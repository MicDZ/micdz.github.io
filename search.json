[{"title":"感知机模型学习笔记","path":"/article/Perceptron-notes/","content":"感知机模型和其相关算法笔记。\n\n<!-- more -->\n\n## 感知机\n\n* 输入空间： $\\mathcal X\\subseteq R^n$ ；输入：$x=(x^1, x^2, ..., x^n)^T\\in\\mathcal X$\n* 输出空间： $\\mathcal Y=\\{+1, -1\\}$ ；输出 $y\\in\\mathcal Y$\n* 感知机：\n\n$$\nf(x)=\\mathbb{sign}(w\\cdot x+b)=\n\\begin{cases}\n+1,\\ w\\cdot x+b\\ge0\\\\\n-1,\\ w\\cdot x+b<0\n\\end{cases}\n$$\n\n其中， $w$ 称为权值（Weight）， $b$ 称为偏置（Bias）， $w\\cdot x$ 表示内积。\n\n* 假设空间： $\\mathcal F=\\{f|f(x)=w\\cdot x+b\\}$\n\n线性方程：\n\n$$\nw\\cdot x+b=0\n$$\n\n法向量： $w$，截距： $b$ 。\n\n区分正负的是特征空间 $\\mathrm R^n$ 中的一个超平面 $\\mathrm S$ 。这个超平面是 $n-1$ 维的。\n\n例如：当n=3时，可以利用2维的平面将三维空间划分为两个部分。我们可以感性地理解更高维的情况。\n\n![image-20230101111006069](/img/Perceptron/1.png)\n\n## 学习策略\n\n要求：数据集线性可分\n\n对于给定的数据集 $T=\\{(x_1,y_1),(x_2,y_2),...,(x_N,y_n)\\}$\n\n若存在某个超平面 $S$\n\n$$\nw\\cdot x+b=0\n$$\n\n能够将数据集的正负实例点完全正确的划分到超平面两侧，即\n\n$$\n\\begin{cases}\ny_i=+1& w\\cdot x_i+b>0\\\\\nyi=-1& w\\cdot x_i+b<0\n\\end{cases}\n$$\n\n那么称数据集线性可分，否则不可分。\n\n### 定义感知机的损失函数\n\n定义 $\\forall x_0\\in\\mathrm R^n$ 到 $\\mathrm S$ 的距离：\n\n$$\n\\frac{1}{||w||}|w\\cdot x_0+b|\n$$\n\n若 $x_0$ 是正确分类点：\n\n$$\n\\frac{1}{||w||}|w\\cdot x_0+b|=\n\\begin{cases}\n\\frac{w\\cdot x_0+b}{||w||} & y_0=+1\\\\\n-\\frac{w\\cdot x_0+b}{||w||} & y_0=-1\n\\end{cases}\n$$\n\n若 $x_0$ 是错误分类点：\n\n$$\n\\frac{1}{||w||}|w\\cdot x_0+b|=\n\\begin{cases}\n-\\frac{w\\cdot x_0+b}{||w||} & y_0=+1\\\\\n\\frac{w\\cdot x_0+b}{||w||} & y_0=-1\n\\end{cases}=\\frac{-y_0}{||w||}|w\\cdot x_0+b|\n$$\n\n误分类点 $x_i$ 到 $\\mathrm S$ 的距离：\n\n$$\n-\\frac{-y_i}{||w||}|w\\cdot x_i+b|\n$$\n\n所有误分类点到 $\\mathrm S$ 的距离：\n\n$$\n-\\frac{1}{||w||}\\sum y_i|w\\cdot x_i+b|\n$$\n\n系数 $-\\frac{1}{||w||}$ 不影响算法。终止点是 $\\mathrm S=0$ 。\n\n## 梯度下降法\n\n求解无约束最优化问题\n\n梯度：指某一函数在该点处最大的方向导数，沿着该方向可以取得最大的变化率。\n\n$$\n\\nabla=\\frac{\\partial f(\\theta)}{\\partial\\theta}\n$$\n\n若 $f(\\theta)$ 为凸函数，则可以通过梯度下降法进行优化取得最小值：\n\n$$\n\\theta^{(k+1)}=\\theta^{(k)}-\\eta\\nabla f(\\theta^{(k)})\n$$\n\n其中 $\\eta$ 指步长。\n\n### 算法\n\n输入：目标函数 $f(\\theta)$ ，步长 $\\eta$ ，精度 $\\epsilon$ 。\n\n输出： $f(\\theta)$ 的极小值点\n\n1. 选取初始值 $\\theta^{(0)}\\in\\mathrm R^n$ ，置 $k=0$ 。\n2. 计算 $f(\\theta^{(k)}$ 。\n3. 计算梯度 $\\nabla f(\\theta^{(k)})$ 。\n4. 置 $\\theta^{(k+1)}=\\theta^{(k)}-\\eta\\nabla f(\\theta^{(k)})$ ，计算 $f(x^{(k+1)})$  ，当 $||f(\\theta^{(k+1)}-f(\\theta^{(k)}))||<\\epsilon$ 或者 $||\\theta^{(k+1)}-\\theta^{(k)}||<\\epsilon$ 时停止迭代 $\\theta^*=\\theta^{(k+1)}$ 。\n5. 否则 $k=k+1$ ，继续第3步\n\n计算梯度：\n\n* 单变量\n\n  $f(x)$ 那么 $\\nabla_x=\\frac{\\partial f}{\\partial x}=\\frac{\\mathrm df}{\\mathrm dx}$ 。\n* 多变量\n\n  $$\n  F(\\Theta)=5\\theta_1^2+2\\theta_2+\\theta_3^4, \\Theta=(\\theta_1,\\theta_2,\\theta_3)^T\n  $$\n\n  分别对三个变量求偏导。\n\n  $$\n  \\nabla_{\\theta_1}=\\frac{\\partial F(\\Theta)}{\\partial\\theta_1}=10\\theta_1\\\\\n  \\nabla_{\\theta_2}=\\frac{\\partial F(\\Theta)}{\\partial\\theta_2}=2\\\\\n  \\nabla_{\\theta_3}=\\frac{\\partial F(\\Theta)}{\\partial\\theta_3}=4\\theta^3\n  $$\n\n  得出\n\n  $$\n  \\nabla_\\Theta=(10\\theta_1,2,4\\theta_3^3)^T\n  $$\n\n一个例子：\n![image-20230101114811607](/img/Perceptron/2.png)\n\n## 原始形式算法\n\n训练数据集： $T=\\{(x_1,y_1),(x_2,y_2),...,(x_N,y_n)\\}$ 其中，$x_i\\in\\mathcal X\\subseteq\\mathrm R^n,y_i\\in\\{+1,-1\\}$\n\n损失函数： $L(w,b)=-\\sum_{x_i\\in M}y_i(w\\cdot x_i+b)$ ，其中， $M$ 表示所有误分类点的集合。\n\n模型参数估计：\n\n$$\n\\mathop{arg}_{w,b}\\min L(w,b)\n$$\n\n![image-20230101210204369](/img/Perceptron/3.png)\n\n批量梯度下降需要大量计算。随机梯度下降计算更简便。\n\n### 算法的收敛性\n\n计 $\\hat w=(w^T,b)^t$ ， $\\hat x=(x^T,1)^T$ ，则分离超平面可以写为 $\\hat w\\cdot \\hat x=0$ 。\n\n![image-20230101211834029](/img/Perceptron/4.png)\n\n* 收敛性：对于线性可分的 $T$ ，经过有限次的搜索，可得到将 $T$ 完全分离开的超平面。\n* 依赖性：分离超平面的结果依赖于不同的初值选择，或者迭代过程中不同的误分类点的选择顺序。\n* 对于线性不可分的 $T$ ，迭代结果会发生震荡，无法收敛。\n* 为得到唯一的分离超平面，需增加约束条件。\n\n## 对偶形式的学习算法\n\n在原始形式中，若 $(x_i,y_i)$ 为误分类点，可如下更新参数：\n\n$$\nw\\leftarrow w+\\eta y_ix_i\\\\\nb\\leftarrow b+\\eta y_i\n$$\n\n假设初始值 $w_0=\\mathbf0，b_0=0$ ，对误分类点 $(x_i,y_i)$ 通过上述的公式更新参数，修改 $n_i$ 次后， $w,b$ 的增量分别是 $\\alpha_iy_ix_i$ 和 $\\alpha_iy_i$ ，其中 $\\alpha_i=n_i\\eta_i$ 。\n\n最后学习到的参数为：\n\n$$\nw=\\sum_{i=1}^{N}\\alpha_iy_ix_i\\\\\nb=\\sum_{i=1}^N\\alpha_iy_i\n$$\n\n![image-20230101215409607](/img/Perceptron/5.png)","tags":["数学","机器学习"]},{"title":"深度学习笔记","path":"/article/DeepLearning-notes/","content":"宏观理解机器学习和深度学习。\n\n<!-- more -->\n\n## 机器学习\n\n寻找一个函数\neg：语音识别 声音->文字\n\n### 机器学习的任务\n回归（Regression）：函数输出为数值 \n分类（Classification）：给定一些选项，函数输出为正确的选项\n\n结构化学习（Structured Learning）：获得有结构的物体\n\n## 机器学习的步骤\n\n1. 找一个带未知参数的函数（Function with unkown）\n\n   也被称作模型eg： $y=b+wx_1$ ，其中 $w, b$ 为未知参数\n\n2. 从训练数据中定义Loss（Define loss from training data）\n\n   Loss是关于未知参数的函数 $L(w,b)$ ，用来衡量未知参数好不好\n\n   真实的值称为Label，预测值与真实值的差即为计算误差\n\n   累计差距的方式有很多种：MAE（绝对值误差），MSE（均方误差）\n\n   误差等高线图（Error Surface）\n\n3. 优化（Optimization）\n\n   $w^*,b^*=arg\\min_{w,b}L$\n\n   梯度下降（Gradient Descent）：\n\n   先假设未知参数只有 $w$ 。先随机取定一个 $w^0$（利用遗传算法）。\n\n   计算 $L$ 对 $w^0$ 的偏导（ $w_0$ 在误差曲线上的切线斜率）\n   $$\n   w^1=w^0-\\eta\\frac{\\partial L}{\\partial w}|_{w=w^0}\n   $$\n   $\\eta$ 被称为学习速率(learning rate)。\n\n   这种机器学习中需要自己设定的东西称为超参数（hyperparameters）\n\n   反复进行上述的操作。\n\n   停止：达到最大迭代速率或找到某一极值（Local minima），无法保证一定找到全局最优解。\n\n   当有多个参数时。先随机取定 $w^0,b^0$。\n\n   计算 $L$ 对 $w^0$ 和 $b^0$ 的偏导。\n   $$\n   w^1=w^0-\\eta\\frac{\\partial L}{\\partial w}|_{w=w^0, b=b^0}\\\\\n   b^1=b^0-\\eta\\frac{\\partial L}{\\partial b}|_{w=w^0, b=b^0}\n   $$\n   反复更新 $w,b$ 。\n\n   ![image-20221230142534137](/img/DeepLearning/1.png)\n\n   \n\n$$\ny=b+\\sum_{j=1}^7w_jx_j\n$$\n\n被称为线性模型\n\n\n\n分段线性折线（常数+一系列折线）\n\n![image-20221230143300146](/img/DeepLearning/2.png)\n\n1. 找一个带未知参数的函数，我们用Sigmoid函数来表示这类折线\n\n$$\ny=c\\frac{1}{1+e^{-(b+wx_1)}}=c\\ sigmoid(b+wx_1)\n$$\n\nw——斜坡的坡度\n\nb——相位\n\nc——高度\n$$\ny=b+\\sum_ic_isigmoid(b_i\\sum_jw_{ij}x_j)\n$$\n$w_ij$ 表示的是第 $i$ 个函数中 $x_j$ 对应的权重。\n\n![image-20221230144348929](/img/DeepLearning/3.png)\n\n![image-20221230144437303](/img/DeepLearning/4.png)\n\n![image-20221230144637959](/img/DeepLearning/5.png)\n\n![image-20221230144702222](/img/DeepLearning/6.png)\n\n2. 定义Loss\n\n$$\ne=|y-\\hat y|\\\\\nLoss:L=\\frac{1}{N}\\sum_ne_n\n$$\n\n3. 优化\n\n   ![image-20221230145242276](/img/DeepLearning/7.png)\n\n![image-20221230145316288](/img/DeepLearning/8.png)\n\nReLU模型：\n$$\ny=b+\\sum_{2i}c_i\\max(0, b_i+\\sum_jw_{ij}x_j)\n$$\n称为激活函数。激活函数的部分称为神经元，很多神经元组成这个模型，叫做神经网络。很多隐藏层就形成了深度学习。","tags":["数学","深度学习"]},{"title":"贝叶斯滤波学习笔记","path":"/article/bayesian-filtering/","content":"贝叶斯滤波可以用于去除观测信息中的噪音。\n\n<!-- more -->\n\n## 贝叶斯学派\n\n贝叶斯理论将人们的主观经验称为**先验概率**，在主观经验的基础上的到某个结果的概率叫做**似然概率**，而将那个结果作用于先验信息，最终更新先验概率得到的预测结果的概率叫做**后验概率**。\n\n贝叶斯定理的公式：\n$$\n\\begin{aligned}\nP(H|E)=&\\frac{P(HE)}{P(E)}=\\frac{P(H)P(E|H)}{p(E)}\\\\\n=&\\frac{P(H)P(E|H)}{\\sum P(H_i)P(E|H_i)}=\\eta P(H)P(E|H)\n\\end{aligned}\n$$\n\n\n![](/img/bayesian-filtering/1.png)\n\n其中 $P(H)$ 为先验概率， $P(E|H)$ 为似然概率。\n\n**举一个实际例子：**\n\n比如此时想要测量气温，根据经验我们有以下先验概率，记为 $P(T$ )：\n![](/img/bayesian-filtering/2.png)\n\n那么假设温度计显示的是29度，我们分析今天气温是30度的概率。\n\n$P(T=30)$ ：先验概率，即今天是30读的概率。对应 $P(H)$ 。\n\n$P(T_m=29|T=30)$ ：似然概率，即今天气温是30度条件下温度计是29度的概率。对应 $P(E|H)$ 。\n\n$P(T_m=29)$ ：所有可能的温度下温度计时29度的概率之和。对应 $P(E)$ 。\n\n$P(T=30|T_m=29)$ ：后验概率，即温度计是29度条件下今天气温是30度的概率。对应 $P(H|E)$ 。\n$$\nP(T=30|T_m=29)=\\frac{P(T_m=29|T=30)P(T=30)}{P(T=30)}\n$$\n\n**将离散的形式拓展到连续：**\n\n将概率化为一个具体的区间，先求 $P(X<x|Y=y)$ ，并转换为求和，则有：\n$$\nP(X<x|Y=y)=\\sum_{u=-\\infty}P(X=u|Y=y)=\\sum_{u\\to-\\infty}^{x}\\frac{P(Y=y|X=u)P(X=u)}{P(X=y)}\n$$\n\n将概率转换为一个极小的区间：\n$$\nP(X<x|Y=y)=\\lim_{\\varepsilon\\to0}\\sum^x_{u=-\\infty}\\frac{P(y<Y<y+\\varepsilon|X=u)P(u<X<u+\\varepsilon)}{P(y<Y<y+\\varepsilon)}\n$$\n将小区间下的概率转换为密度函数在小区间上的积分：\n$$\nP(X<x|Y=y)=\\lim_{u\\to-\\infty}\\sum_{u=-\\infty}^x\\frac{\\int_y^{y+\\varepsilon}f_{Y|X}(y|u)\\mathrm{d}y\\int_u^{u+\\varepsilon}f_X(u)\\mathrm{d}u}{\\int_y^{y+\\varepsilon}f_Y(y)\\mathrm{d}y}\n$$\n其中 $f$ 为概率密度函数。\n\n\n\n再运用中值定理：\n$$\nP(X<x|Y=y)=\\lim_{\\varepsilon\\to0}\\sum_{u=-\\infty}^x\\frac{[f_{Y|X}(\\xi_1|u)\\varepsilon][f_X(\\xi_2)\\varepsilon]}{f_Y(\\xi_3)\\varepsilon}\n$$\n其中：\n$$\n\\xi_1\\in(y,y+\\varepsilon)\\\\\n\\xi_2\\in(u,u+\\varepsilon)\\\\\n\\xi_3\\in(y,y+\\varepsilon)\n$$\n易知：\n$$\nP(X<x|Y=y)=\\lim_{\\varepsilon\\to0}\\sum_{u=-\\infty}^x\\frac{f_{Y|X}(y|x)f_X(x)}{f_Y(y)}\n$$\n转换为积分形式：\n$$\nP(X<x_0|Y=y)=\\int_{-\\infty}^{x_0}\\frac{f_{y|x}f_X{x}}{f_Y(y)}=\\int_{-\\infty}^{x_0}f_{X|Y}(x|y)\\mathrm{d}x\n$$\n两边消去积分，得到连续随机变量下的贝叶斯公式：\n$$\nf_{X|Y}(x|y)=\\frac{f_{Y|X}(y|x)f_X(x)}{f_Y(y)}\n$$\n\n## 贝叶斯滤波\n\n贝叶斯滤波（及衍生出的卡尔曼、粒子）基本思想：对观测和预测的数据做加权平均。\n\n概率是怎么得来的？\n\n随着实验的外部观测修正最初的概率值，最终逼近实验概率的真实值。\n\n先验概率->（观测）后验概率\n\n对于每一次实验，贝叶斯理论取消了独立性的概念，因此每一次实验的变量都是相关的，即：\n$$\nx_k=f(x_{k-1})\n$$\n并且每一次实验的概率也相关，即：\n$$\nP(x_k)=F(P(x_{k-1}))\n$$\n$x_k$预测值，$P(x_k)$ 先验概率\n\n优点：完美解决了多传感器的数据融合和滤波问题\n\n缺点：无穷积分电脑做不出来\n\n\n![](/img/bayesian-filtering/3.png)\n\n**改进**：\n\n卡尔曼滤波：把随机变量间的关系函数f限定为线性函数 $X_k=AX_{k-1}+B$\n\n粒子滤波：用蒙特卡洛积分法近似计算非线性函数 $f$","tags":["数学"]},{"title":"OpenCV学习笔记","path":"/article/OpenCV-notes/","content":"记录一些OpenCV的基本操作。\n\n持续更新中。\n\n<!-- more -->\n\n\n## 基础知识\n\n### 图像的时空域表示\n\n**像素**：(x,y)被赋予一个灰度值。图像在计算机中一般以矩阵的形式存储。\n\n**位深**：存储一个像素所用的位（bit）被称为位深，存储一个像素使用的位越多，色彩越丰富。\n\n**通道**：图像一个颜色通道表征一个维度的信息。例如RGB颜色空间中，有RGB三个通道，每个通道都是一个矩阵，矩阵中的每一个元素保存着0-255的值，对应不同的颜色分量。\n\n**色彩空间**：RGB有局限性，RGB颜色的三个分量与亮度密切相关。只要亮度改变，三个分量都需要相应地改变，没有更直观的方式来表达。RGB是一种均匀性比较差的颜色空间，对于某一种颜色，我们很难推断出较为精确地三个分量数值来表示。还有HSV、HLS、YUV、LAB等色彩空间。\n\n**HSV色彩空间**：Hue（色调、色相），Saturation（饱和度、色彩纯净度），Value（明度）。\n\n\n\n### RGB转换为HSV\n先将RGB转换为0-1之间\n$$\nR=R/255\\\\\nG=G/255\\\\\nB=B/255\n$$\n\n利用以下公式计算H、S、V\n$$\nV=\\mathrm{max}(R,G,B)\\\\\nS=\n\\begin{cases}\n\\frac{V-\\mathrm{min}(R,G,B)}{V}, V\\not=0\\\\\n0, V=0\n\\end{cases}\\\\\nH=\n\\begin{cases}\n60\\times(G-B)/(V-\\mathrm{min}(R,G,B)), V=R\\\\\n120+60\\times(B-R)/(V-\\mathrm{min}(R,G,B)), V=G\\\\\n240+60\\times(R-G)/(V-\\mathrm{min}(R,G,B)), V=B\n\\end{cases}\n$$\n\n如果H小于零，得到的最终的H值还要加上360。\n### 图像的频域表示\n\n将图像的灰度分布函数经过离散傅里叶变换即可得到图像的频率分布函数。\n\n对图像而言，图像的边缘部分是突变部分，变化较快，因此反应在频域上是高频分量。为使图像边缘更加平滑，可以滤掉高频分量，即低通滤波器。相反，若需要提取出图像的边缘部分，可以滤掉低频分量，即高通滤波器。通常进行边缘提取或图像锐化。\n\n这种方法在实际中不可取，计算量太大，更实用的办法是将设计好的mask做idft得其时空域表示，再将其域原图像**卷积**，可得到滤波后的图像。（卷积定理：**频域相乘=时域相卷**）\n\n### 图像的滤波\n\n高通滤波：允许高频通过\n\n低通滤波：允许低频通过\n\n带通滤波：允许一定频率通过\n\n带阻滤波：阻止一定频率通过\n\n全通滤波：允许所有频率通过，仅仅改变相位关系\n\n陷波滤波：阻止一个狭窄频率范围通过\n\n\n\n## 图像处理\n\n![image-20221119204133760](/img/opencv/1.png)\n\n\n### 基本图像操作\n```cpp\nSrc=Mat::zeros(200, 200, CV_8UC3)\n```\n8U：8位无符号数\nC3：3个通道\n\n`B=src.at<Vec3b>(5,3)[0];`取出图像中五行三列的B通道。\n\nVec3b存储三通道图像像素时所用的数据结构。\n\n### 形态学变换\n\n**腐蚀**\n\n将图像与卷积核相卷积，计算卷积覆盖的图像区域中的最小值，并将赋给锚点像素。\n\n可以消除图像中的一些毛刺。\n\n**膨胀**\n\n将图像与卷积核相卷积，计算卷积覆盖的图像区域中的最大值，并将其赋给锚点像素。\n\n可以用于消除图像中的缺陷。\n\n![image-20221119204924991](/img/opencv/2.png)\n\n\n**ROI区域**\n方法一：\n\n```cpp\nimageROI=image(Rect(500,250,rec.cols,rec.rows));\n```\n\n利用`Rect`函数，返回一个矩形区域，类型为`N2cv5Rect_IiEE`，eg：`[20 x 20 from (1, 1)]`。\n\n方法二：\n\n```cpp\nimageROI=image(Range(250,250+rec.rows),Range(200,200+rec.cols));\n```\n\n\n### 输入与输出\n\n* imread\n\n```cpp\nMat imread(const string& filename, intflags=1 );\n```\n\nflags的参数含义如下：\n\n```cpp\nenum\n{\n/* 8bit, color or not */\n   LOAD_IMAGE_UNCHANGED  =-1,\n/* 8bit, gray */\n   LOAD_IMAGE_GRAYSCALE  =0,\n/* ?, color */\n   LOAD_IMAGE_COLOR      =1,\n/* any depth, ? */\n   LOAD_IMAGE_ANYDEPTH   =2,\n/* ?, any color */\n   LOAD_IMAGE_ANYCOLOR   =4\n};\n```\n\n* namedWindow\n\n用于创建一个有名字的窗口。\nflags默认为`WINDOW_AUTOSIZE`。一般不需要调整。\n\n* imshow\n\n```cpp\nvoid imshow(const string& winname, InputArray mat);\n```\n\n这里的`InputArray`会进行枚举，匹配到相应的类型。可以理解为通用的矩阵类。\n\n* imwrite\n\n```cpp\nbool imwrite(const string& filename,InputArray img, const vector<int>& params=vector<int>() );\n```\n\n最后一个参数决定图像质量。\n\n对于JPEG格式的图片，这个参数表示从0到100的图片质量（IMWRITE_JPEG_QUALITY），默认值是95.\n对于PNG格式的图片，这个参数表示压缩级别（IMWRITE_PNG_COMPRESSION）从0到9。较高的值意味着更小的尺寸和更长的压缩时间，而默认值是3。\n对于PPM，PGM，或PBM格式的图片，这个参数表示一个二进制格式标志（IMWRITE_PXM_BINARY），取值为0或1，而默认值是1。\n\n具体的用法如下：\n\n```cpp\n\tstd::vector<int> compression_params;\n\tcompression_params.push_back(IMWRITE_JPEG_QUALITY);  //选择jpeg\n\tcompression_params.push_back(100); //在此填入你要的图片质量\n\timwrite(\"test.jpg\", destImage1, compression_params);\n```\n\n### 查找轮廓\n\n轮廓`contours`的定义为`vector<vector<Point>> contours`是一个嵌套的向量。向量的每一个元素保存了一组由连续的Point点构成的点的向量组，每一组Point就是一个轮廓。\n\n参数`hierarchy`也是一个向量，向量内有四个整数，整数代表轮廓的标号，与contours中的索引相同。从hierarchy[i][0]到hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。如果没有对应的轮廓值为-1。","tags":["数学","OpenCV"]},{"title":"电路运放、IO电路","path":"/article/embedded1/","content":"运算放大器、IO电路学习\n\n<!--more-->\n\n## 运算放大器\n\n&emsp;&emsp;运算放大器（简称“运放”）是具有很高放大倍数的电路单元。在实际电路中，通常结合反馈网络共同组成某种功能模块。它是一种带有特殊耦合电路及反馈的放大器。其输出信号可以是输入信号加、减或微分、积分等数学运算的结果。由于早期应用于模拟计算机中用以实现数学运算，因而得名“运算放大器”。\n\n![](/img/embedded1/图片1.png)\n\n![](/img/embedded1/图片2.png)\n\n&emsp;&emsp;当信号从“+”端口输入时，输出信号与输入信号同向；当信号从“-”端口输出时，输出信号与输入信号反相。两个端口同时输入信号时，进行减数运算。\n\n\n\n### 开环电路\n\n$$\nV_{out}=(V_+-V_-)\\times Aog\n$$\n\n\n\n&emsp;&emsp;Aog代表运算放大器的开环回路差动增益，这个增益非常大，所以非常微小的讯号都可能导致输出饱和。\n\n\n\n### 闭环负反馈\n\n#### 反相比例放大电路\n\n&emsp;&emsp;将运算放大器的反相输入端与输出端连接起来，放大器电路就处在负反馈组态的状况，此时通常可以将电路简单地称为闭环放大器。通俗地说，也就是**放大器将输入信号反转并改变它**。\n\n![](/img/embedded1/图片3.webp)\n\n&emsp;&emsp;输入通过电阻 R1 提供给反相输入端，非反相端接地。输出通过反馈电阻 Rf 反馈到反相输入端。\n\n这里利用理想运算放大器的两条假设：\n\n1. “虚断”：负反馈网络自己的特性能够使Error达到最小，认为 $V_1$ 与  $V_2$ 的电流信号恒为0\n2. “虚短”：差分输入电压为零，即 $V_1-V_2=0$ （虚拟接地）\n\n&emsp;&emsp;反相运算放大器闭环增益方程推导如下：\n$$\n\\begin{aligned}\ni&=\\frac{V_{in}-V_{out}}{R_{in}+R_{f}}\\\\\ni&=\\frac{V_{in}-V_2}{R_{in}}=\\frac{V_2-V_{out}}{R_f}\n\\end{aligned}\n$$\n对上两式求解方程得：\n$$\n\\begin{aligned}\n\\frac{V_{out}}{V_{in}}=-\\frac{R_f}{R_{in}}\n\\end{aligned}\n$$\n&emsp;&emsp;通过这个式子，我们可以知道：\n\n* 反相放大器的增益为负。\n* 反相放大器增益取决于所使用的电阻值\n\n#### 同相比例放大电路\n![](/img/embedded1/图片4.webp)\n\n&emsp;&emsp;由于引入电压串联负反馈，可以提高输入电阻，提高程度与反馈深度有关，同时在理想运放条件下，可以看作输入电阻 $R'$ 为无穷大。\n\n&emsp;&emsp;同样利用理想运算放大器的假设，有如下式子：\n$$\n\\frac{V_{in}-0}{R}=\\frac{V_{out}-V_{in}}{R_f}\n$$\n于是可以得出：\n$$\nV_{out}=V_{in}\\times(1+\\frac{R_f}{R})\n$$\n\n#### 差分放大电路\n\n![](/img/embedded1/图片5.webp)\n\n&emsp;&emsp;同样利用理想运算放大器的假设，有如下式子：\n$$\n\\frac{V_5-0}{R_3}=\\frac{V_+-V_5}{R_2}\\\\\n\\frac{V_6-V_-}{R_1}=\\frac{V_{out}-V_6}{R_4}\\\\\nV_5=V_6\\\\\nR_1=R_2\\\\R_3=R_4\n$$\n联立解得：\n$$\nR_3(V_+-V_-)=V_{out}R_1\n$$\n\n#### 积分电路\n\n![](/img/embedded1/图片6.png)\n\n&emsp;&emsp;对瞬时电流进行分析：\n$$\ni_c=C\\frac{\\mathrm{d}u_c}{\\mathrm{d}t}\n$$\n\n$$\n\\frac{u_I}{R}=-C\\frac{\\mathrm{d}u_0}{\\mathrm{d}t}\n$$\n\n移项积分得：\n$$\nu_0=-\\frac{1}{RC}\\int u_I\\mathrm{d}t\n$$\n\n#### 微分电路\n\n![](/img/embedded1/图片7.png)\n\n&emsp;&emsp;分析思路同积分电路。\n$$\ni=C\\frac{\\mathrm du_I}{\\mathrm d t}=-\\frac{u_0}{R}\n$$\n得到：\n$$\nu_0=-RC\\frac{\\mathrm d u_1}{\\mathrm d t}\n$$\n\n## GPIO电路\n\n\n![](/img/embedded1/图片8.png)\n\n&emsp;&emsp;GPIO是一个数字信号管脚得集成电路，可被用于输入输出。\n\n#### GPIO的输入模式\n\n1. 输入浮空模式\n\n   ![](/img/embedded1/图片9.jpeg)\n\n电平加在I/O口上，电平输入到施密特触发器进行整形后送入到输入数据寄存器，供cpu进行读取。（输入浮空模式下，上拉下拉电阻开关关闭）\n\n2. 输入上拉模式\n\n   ![](/img/embedded1/图片10.webp)\n\n   \n\n输入上拉模式下，上拉电阻开关打开，下拉电阻开关关闭。不确定的信号通过一个电阻嵌位在高电平（电阻大概在30-50k）。其余与输入浮空模式一致。\n\n3. 输入下拉模式\n\n![](/img/embedded1/图片11.webp)\n\n\n\n输入下拉模式下，下拉电阻开关打开，上拉电阻开关关闭。外部接入的电平会通过下拉电阻到地。其余与浮空输入模式一致。\n\n4. 模拟输入模式\n\n![](/img/embedded1/图片12.webp)\n\n\n\n上拉下拉电阻是无效的。模拟输入模式下，外部的电压是模拟量，并不是以电平的形式输入。其余与输入浮空模式一致。\n\n#### GPIO的输出模式\n\n1. 开漏输出模式\n\n![](/img/embedded1/图片13.webp)\n\n\n\ncpu写数据进位设置位清除寄存器，然后映射到输出数据寄存器。输出数据寄存器连通到输出控制电路。若输出高电平（1），N-MOS管关，I/O口端口的电平不会由输出的1来决定，电平由外部上拉下拉决定。（其输出的电平也可以通过输入电路读取进来）\n\n2. 开漏输出复用模式\n\n![](/img/embedded1/图片14.webp)\n\n开漏复用输出模式输出控制电路之前的来源由复用功能输出，即来自片上外设模块。其余与开漏输出模式一致。\n\n3. 推挽输出模式\n![](/img/embedded1/图片15.webp)\n推挽输入模式控制输出的寄存器与开漏输出一致。若输出1，P-MOS管导通，N-MOS管截止，I/O口输出1。若输出0，N-MOS管导通，P-MOS管截止，I/O口输出0。\n\n4. 推挽复用输出模式·\n![](/img/embedded1/图片16.webp)\n推挽复用输出模式通过复用功能输出，其他与推挽输出模式一致。\n\n注：推挽输出可以输出强高低电平，连接数字器件。而开漏输出只可以输出强低电平，高电平得靠外部电阻拉高。\n\n每组GPIO端口的寄存器包括两个32位配置寄存器，两个32位数据寄存器，一个32位置位/复位寄存器，一个16位复位寄存器，一个32位锁定寄存器。","tags":["模电"]},{"title":"Hello, world","path":"/article/Hello-World/","content":"欢迎来到MicDZ's blog，博客采取全新[Stellar](https://xaoxuu.com/wiki/stellar/)主题，部分内容将会更新。\n\n<!-- more -->\n\n如果您觉得博客中有任何问题，希望您提出宝贵的意见。"},{"title":"2021回顾 & 2022展望","path":"/article/2022-resolution/","content":"2021年，喜中有忧，重逢希望。\n\n<!--more-->\n\n## 前言\n\n如果说我的[2020年](/article/2021-resolution/)是一个迷惑魔幻的一年，那么我的2021年绝比2020年清醒。总的来说是，喜中有忧，重逢希望。\n\n现在是2021年12月31日20:41，距离高考还有157天，和前几年写年终总结相比，今天我的心态完全不同。\n\n## 2020回顾\n\n### 收获\n\n上半年在1912班的高二生活十分丰富多彩。由于是在平行班，学习基本没有什么压力，这让我们有了很多课余的时间参与到学校的活动中。我参加了学校科技节的三个项目——水火箭卫星发射与回收、生物微生物作画、化学微视频大赛，在学校范围获得了不错的成绩。其中，水火箭大幅打破了校记录，化学微视频获一等奖，生物微生物作画获特等奖。","tags":["Resoultion"],"categories":["Review & Resoultion"]},{"title":"配子一定比例致死的人类遗传病计算问题","path":"/article/thoughts-of-a-biological-problem/","content":"半年没更博，文化课战士回来报道。前言老师同学们好！{% note color:yellow 本人高中生，有关生物的见识仅局限高中范围，本文有关专有用语可能不够准确。本文旨在分享我对此前期考复习前的一道题目的思考。%}{% note color:cyan 题目内容如下：右图是甲、乙两种单基因遗传病的家系图，家系中无突变发生且其中一种病为伴X遗传。已知正常人群中乙病携带者占1/6，且含乙病基因的雄配子半数致死。6号个体与人群中正常男性结婚，生育一个两病兼患男孩的概率是( )。A. 1/184 B. 1/192 C. 1/368 D. 1/384%}这道题的最初来源我没有能够找到，只在[1]中有所发现。问题分析甲病有关基因用 $X^A$ 与 $X^a$ 表示，乙病有关基因用 $B$ 与 $b$ 表示。对于甲病的结果我不存在质疑，很容易得出该夫妇生出一个患甲病男孩的概率$$P_1=\\frac{1}{2}\\times\\frac{1}{2}\\times\\frac{1}{4}=\\frac{1}{16}$$接下来仅需计算该夫妇所生育的孩子中患乙病的概率 $P_2$，通过自由组合定律即可得出该题的答案$$P=P_1\\times P_2$$问题的焦点在于如何计算 $P_2$ 。计算机模拟结果将原问题抽离成为与现实相符的一个模型。假设现有一个大小为 $N$ 的男性正常群体。我将男性每一个个体从 $1$ 至 $N$ 编号记为 $a_i=i$ 。为了满足题目条件，另 $\\forall a_i\\equiv 1 \\pmod{6}$ 的男性个体为乙病的携带者。然后随机生成一个数 $x\\in [1,N]$ 表示个体6与编号为 $x$ 的男性个体交配。如果 $x\\equiv 1 \\pmod{6}$ 则表示个体6与一男性乙病的携带者交配。考虑该男性的配子。若不考虑致死该男性配子 $B$ 与 $b$ 应为 $1:1$ 。现 $b$ 半数致死，则该男性配子比例应为 $2:1$ 。因而再生成一个随机数 $y\\in[1,3]$ ，如果所得随机数为 $1$ 则此次模拟该男性产生的配子为 $b$ ，其余情况则为 $B$ 。如果 $x$ 不满足 $x\\equiv 1 \\pmod{6}$ 。则该男性产生的配子一定为 $B$。将男性产生的配子与女性的配子组合即可得到后代的基因型。将随机生成 $x$ 的步骤重复 $\\Omega$ 次，记录下其中后代为 $bb$ 的次数 $T$ 即可得到 $$P_2=\\frac{T}{\\Omega}$$计算机实现代码如下：green,c++代码```cpp#include<iostream>#include<cstdio>#include<cmath>#include<cstring>#include<ctime>#include<cstdlib>using namespace std;#define REP(i,e,s) for(register int i=e; i<=s; i++)#define DREP(i,e,s) for(register int i=e; i>=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)int read() {\tint x=0,f=1,ch=getchar();\twhile(ch>'9'ch<'0'){if(ch=='-')f=-1;ch=getchar();}\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\treturn x*f;}const int MAXN=1000000+10;const int N=1000000;int a[MAXN];int _rand(int l,int r) { return rand()%(r-l+1)+l;}int main() { freopen(\"data.out\",\"w\",stdout);\tsrand(time(0)); printf(\"%d\\n\",_rand(1,2)); const int omega=1000000; int T=0; for(int i=1; i<=omega; i++) { int x=_rand(1,N); if(x%6==1) { int y=_rand(1,3); if(y==1) {T++; printf(\"x:%d y:%d T+1\\n\",x,y); } else printf(\"x:%d y:%d T+0\\n\",x,y); } else printf(\"x:%d\\n\",x); } printf(\"Ω:%d T:%d\\n\",omega,T);\treturn 0;}```green,python代码```pythonimport randomT=0Omega=1000000N=1000000fp=open(\"./data.txt\",\"w+\")for i in range(1,Omega): x=random.randint(1,N) if(x%6==1): y=random.randint(1,3) if(y==1): T+=1 print(\"x:\",x,\" y:\",y,\" T+1\",file=fp) else: print(\"x:\",x,\" y:\",y,\" T+0\",file=fp) else: print(\"x:\",x,file=fp)print(\"Ω:\",Omega,\" T:\",T,file=fp)fp.close()```计算机模拟的结果如下：单机此处下载 /data.txt最终 $\\Omega=1000000$ $T=55506$。$$P_2=\\frac{T}{\\Omega}=\\frac{55506}{1000000}=0.055506\\approx\\frac{1}{18}$$参考答案的计算方式我在这里简单描述一下参考答案的计算方式。对于一个人群，其中有 $\\frac{1}{6}$ 的正常男性，则可知男性中 $BB:Bb=5:1$ 。假设不考虑考虑男性配子致死的情况，则该人群中正常男性产生的配子比例 $B:b=11:1$ 。又由于有一半的 $b$ 致死，则比例为 $B:b=11:0.5=22:1$ 。则男性群体中产生 $b$ 配子的概率为 $P_2=\\frac{1}{23}$ 。这样得出的答案$$P=P_1\\times P_2=\\frac{1}{16}\\times\\frac{1}{23}=\\frac{1}{368}$$应选C。然而，这样计算得来的 $P_2$ 与计算机模拟的结果不同。我认为的计算方式对于个体6，记她所遇到的男性个体为乙病携带者的事件为 $S$ ，所遇到不为乙病携带者的事件为 $T$ 。显然 $P(S)=\\frac{1}{6}$ ， $P(T)=\\frac{5}{6}$ 。将正常男性群体产生的配子分为两类，一类为纯合子产生的配子 $B_1$ ，另一类为杂合子产生的配子 $B_2$ 与 $b_2$ 。然后再考虑个体6所遇的配子的问题。记个体6的配子 $b$ 与 $b_2$  相遇的事件为 $Y$ 。显然 $$P_2=P(SY)=P(S)\\times P(YS)=\\frac{1}{6}\\times\\frac{1}{3}=\\frac{1}{18}$$简单来说，就是个体6有 $\\frac{1}{6}$ 的可能与一名携带乙病基因的男性交配，而与一名携带乙病基因的男性交配后代为乙病的概率为 $\\frac{1}{3}$ ，因而个体6与人群中正常男性交配后代患乙病的概率 $P_2=\\frac{1}{3}\\times\\frac{1}{6}$ 。两种计算方式答案不同的分析参考答案错误的可能原因对于参考答案的计算方式，我们可以理解为，将人群中所有正常男性的配子放在一起，再从这些配子中随机选取一个。这样可以解释为什么分母为 $23$ 。这样对于存在致死的男性的配子，他们的配子在整个男性人群中则会少去致死的那一部分，使存在致死男性的竞争力减弱。简单来说，例如这里有 $12$ 名男性，其中 $10$ 人为 $BB$ ， $2$ 人为 $Bb$ 。假设每个人产生两个配子。一共会产生 $12\\times2-1=23$ 个配子。则产生配子的比例为 $B_1:B_2:b_2=20:2:1$ 。如果直接从这 $23$ 个配子中计算比例，那么对于 $Bb$ 男性人群与个体6交配的概率为 $\\frac{B_2+b_2}{B_1+B_2+b_2}=\\frac{1+3}{23}<\\frac{1}{6}$ 。这与事实是矛盾。事实情况应保证个体6与任意男性交配的概率相当，即个体6与 $Bb$ 男性群体交配的比例应当为 $\\frac{1}{6}$ 。解决这一问题就需要分步进行讨论。两种计算方式的适用性如果对于人类群体而言，我认为，应当使用后面的计算方式。如果对象是花粉传播的植物，若假设所有不携带乙病基因的雄性植株个体产生的花粉数相同，而携带乙病基因的雄性植株产生的花粉少 $\\frac{1}{4}$  ，那么携带乙病基因的植株竞争力会减弱，则应当使用参考答案的方式。我的态度{% note 以下为我的态度，可能存在事实性错误 我认为参考答案的计算方法不符合实际，应为答案错误。对于这样一个实际问题，不存在两种答案，更不存在一种更精确一种高级的说法，一定存在唯一正确的答案。对于是否“超纲”的问题，我尚不清楚，但可以肯定的是往年高考出现过配子致死的题目。color:red %}恳请老师同学对我的想法批评指导。与我联系me@micdz.cn。参考资料<span id=\"references-1\"></span><br>1]. [2020学年第一学期浙南名校联盟第一次联考高三年级生物试题卷<span id=\"references-2\"></span><br>鸣谢感谢邓毅萍老师。感谢许锜桐同学。","tags":["生物"],"categories":["Others"]},{"title":"2020回顾 & 2021展望","path":"/article/2021-resolution/","content":"2020梦幻开局，懵逼结束。原谅退役的我已经半年没有更博。:(——应该也没有人会在意我。前言现在是12月31日00:13分，独自一人坐在电脑前回忆过去的一年。不知从何说起。回看2020年终总结，的确像文末的我所说的那样，回忆是非常有意思的一件事情。那时对着电脑的我还是一个对还未知的2020满怀憧憬，对自己竞赛、文化充满信心的少年。全然不知这魔幻的2020完全没有走向我所期望的路线。我没有大E，也招招打得我猝不及防，全部没有防出去。2020回顾难过可能从小受家庭理想主义氛围的熏陶，我带着迷之自信走进2020。2020，残酷的2020，抽打我，将我按在地上，让我带着现实主义沉重的心情准备迈入2021。我彻底明白了，能力差、水平低才是我。过去都是假装努力，我太缺乏毅力与勇气。疫情期间的放纵直接造成了我后续一系列的错误。疫情，真的改变了很多。color:green 2020，专心搞竞赛，省一拿高分，争取省选前列，取得打全国赛银牌水平。（x）强基计划的正式敲定，成为击垮我的最后稻草。决定退组时，我几乎没有痛苦。知道后来，依稀间，我回想起无数个夜晚在荧光屏前挠头发改代码的我，再没能控制自己的伤心爆发……color:red 2020，退组搞文化，文化无起色，分班考试爆炸，错失进入实验班的机会。（√）分班考试 [1]出成绩的那天上午，可能是我这一年最难受的时候，距离目标仅一步之遥，而又触之不及。痛苦、后悔、着急交织。我几乎红着眼走进洛总办公室，卑微地希望他能为我改错的生物大题加上四分，虽然我知道这只是徒劳，但努力去搏总比低头放弃要轻松。结局，当然是被洛总D了一顿，然后强忍泪水回家。CSP2020、NOIp2020。原想画上一个完美句号，结束这一行行刻在我青春里的代码，但……。又一次跪在了`usigned long long`前。CSP2020不用打高精，打了，萎了，NOIp2020该打高精，没打，萎了。NOIp2020 T2爆0，我是傻逼。罢了罢了，大家的2020都比我难过吧，那些抗疫一线的英雄们都坚持下来了，我这又算什么呢……收获重新分班，重新认识一群伙伴，重新开启新一阶段的学习生活。高中生活也丰富多彩了起来，长绳比赛（1912是第一！）、艺术节、元旦晚会（达成成就）、足球赛……这样才是青春！平行班的学习的确少了许多压力，学习也更自由一些，也更便于好好落实基础。在1912班碰到了非常多值得学习的大佬，在大佬带领下，我对文化课学习也找到了一些感觉，改变了以前一些错误的观念，也取得了一些令我意想不到的成绩。希望这样的节奏能够保持下去。悲哀2020年的下学期，学校发生了一些事情……只愿，逝者安息，生者奋发。2021展望祖国富强相信在中国抗疫取得巨大成功的背景下，祖国可以弯道超车，实现新的飞跃！（希望湾湾早日回归学习保持节奏，重视基础，注重落实。扎实掌握好每一个知识点。平和心态面对每一次考试的过程和结果。后记感谢过去一年与我一起跨过困难的朋友，感谢家长老师的帮助，感谢在失败后不放弃的自己。这里立个flag，文化成绩在下一个学期稳定达到年级前100。引用<span id=\"references-1\"></span><br>数学63(100)，物理77(100)。两门自认为擅长的科目筐瓢，严重拖后腿。","tags":["Resoultion"],"categories":["Review & Resoultion"]},{"title":"windows10的Ubuntu子系统","path":"/article/windows10-ubuntu20/","content":"在win10上运行最新的Ubuntu终端。\n\n<!--more-->\n\n很早时候windows就发布了其可以在win10运行的Ubuntu子系统。\n\n<img src=\"https://www.micdz.cn/img/2020-5-10-1.png\"/>\n\n总的来说这个子系统与一个普通的Ubuntu没有区别。\n\n这里总结一下子系统一些目录在win10的对应关系。\n\n## 目录对应关系\n\n### 根目录\n\n`\\` \n\n根目录对应在\n\n`C:\\Users\\[WIN_USER]\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu[UBUNTU_RELEASES]onWindows_79rhkp1fndgsc\\LocalState\\rootfs`\n\n其中 `[WIN_USER]` 表示你的windows系统用户名， `[UBUNTU_RELEASES]` 表示你安装的Ubuntu版本号， `[UBUNTU_USER]` 表示你在子系统下的用户名。\n\n### home目录\n\n`~`\n\nhome目录对应在 \n\n`C:\\Users\\[WIN_USER]\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu[UBUNTU_RELEASES]onWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\[UBUNTU_USER]`  \n\n### 启动默认目录\n\n`/mnt/c/Users/MicDZ` \n\n对应为\n\n `C:\\Users\\[WIN_USER]`\n\n## 操作\n\n与普通Ubuntu无异。","tags":["ubuntu","虚拟机"],"categories":["Dev"]},{"title":"【51nod2014】小朋友的笑话 题解","path":"/article/51nod2014-solution/","content":"[51nod2014](https://www.51nod.com/Challenge/Problem.html#problemId=2014)\n\n<!--more-->\n\n## 核心思路\n\n解决这道题需要面对两个问题。首先是如何求或修改某一区间的小朋友的状态，这可以用线段树解决；其次是如何知道某一个（段）小朋友已经听过这个笑话，这个问题可以用 $\\max\\{l\\}$ 个set维护。\n\n具体的操作是这样。首先得到了一段 $[x-k,x+k]$ 的区间，将这个区间内的所有数修改为 $1$，再将这个区间与对应笑话的set取并，将交集部分修改为 $0$ 。取交集的操作是，先找到第一个包含于 $[x-k,x+k]$ 的区间，然后向后增加指针直至离开 $[x-k,x+k]$ 这一区间。\n\nset中最多出现 $n$ 个区间，查找到第一个需要 $n\\log n$ ，从那往后最多经历 $n$ 个区间，修改每一个区间的复杂度为 $\\log n$，因此总的复杂度为 $O(n\\log n)$ 。\n\n\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<set>\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a)\tfreopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m;\nnamespace Brute {\n\tconst int MAXN=1e4+10;\n\tbool mark[MAXN][MAXN],sta[MAXN];\n\tvoid main() {\n\t\tREP(i,1,m) {\n\t\t\tint op=read();\n\t\t\tif(op==1) {\n\t\t\t\tint x=read(),l=read(),k=read();\n\t\t\t\tREP(j,max(1,x-k),min(n,x+k)) {\n\t\t\t\t\tif(mark[j][l]) sta[j]=0;\n\t\t\t\t\telse sta[j]=1;\n\t\t\t\t\tmark[j][l]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint l=read(),r=read(),ans=0;\n\t\t\t\tREP(j,l,r) ans+=sta[j];\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n}\n\nnamespace AC {\n\tconst int MAXN=1e5+10;\n\n\tset<pair<int,int> > s[MAXN];\n\n\tstruct SegmentTree {\n\t\tint lf[MAXN<<2],rg[MAXN<<2],add[MAXN<<2],sum[MAXN<<2],a[MAXN<<2];\n#define l(x) lf[x]\n#define r(x) rg[x]\n#define len(x) (rg[x]-lf[x]+1)\n\t\tvoid pushup(int p) {sum[p]=sum[p*2]+sum[p*2+1];}\n\t\tvoid pushdown(int p) {\n\t\t\tif(add[p]!=-1) {\n\t\t\t\tadd[p*2]=add[p];\n\t\t\t\tadd[p*2+1]=add[p];\n\t\t\t\tsum[p*2]=add[p]*len(p*2);\n\t\t\t\tsum[p*2+1]=add[p]*len(p*2+1);\n\t\t\t\tadd[p]=-1;\n\t\t\t}\n\t\t}\n\t\tvoid build(int p,int l,int r) {\n\t\t\tl(p)=l,r(p)=r;\n\t\t\tif(l==r) {sum[p]=0,add[p]=-1;return ;}\n\t\t\tint mid=(l+r)>>1;\n\t\t\tbuild(p*2,l,mid);\n\t\t\tbuild(p*2+1,mid+1,r);\n\t\t\tpushup(p);\n\t\t}\n\t\tvoid change(int p,int l,int r,int d) {\n\t\t\tif(l(p)>=l&&r(p)<=r) {\n\t\t\t\tsum[p]=d*len(p);\n\t\t\t\tadd[p]=d;\n\t\t\t\treturn ;\n\t\t\t} \n\t\t\tpushdown(p);\n\t\t\tint mid=(l(p)+r(p))>>1;\n\t\t\tif(l<=mid) change(p*2,l,r,d);\n\t\t\tif(r>mid) change(p*2+1,l,r,d);\n\t\t\tpushup(p);\n\t\t}\n\t\tint ask(int p,int l,int r) {\n\t\t\tif(l(p)>=l&&r(p)<=r) return sum[p];\n\t\t\tint ans=0;\n\t\t\tpushdown(p);\n\t\t\tint mid=(l(p)+r(p))>>1;\n\t\t\tif(l<=mid) ans+=ask(p*2,l,r);\n\t\t\tif(r>mid) ans+=ask(p*2+1,l,r);\n\t\treturn ans;\n\t\t}\n\t} seg;\n#define mp(a,b) make_pair(a,b)\n\tvoid main() {\n\t\tseg.build(1,1,n);\n\t\tREP(i,1,m) {\n\t\t\tint op=read();\n\t\t\tif(op==1) {\n\t\t\t\tint x=read(),L=read(),k=read(),l=max(1,x-k),r=min(n,x+k),nowl=l,nowr=r;\n\t\t\t\tif(s[L].size()) {\n                    set<pair<int,int> >::iterator it=s[L].lower_bound(mp(l,0));\n\t\t\t\t\tset<pair<int,int> >::iterator pre=it;\n\t\t\t\t\tif(it!=s[L].begin()) {\n\t\t\t\t\t\tpre--;\n\t\t\t\t\t\tif((*pre).second>=l) it=pre;\n\t\t\t\t\t}\n\t\t\t\t\tif(it==s[L].end()||(*it).first>r) {\n                        s[L].insert(mp(l,r));\n\t\t\t\t\t\tseg.change(1,l,r,1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnowl=min(nowl,(*it).first);seg.change(1,l,r,1);\n\t\t\t\t\t\tseg.change(1,l,r,1);\n\t\t\t\t\t\twhile(it!=s[L].end()&&(*it).first<=r) {\n\t\t\t\t\t\t\tseg.change(1,max(l,(*it).first),min(r,(*it).second),0);\t\t\t\t\n\t\t\t\t\t\t\tnowr=max(nowr,(*it).second);\n\t\t\t\t\t\t\tpre=it,it++;s[L].erase(pre);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[L].insert(mp(nowl,nowr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tseg.change(1,l,r,1);\n\t\t\t\t\ts[L].insert(mp(l,r));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint l=read(),r=read();\n\t\t\t\tprintf(\"%d\\n\",seg.ask(1,l,r));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tn=read(),m=read();\n\tAC::main();\n\treturn 0;\n}\n```","tags":["题解"],"categories":["OI","题解"]},{"title":"【51nod1444】破坏道路 题解","path":"/article/51nod1444-solution/","content":"[51nod1444](https://www.51nod.com/Challenge/Problem.html#problemId=1444)\n\n<!--more-->\n\n## 核心思路\n\n相当简单的一道题，只要把所有的方案枚举出来找到最优的即可。\n\n枚举的过程很有规律，可以利用位运算降低代码的复杂度。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a)\tfreopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=3000+10,MAXM=MAXN*MAXN;\n\nint head[MAXN],_next[MAXM],to[MAXM],cnt;\n\nvoid addedge(int u,int v) {\n\tcnt++;\n\t_next[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n}\n\nint dis[MAXN][MAXN];\n\nqueue<int> q;\n\nvoid bfs(int s) {\n\tdis[s][s]=0;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=head[u]; i; i=_next[i]) {\n\t\t\tint v=to[i];\n\t\t\tif(dis[s][v]==dis[s][0]) dis[s][v]=dis[s][u]+1,q.push(v);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n=read(),m=read();\n\tREP(i,1,m) {\n\t\tint u=read(),v=read();\n\t\taddedge(u,v);\n\t\taddedge(v,u);\n\t}\n\tmemset(dis,127,sizeof(dis));\n\tREP(i,1,n) bfs(i);\n\n\t//REP(i,1,n){ REP(j,1,n) printf(\"%d \",dis[i][j]); puts(\"\");}\n\tint s[2][2],l[2];\n\t\n\ts[0][0]=read(),s[0][1]=read(),l[0]=read(),s[1][0]=read(),s[1][1]=read(),l[1]=read();\n\n\tREP(i,0,1) if(dis[s[i][0]][s[i][1]]>l[i]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint ans=m; REP(i,0,1) ans-=dis[s[i][0]][s[i][1]];\n\t\n\tREP(i,1,n) REP(j,1,n) {\n\t\tREP(k,0,1) REP(p,0,1) {\n\t\t\tint dis1=dis[s[0][0^p]][i]+dis[i][j]+dis[j][s[0][1^p]];\n\t\t\tint dis2=dis[s[1][0^k]][i]+dis[i][j]+dis[j][s[1][1^k]];\n\t\t\tif(dis1<=l[0]&&dis2<=l[1]) ans=max(ans,m-(dis1+dis2-dis[i][j]));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n```","tags":["题解","图论","最短路"],"categories":["OI","题解"]},{"title":"【51nod1331】狭窄的通道 题解","path":"/article/51nod1331-solution/","content":"[51nod1331](https://www.51nod.com/Challenge/Problem.html#problemId=1331)\n\n<!--more-->\n\n## 核心思路\n\n这道题有一些细节需要注意。\n\n分为两类情况，一类是中间有一些不去两头将交换的，另一类是所有的都交换。有一些狼可以左右两个交换区都经过。然后还有一堆非常难调的细节，考场上没能写出来。\n\n复杂度为 $O(n^3)$ 。\n\n## 完整代码\n\n参考[这位博主](https://www.cnblogs.com/Yuzao/p/7535527.html)。\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a)\tfreopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=50+10,INF=0x3f3f3f3f;\n\nstruct edge {\n\tint s,t;\n} a[MAXN];\n\nbool cmp1(edge a,edge b) {\n\treturn a.s<b.s;\n}\n\nbool cmp2(edge a,edge b) {\n\treturn a.t<b.t;\n}\n\nint n,l,ans;\n\nvoid calc(int pos) {\n\tsort(a+1,a+pos+1,cmp2);\n\tsort(a+pos+1,a+n+1,cmp2);\n\tint leng=0;\n\tREP(i,1,pos) leng+=a[i].s+a[i].t;\n\tREP(i,pos+1,n) leng+=l-a[i].s+l-a[i].t;\t\n\tint sum1=0,sum2=0;\n\n\tREP(i,pos+1,n) {\n\t\tsum1=0;\n\t\tREP(j,1,pos) if(a[j].t>=a[i].t) sum1+=2*(l-a[j].t);\n\t\tans=min(ans,leng+sum1+sum2);\n\t\tsum2+=2*a[i].t;\n\t}\n}\n\nbool pd(int l,int r,int _l,int _r) {\n\tint n1=0,n2=INF;\n\tREP(i,l,r) n1=max(n1,a[i].t);\n\tREP(i,_l,_r) n2=min(n2,a[i].t);\n\treturn n1<n2;\n}\n\nint main() {\n\tint t=read();\n\twhile(t--) {\n\t\tans=INF;\n\t\tn=read(),l=read();\n\t\tREP(i,1,n) a[i]=(edge){read(),read()};\n\t\tREP(i,0,n) { \n\t\t\tsort(a+1,a+1+n,cmp1);\n\t\t\tcalc(i);\n\t\t}\n\t\tsort(a+1,a+1+n,cmp1);\n\t\tint si=0;\n\t\tREP(i,0,n) {\n\t\t\tsi+=a[i].t+a[i].s;\n\t\t\tif(pd(1,i,i+1,n)) {\n\t\t\t\tint j=i+1,tot=0;\n\t\t\t\tfor(; j<=n; j++) if(!pd(i+1,j,j+1,n)) {break;}\n\t//\t\t\tDE(\"%d\\n\",j);\n\t\t\t\tREP(k,i+1,j-1) tot+=abs(a[k].t-a[k].s);\n\t\t\t\tREP(k,j,n) tot+=l-a[k].s+l-a[k].t;\n\t\t\t\tans=min(ans,si+tot);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```","tags":["题解"],"categories":["OI","题解"]},{"title":"【51nod1564】区间的价值 题解","path":"/article/51nod1564-solution/","content":"[51nod1564](https://www.51nod.com/Challenge/Problem.html#problemId=1564)\n\n<!--more-->\n\n## 核心思路\n\n这道题是“细节理解题”，题目的关键在于“ $a_i$ 的值将会是 $1-10^9$内随机的一个数”。这保证了没有特殊构造的数据来卡我特定的算法。\n\n可以尺取来更新答案，我们要使得最小值最大。所以每次只需要将 $l-1$ 和 $r+1$ 中较小的那一个加入即可。每次加入后更新答案。\n\n没有特殊构造数据，期望复杂度 $O(n\\log n)$。特殊构造可以卡至 $O(n^2)$ 。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<stack>\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a)\tfreopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n#define ll long long\n#define int ll\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=100000+10,INF=0x3f3f3f3f;\n\nint a[MAXN];\n\nnamespace Solution {\n\tint ans[MAXN];\n\t//stack<pair<int,int> > s;\n\tvoid main() {\n\t\tint n=read();\n\t\tREP(i,1,n) a[i]=read();\n\n\t\tREP(i,1,n) {\n\t\t\tans[1]=max(ans[1],1ll*a[i]*a[i]);\n\n\t\t\tint minn=a[i],maxx=a[i],l=i,r=i;\n\t\t\twhile(a[l]<=maxx&&a[r]<=maxx) {\n\t\t\t\tif(a[l-1]>a[r+1]) l--;\n\t\t\t\telse r++;\n\t\t\t\tif(r>n) r--;\n\t\t\t\tif(l<1) l++;\n\t\t\t\tminn=min(minn,min(a[l],a[r]));\n\t\t\t\tans[r-l+1]=max(ans[r-l+1],1ll*maxx*minn);\n\t\t\t\tif(l==1&&r==n) break;\n\t\t\t}\n\t\t}\n\t\tREP(i,1,n) printf(\"%lld\\n\",ans[i]);\n\t}\n}\nsigned main() {\n\tSolution::main();\t\n\treturn 0;\n}\n\n```","tags":["题解"],"categories":["OI","题解"]},{"title":"莫比乌斯反演学习笔记","path":"/article/mobius/","content":"<!--more-->\n\n## 前置知识\n\n$$\n\\forall a,b,c\\in\\mathbb{Z},\\left\\lfloor\\frac{a}{bc}\\right\\rfloor=\\left\\lfloor\\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor\n$$\n\n$$\n\\forall n \\in N,  \\left|\\left\\{ \\lfloor \\frac{n}{d} \\rfloor \\mid d \\in N \\right\\}\\right| \\leq \\lfloor 2\\sqrt{n} \\rfloor\n$$\n\n## 数论分块\n\n对于任意一个 $i(i\\leq n)$ ，我们需要找到一个最大的 $j(i\\leq j\\leq n)$ ，使得 $\\left\\lfloor\\frac{n}{i}\\right\\rfloor = \\left\\lfloor\\frac{n}{j}\\right\\rfloor$ 。\n\n$$\nj=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor\n$$\n\n\n\n## Dirichlet 卷积\n\n### 定义\n\n定义两个数论函数 $\\textbf f,\\textbf g$ 的 Dirichlet 卷积为\n\n$$\n(\\textbf f\\ast \\textbf g)(n)=\\sum_{d\\mid n}\\textbf f(d)\\textbf g(\\frac{n}{d})\n$$\n\n也可以等价地写为：\n$$\n(\\textbf f*\\textbf g)(n)=\\sum_{ij=n}\\textbf f(i)\\textbf g(j)\n$$\n\n\n### 性质\n\n1. **交换律** $\\textbf f*\\textbf g=\\textbf g*\\textbf f$\n2. **结合律** $(\\textbf f*\\textbf g)*\\textbf h=\\textbf f*(\\textbf g*\\textbf h)$\n3. **分配率** $(\\textbf f+\\textbf g)*\\textbf h=\\textbf f*\\textbf h+\\textbf g*\\textbf h$\n4. **数乘** $(x\\textbf f)*\\textbf g=x(\\textbf f*\\textbf g)$\n5. **单位元** $\\epsilon*\\textbf f=\\textbf f$\n6. **逆元** 对于每个 $\\textbf f(1)\\not=0$ 的 $\\textbf f$  ，都存在一个 $\\textbf g$  使得 $\\textbf f*\\textbf g=\\epsilon$\n\n### 函数的逆\n\n对于函数 $\\textbf f$ ，要求它的逆 $\\textbf g$ 。那么 $\\textbf g$ 为：\n\n\n\n### 例子\n\n$$\n\\begin{aligned}\n\\varepsilon=\\mu \\ast 1&\\iff\\varepsilon(n)=\\sum_{d\\mid n}\\mu(d)\\\\\nd=1 \\ast 1&\\iff d(n)=\\sum_{d\\mid n}1\\\\\n\\sigma=d \\ast 1&\\iff\\sigma(n)=\\sum_{d\\mid n}d\\\\\n\\varphi=\\mu \\ast \\textbf{ID}&\\iff\\varphi(n)=\\sum_{d\\mid n}d\\cdot\\mu(\\frac{n}{d})\n\\end{aligned}\n$$\n\n## 积性函数\n\n若 $\\gcd(x,y)=1$ （ $x\\perp y$ ） 且 $\\textbf f(xy)=\\textbf f(x)\\textbf f(y)$ ，则 $\\textbf f(n)$ 为积性函数。\n\n### 性质\n\n若 $\\textbf f(x)$ 和 $\\textbf g(x)$ 均为积性函数，则以下函数也为积性函数：\n\n$$\n\\begin{aligned}\\textbf h(x)&=\\textbf f(x^p)\\\\\\textbf h(x)&=\\textbf f ^p(x)\\\\\\textbf h(x)&= \\textbf f(x)\\textbf g(x)\\\\\\textbf h(x)&=\\sum_{d\\mid x}\\textbf f(d)\\textbf g(\\frac{x}{d})\\end{aligned}\n$$\n\n### 例子\n\n-   单位函数： $\\epsilon(n)=[n=1]$ \n-   恒等函数： $\\textbf{id}_k(n)=n^k$  $\\textbf{id}_{1}(n)$ 通常简记作 $\\textbf{id}(n)$ 。\n-   常数函数： $\\textbf 1(n)=\\textbf 1$ \n-   除数函数： $\\sigma_{k}(n)=\\sum_{d\\mid n}d^{k}$  $\\sigma_{0}(n)$ 通常简记作 $\\operatorname{d}(n)$ 或 $\\tau(n)$ ， $\\sigma_{1}(n)$ 通常简记作 $\\sigma(n)$ 。\n-   欧拉函数： $\\varphi(n)=\\sum_{i=1}^n [\\gcd(i,n)=1]$ \n-   莫比乌斯函数\n\n### 结论\n\n**两个积性函数的狄利克雷卷积是积性函数**。\n\n\n\n## 莫比乌斯函数\n\n### 定义\n\n $\\mu$ 为莫比乌斯函数，定义为\n\n$$\n\\mu(n)=\n\\begin{cases}\n1&n=1\\\\\n0&n\\text{ 含有平方因子}\\\\\n(-1)^k&k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\\\\n\\end{cases}\n$$\n详细解释一下：\n\n令 $n=\\prod_{i=1}^kp_i^{c_i}$ ，其中 $p_i$ 为质因子， $c_i\\ge 1$ 。上述定义表示：\n\n1.   $n=1$ 时， $\\mu(n)=1$ ；\n2.  对于 $n\\not= 1$ 时：\n    1.  当存在 $i\\in [1,k]$ ，使得 $c_i > 1$ 时， $\\mu(n)=0$ ，也就是说只要某个质因子出现的次数超过一次， $\\mu(n)$ 就等于 $0$ ；\n    2.  当任意 $i\\in[1,k]$ ，都有 $c_i=1$ 时， $\\mu(n)=(-1)^k$ ，也就是说每个质因子都仅仅只出现过一次时，即 $n=\\prod_{i=1}^kp_i$ ， $\\{p_i\\}_{i=1}^k$ 中个元素唯一时， $\\mu(n)$ 等于 $-1$ 的 $k$ 次幂，此处 $k$ 指的便是仅仅只出现过一次的质因子的总个数。\n\n\n\n反演结论： $\\displaystyle [gcd(i,j)=1] \\iff\\sum_{d\\mid\\gcd(i,j)}\\mu(d)$ \n\n\n\n## 莫比乌斯反演\n\n定义 $\\textbf{1}$ 的逆是 $\\mu$ 。如果 $\\textbf g=\\textbf f*\\textbf 1$，就有 $\\textbf f=\\textbf f*\\textbf 1*\\mu=\\textbf g*\\mu$ 。\n\n即如果 $\\textbf g(n)=\\sum_{d|n} \\textbf f(d)$，那么 $\\textbf f(n)=\\sum_{d|n}\\mu(\\frac n d)\\textbf g(d)$ 。 \n\n\n\n\n\n## 内容来源声明\n\n本文部分内容来自 [OI-wiki](https://oi-wiki.org) ，[洛谷日报](https://www.luogu.com.cn/blog/lx-2003/mobius-inversion) ，侵删。","tags":["数学","学习笔记"],"categories":["OI","学习笔记"]},{"title":"【JSOI2013】侦探jyy 题解","path":"/article/JSOI2013-zhentanjyy-solution/","content":"[JSOI2013](https://www.lydsy.com/JudgeOnline/problem.php?id=4478)\n\n<!--more-->\n\n## 核心思路\n\n我们枚举每一个点，假设这个点不发生，那么它的前驱都不能发生。搜索完它的全部前驱打上标记作为这些点不能发生。然后再从剩下不一定发生的点中贪心地将每一个入度为 $0$ 的设定为一定发生，统计它们的全部后继，如果能够覆盖题目所给的 $d$ 个点，那么最开始枚举的这个点就可以不发生，否则一定发生。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=(e); i<=(s); i++)\n#define DREP(i,e,s) for(register int i=(e); i>=(s); i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define ll long long\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1000+10,MAXM=100000+10;\n\nint head[MAXN],_next[MAXM],to[MAXM],cnt;\n\nvoid addedge(int u,int v) {\n\tcnt++;\n\t_next[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n}\nvector<int> g[MAXN];\n\nint book[MAXN],flag[MAXN],mark[MAXN];\n\nqueue<int> q;\n\nvoid bfs(int s) {\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tint u=q.front();q.pop();\n\t\tREP(i,0,(int)g[u].size()-1) {\n\t\t\tint v=g[u][i];\n\t\t\tif(flag[v]) continue;\n\t\t\tflag[v]=1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n}\n\nint in[MAXN];\n\nvoid bfs2(int s) {\n\tq.push(s);mark[s]=1;\n\twhile(!q.empty()) {\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=head[u]; i; i=_next[i]) {\n\t\t\tint v=to[i];\n\t\t\tif(mark[v]) continue;\n\t\t\tmark[v]=1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n} \n\nint ans[MAXN];\n\nint main() {\n\tint n=read(),m=read(),d=read();\n\tREP(i,1,m) {\n\t\tint u=read(),v=read();\n\t\taddedge(u,v);in[v]++;\n\t\tg[v].push_back(u);\n\t}\n\tREP(i,1,d) book[read()]=1; \n\n\tREP(i,1,n) {\n\t\tmemset(flag,0,sizeof(flag));\n\t\tmemset(mark,0,sizeof(flag));\n\t\tbfs(i);\n\t\tREP(j,1,n) \n\t\t\tif(!flag[j]&&in[j]==0&&j!=i) bfs2(j);\n\t\tREP(j,1,n) {\n\t\t\tif(!mark[j]&&book[j]) {\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,1,n) if(ans[i]) printf(\"%d \",i);\n\treturn 0;\n}\n\n```","tags":["题解","贪心"],"categories":["OI","题解"]},{"title":"【JSOI2011】棒棒糖 题解","path":"/article/JSOI2011-bangbangtang-solution/","content":"[JSOI2011](https://www.lydsy.com/JudgeOnline/problem.php?id=5178)\n\n<!--more-->\n\n## 核心思路\n\n直接上一棵主席树，不用离散化美滋滋。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=(e); i<=(s); i++)\n#define DREP(i,e,s) for(register int i=(e); i>=(s); i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=200000+10,MAXM=MAXN*18;;\n\nint rt[MAXM],a[MAXN];\n\nstruct President_Tree {\n\tint cnt,ls[MAXM],rs[MAXM],sum[MAXM];\n\tPresident_Tree() {\n\t\tcnt=0;\n\t}\n\tvoid build(int &p,int l,int r) {\n\t\tp=++cnt;\n\t\tif(l==r) return ;\n\t\tint mid=(l+r)>>1;\n\t\tbuild(ls[p],l,mid);\n\t\tbuild(rs[p],mid+1,r);\n\t}\n\tvoid change(int &p,int l,int r,int u,int x) {\n\t\tp=++cnt,ls[p]=ls[u],rs[p]=rs[u],sum[p]=sum[u]+1;\t\n\t\tif(l==r) return ;\n\t\tint mid=(l+r)>>1;\n\t\tif(x<=mid) change(ls[p],l,mid,ls[u],x);\n\t\telse change(rs[p],mid+1,r,rs[u],x);\n\t}\n\tint ask(int x,int y,int l,int r,int k) {\n\t\tif(l==r) return l;\n\t\tint mid=(l+r)>>1;\n\t\tif(sum[ls[y]]-sum[ls[x]]>=k) return ask(ls[x],ls[y],l,mid,k);\n\t\telse if(sum[rs[y]]-sum[rs[x]]>=k) return ask(rs[x],rs[y],mid+1,r,k);\n\t\treturn -1;\n\t}\n} s;\n\n\nint main() {\n\tint n=read(),m=read();\n\tREP(i,1,n) a[i]=read();\n\tint sz=n;\n\ts.build(rt[0],1,sz);\n\tREP(i,1,n) s.change(rt[i],1,sz,rt[i-1],a[i]);\n\n\twhile(m--) {\n\t\tint l=read(),r=read();\n\t\tint t=s.ask(rt[l-1],rt[r],1,sz,(r-l+1)/2+1);\n\t\tif(t!=-1) printf(\"%d\\n\",t);\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n```","tags":["题解","可持久化","线段树"],"categories":["OI","题解"]},{"title":"可持久化线段树学习笔记","path":"/article/persistent-seg/","content":"主席树又称可持久化线段树权值线段树普通线段树的每一个节点表示区间，记录的是原序列在该区间上的一些信息。而权值线段树记录的是在整个序列中属于这个区间的元素的个数。这样，在权值线段树中，元素与元素之间是**无序**的，类似与一棵平衡树。下面是我用动态开点权值线段树写的普通平衡树。其查询方式与BST类似。green,权值线段树实现普通平衡树```cpp#include<iostream>#include<cstdio>#include<cmath>#include<cstring>#include<algorithm>using namespace std;#define REP(i,e,s) for(register int i=(e); i<=(s); i++)#define DREP(i,e,s) for(register int i=(e); i>=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)int read() {\tint x=0,f=1,ch=getchar();\twhile(ch>'9'ch<'0'){if(ch=='-')f=-1;ch=getchar();}\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\treturn x*f;}#define int llconst int MAXN=100000+10;struct SegmentTree {\tint lson[MAXN<<5],rson[MAXN<<5],a[MAXN];\tint lf[MAXN<<5],rg[MAXN<<5],sum[MAXN<<5],add[MAXN<<5],cnt;#define l(x) lf[x]#define r(x) rg[x]#define sum(x) sum[x]#define add(x) add[x]#define len(x) (rg[x]-lf[x]+1)\tvoid pushup(int p) {\t\tsum(p)=sum(lson[p])+sum(rson[p]);\t}\tvoid pushdown(int p) {\t\tif(add(p)) {\t\t\tif(!lson[p]) lson[p]=++cnt;\t\t\tif(!rson[p]) rson[p]=++cnt;\t\t\tint mid=(l(p)+r(p))>>1;\t\t\tadd(lson[p])=add(lson[p])+add(p);\t\t\tadd(rson[p])=add(rson[p])+add(p);\t\t\tsum(lson[p])=sum(lson[p])+add(p)*(mid-l(p)+1);\t\t\tsum(rson[p])=sum(rson[p])+add(p)*(r(p)-mid);\t\t\tadd(p)=0;\t\t}\t}\tvoid change(int &p,int l,int r,int L,int R,int d) {\t\tif(!p) p=++cnt,l(p)=l,r(p)=r;\t\tif(l(p)>=L&&r(p)<=R) {\t\t\tsum(p)=sum(p)+d*len(p);\t\t\tadd(p)=add(p)+d;\t\t\treturn ;\t\t}\t\tpushdown(p);\t\tint mid=(l(p)+r(p))>>1;\t\tif(L<=mid) change(lson[p],l,mid,L,R,d);\t\tif(R>mid) change(rson[p],mid+1,r,L,R,d);\t\tpushup(p);\t}\tint ask(int p,int l,int r) {\t\tif(!p) return 0;\t\tif(l(p)>=l&&r(p)<=r) return sum(p);\t\tpushdown(p);\t\tint mid=(l(p)+r(p))>>1;\t\tint ans=0;\t\tif(l<=mid) ans=ans+ask(lson[p],l,r);\t\tif(r>mid) ans=ans+ask(rson[p],l,r);\t\treturn ans;\t}\tint getvl(int p,int l,int r,int rk) {\t\tif(l==r) return l; \t\tint mid=(l+r)>>1;\t\tif(sum(lson[p])>=rk) return getvl(lson[p],l,mid,rk);\t\telse return getvl(rson[p],mid+1,r,rk-sum(lson[p]));\t}\tint getrk(int p,int l,int r,int vl) {\t\tif(!p) return 0;\t\tif(l==r) return 1;\t\tint mid=(l+r)>>1;\t\tif(vl<=mid) return getrk(lson[p],l,mid,vl);\t\telse return sum[lson[p]]+getrk(rson[p],mid+1,r,vl);\t}} s;const int N=1e7+10;signed main() {\tint n=read(),rt=0;\tREP(i,1,n) {\t\tint op=read();\t\tif(op==1) {\t\t\tint x=read();\t\t\ts.change(rt,-N,N,x,x,1);\t\t}\t\tif(op==2) {\t\t\tint x=read();\t\t\ts.change(rt,-N,N,x,x,-1);\t\t}\t\tif(op==3) {\t\t\tint x=read();\t\t\tprintf(\"%lld\\n\",s.getrk(1,-N,N,x));\t\t}\t\tif(op==4) {\t\t\tint k=read();\t\t\tprintf(\"%lld\\n\",s.getvl(1,-N,N,k));\t\t}\t\tif(op==5) {\t\t\tint x=read();\t\t\tprintf(\"%lld\\n\",s.getvl(1,-N,N,s.ask(1,-N,x-1)));\t\t}\t\tif(op==6) {\t\t\tint x=read();\t\t\tprintf(\"%lld\\n\",s.getvl(1,-N,N,s.ask(1,-N,x)+1));\t\t}\t}\treturn 0;}```权值线段树可以解决整个区间第 $k$ 大的问题，那么如何动态查询区间第 $k$ 大呢？权值线段树显然是无法完成的。可持久化线段树权值线段树支持查询区间 $[1,n]$ 的第 $k$ 大查询。考虑解决查询 $[l,r]$ 的第 $k$ 大需要那些信息。与权值线段树类似的，我们只需要建立一棵 $[l,r]$ 的权值线段树。考虑如何快速地建立出这样的一棵权值线段树。主席树就是解决这一问题的数据结构。我们建立 $n$ 棵权值线段树，第 $i$ 棵表示原序列 $[1,i]$ 的权值线段树。当我们在查询 $[l,r]$ 的时候即可通过 $[1,r]-[1,l-1]$ 得到 $[l,r]$ 的权值线段树。为什么可以这么相减呢？假设现在我们要求解区间 $[l,r]$，我们已知 $[1,l-1]$ 与 $[1,r]$ 两棵权值线段树。假设有一个元素 $a$ 在原序列中处于 $[1,l-1]$ ，那么这一个节点不应被统计到答案中。我们再来看这个元素在两棵权值线段树中出现的位置，在第一棵权值线段树中所有包含于 $\\{a\\}$ 的节点都会出现，在第二棵权值线段树中同样也是如此。因此，只要将两棵权值线段树前相同的部分相减即可得到 $[l,r]$ 的权值线段树。建树的过程也非常巧妙，我们可以发现所有与之前相同的节点在后续询问中永远不可能被访问，因此这一部分节点完全没有必要建立出来。可以参考下图。green,<a href=\"https://www.luogu.com.cn/problem/P3834\">【模板】可持久化线段树 1（主席树）</a>```cpp#include<iostream>#include<cstdio>#include<cmath>#include<cstring>#include<algorithm>using namespace std;#define REP(i,e,s) for(register int i=(e); i<=(s); i++)#define DREP(i,e,s) for(register int i=(e); i>=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)int read() {\tint x=0,f=1,ch=getchar();\twhile(ch>'9'ch<'0'){if(ch=='-')f=-1;ch=getchar();}\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\treturn x*f;}const int MAXN=200000+10,MAXM=MAXN*18;;int rt[MAXM],a[MAXN],b[MAXN];struct Persistent_Tree {\tint cnt,ls[MAXM],rs[MAXM],sum[MAXM];\tPersistent_Tree() {\t\tcnt=0;\t}\tvoid build(int &p,int l,int r) {\t\tp=++cnt;\t\tif(l==r) return ;\t\tint mid=(l+r)>>1;\t\tbuild(ls[p],l,mid);\t\tbuild(rs[p],mid+1,r);\t}\tvoid change(int &p,int l,int r,int u,int x) {\t\tp=++cnt,ls[p]=ls[u],rs[p]=rs[u],sum[p]=sum[u]+1;\t\t\tif(l==r) return ;\t\tint mid=(l+r)>>1;\t\tif(x<=mid) change(ls[p],l,mid,ls[u],x);\t\telse change(rs[p],mid+1,r,rs[u],x);\t}\tint ask(int x,int y,int l,int r,int k) {\t\tif(l==r) return l;\t\tint mid=(l+r)>>1;\t\tint v=sum[ls[y]]-sum[ls[x]];\t\tif(v>=k) return ask(ls[x],ls[y],l,mid,k);\t\telse return ask(rs[x],rs[y],mid+1,r,k-v);\t}} s;int main() {\tint n=read(),m=read();\tREP(i,1,n) a[i]=b[i]=read();\tsort(b+1,b+1+n);\tint sz=unique(b+1,b+1+n)-b-1;\ts.build(rt[0],1,sz);\tREP(i,1,n) s.change(rt[i],1,sz,rt[i-1],lower_bound(b+1,b+sz+1,a[i])-b);\twhile(m--) {\t\tint l=read(),r=read(),k=read();\t\tprintf(\"%d\\n\",b[s.ask(rt[l-1],rt[r],1,sz,k)]);\t}\treturn 0;}```树上主席树与主席树前缀和思想相似的，利用树上差分的情况也可以用主席树维护。与序列不同的是，建树时是儿子节点与父亲节点不同的插入，查询时利用树上差分计算。green,<a href=\"https://www.luogu.com.cn/problem/P3302\">[SDOI2013]森林</a>```cpp#include<iostream>#include<cstdio>#include<cmath>#include<cstring>#include<algorithm>#include<queue> using namespace std; #define REP(i,e,s) for(register int i=(e); i<=(s); i++)#define DREP(i,e,s) for(register int i=(e); i>=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)int read() { int x=0,f=1,ch=getchar(); while(ch>'9'ch<'0'){if(ch=='-')f=-1;ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;} const int MAXN=80000+10,MAXM=MAXN*200; int rt[MAXM],a[MAXN],b[MAXN]; struct President_Tree { int cnt,ls[MAXM],rs[MAXM],sum[MAXM]; void init() { cnt=0; memset(ls,0,sizeof(ls)); memset(rs,0,sizeof(rs)); memset(sum,0,sizeof(sum)); } void build(int &p,int l,int r) { p=++cnt; if(l==r) return ; int mid=(l+r)>>1; build(ls[p],l,mid); build(rs[p],mid+1,r); } void change(int &p,int l,int r,int u,int x) { p=++cnt,ls[p]=ls[u],rs[p]=rs[u],sum[p]=sum[u]+1; if(l==r) return ; int mid=(l+r)>>1; if(x<=mid) change(ls[p],l,mid,ls[u],x); else change(rs[p],mid+1,r,rs[u],x); } int ask(int x,int y,int l,int r,int lc,int falc,int k) { if(x==y) return x; int mid=(x+y)>>1; int v=sum[ls[l]]+sum[ls[r]]-sum[ls[lc]]-sum[ls[falc]]; if(v>=k) return ask(x,mid,ls[l],ls[r],ls[lc],ls[falc],k); else return ask(mid+1,y,rs[l],rs[r],rs[lc],rs[falc],k-v); }} s; int head[MAXN],_next[MAXN<<1],to[MAXN<<1],cnt; void addedge(int u,int v) { cnt++; _next[cnt]=head[u]; head[u]=cnt; to[cnt]=v;} int fa[MAXN][25],dist[MAXN]; queue<int> q; int sz; void bfs(int s) { q.push(s); while(!q.empty()) { int u=q.front();q.pop(); for(int i=head[u]; i; i=_next[i]) { int v=to[i]; if(fa[u][0]==v) continue; fa[v][0]=u; dist[v]=dist[u]+1; q.push(v); } }} int f[MAXN],son[MAXN],vis[MAXN]; int find(int x) { if(f[x]==x) return x; return f[x]=find(f[x]);} void dfs(int u,int p,int _rt) { fa[u][0]=p; REP(i,1,19) fa[u][i]=fa[fa[u][i-1]][i-1]; son[_rt]++; dist[u]=dist[p]+1; f[u]=p; vis[u]=1; s.change(rt[u],1,sz,rt[p],a[u]); for(int i=head[u]; i; i=_next[i]) { int v=to[i]; if(v==p) continue; dfs(v,u,_rt); }} int lca(int u,int v) { if(dist[u]<dist[v]) swap(u,v); int len=dist[u]-dist[v]; DREP(i,19,0) if(1<<i&len) u=fa[u][i]; if(u==v) return u; DREP(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];} int last=0; void init() { memset(head,0,sizeof(head)); memset(vis,0,sizeof(vis)); memset(fa,0,sizeof(fa)); memset(dist,0,sizeof(dist)); memset(son,0,sizeof(son)); memset(rt,0,sizeof(rt)); cnt=0;} int main() { read(); int n=read(),m=read(),q=read(); REP(i,1,n) a[i]=b[i]=read(),f[i]=i; sort(b+1,b+1+n); sz=unique(b+1,b+1+n)-b-1; s.build(rt[0],1,sz); REP(i,1,n) a[i]=lower_bound(b+1,b+1+sz,a[i])-b; REP(i,1,m) { int u=read(),v=read(); addedge(u,v); addedge(v,u); } REP(i,1,n) { if(!vis[i]) { dfs(i,0,i); f[i]=i; } } int last=0; REP(i,1,q) { char op[3]; scanf(\"%s\",op+1); if(op[1]=='Q') { int u=read()^last,v=read()^last,k=read()^last,_lca=lca(u,v); last=b[s.ask(1,sz,rt[u],rt[v],rt[_lca],rt[fa[_lca][0]],k)]; printf(\"%d\\n\",last); } else { int u=read()^last,v=read()^last,rtu=find(u),rtv=find(v); addedge(u,v);addedge(v,u); if(son[rtu]<son[rtv]) swap(u,v),swap(rtu,rtv); dfs(v,u,rtu); } } return 0;}```可修改主席树咕咕咕","tags":["可持久化","线段树","学习笔记"],"categories":["OI","学习笔记"]},{"title":"组合容斥计数及反演学习笔记","path":"/article/combination/","content":"<!--more-->\n## 常用公式\n### 二项式定理\n$$\n(a+b)^n=\\sum_{i=0}^n{n\\choose{i}}a^ib^{n-i}\n$$\n\n### 可重组合\n$$\n{n+m-1}\\choose m\n$$\n\n\n### 二项式反演\n\n$$\n\\begin{aligned}f_n&=\\sum_{i=0}^n(-1)^i{n \\choose i}g_i\\\\g_n&=\\sum_{i=0}^n(-1)^i{n\\choose i}f_i\\end{aligned}\n$$\n\n或者把它写成更常见的形式\n\n$$\n\\begin{aligned}f_n&=\\sum_{i=0}^n{n\\choose i}g_i\\\\g_n&=\\sum_{i=0}^n(-1)^{n-i}{n\\choose i}f_i\\end{aligned}\n$$\n\n一些二项式反演变形公式，其实就是替换一下范围\n$$\nf_{k}=\\sum_{i=k}^{n}(-1)^i\\binom{i}{k}g_i\\Rightarrow g_k= \\sum_{i=k}^{n}(-1)^i\\binom{i}{k}f_i\\\\\nf_{k}=\\sum_{i=k}^{n}\\binom{i}{k}g_i\\Rightarrow g_k=\\sum_{i=k}^{n}(-1)^{i-k}\\binom{i}{k}f_i\n$$\n\n把 $f_i$ 带入 $g_n$ 的式子中可以简单证明（蒯自yyb）。\n\n$$\n\\begin{aligned}g_n&=\\sum_{i=0}^n(-1)^{n-i}{n\\choose i}f_i\\\\\n&=\\sum_{i=0}^n(-1)^{n-i}{n\\choose i}\\sum_{j=0}^i{i\\choose j} g_j\\\\\n&=\\sum_{j=0}^n g_i\\sum_{i=j}^n{n\\choose i}{i\\choose j}(-1)^{n-i}\\\\\n&=\\sum_{j=0}^n g_j\\sum_{i=j}^n{n\\choose j}{n-j\\choose i-j}(-1)^{n-i}\\\\\n&=\\sum_{j=0}^n g_j[{n\\choose j}\\sum_{i=j}^n{n-j\\choose i-j}(-1)^{n-i}]\\\\\n&=\\sum_{j=0}^n g_j[{n\\choose j}\\sum_{i=0}^{n-j}{n-j\\choose i}(-1)^{n-j-i}]\\\\\n&=\\sum_{j=0}^n g_j[{n\\choose j}(1-1)^{n-j}]\\\\\n&=g_n\\end{aligned}\n$$","tags":["数学","组合","容斥","学习笔记"],"categories":["OI","学习笔记"]},{"title":"2019回顾 & 2020展望","path":"/article/2020-resolution/","content":"语文不好，就当写篇作文练练笔吧\n\n<!--more-->\n\n## 前言\n\n岁月不居，时节如流。2019年很快过去了，回想一年前的此时，我还正深陷文化课的泥潭无法自拔，今年的我仍旧如此。\n\n2019是不平凡的一年，这一年过得很充实、走得很坚定。\n\n经历了中考，按国家的话来说，这是我们人生中第一场决定着未来命运的关键转折点；加入长郡信息组，虽然被大佬们吊打，但是收获颇丰；进入了1902班，交了太多朋友，一同见证了太多有意思的故事。\n\n可能是在1902班时间不够长，不连续的缘故，现在听到“25班”，“电教委员”，我都还会条件反射。眼前闪过过去三年的点滴，浮起点点泪光。\n\n感慨万千，乃提笔记之。\n## 2019回顾\n\n### 中考\n\n2019年年初，是中考奋战的最后200天，抛开中考带来的紧迫感，学习之余有太多的乐趣可以追忆。诡计狗叫、猫狗联赛 [[1]](#references-1)、国语近人 [[2]](#references-2)、12.1事件 [[3]](#references-3)、食堂事件 ……\n\n但中考前有的不仅只是欢乐，还有考试失败的苦恼，来自同学、老师、家人的各种压力。\n\n还记得年初的第一次月考，语文作文偏题的我获得了人生中第一个“C”，距离“D”线仅差1分，国家找我谈话，严厉地指出了我语文学习中的各种问题，那一刻，我认为我的初中语文学习是非常失败的，甚至丧失了考6A的信心。\n\n颓废了一段时间，家人也十分担心，我的悲伤情绪无处排解，看番无动力，写作业没耐心，追美剧，嗯…没有这个条件。家中电脑被藏起，信息书被锁起。后来不知怎么的，有一天晚上，看到暴雨过后学校被淹没的草场，顶着严冬的冽风，突然间想明白了，必须要努力一把，否则自己是怎么失败的都不知道，但是找不到努力方向的我面对现实时，陷入无尽的茫然。\n\n百日誓师，在初二生地会考百日誓师的前一天进行，多么希望时间能回到初二，再来一次生地会考。\n\n后面的几次月考和全真模拟，包括和长郡系联考的月考，虽排名稍见起色，但是始终没能拿到全A，除了着急，也没有别的想法。\n\n直到中考的前一天晚上，我的心里依旧没底，匆匆忙忙奔赴考场，匆匆忙忙写完试卷，乐呵乐呵老师考前押的题，中考就迷迷糊糊考完了。考场上、考后的记忆全部丢失，回忆不起什么来了。\n\n成绩揭晓，事实证明，我是幸运的，广益是幸运的。\n\n中考前的挫折，中考时的沉着，让我看到了自己尚存希望，未来可期。\n\n### 初至郡园\n\n早已做好了长郡小的心理准备，但还是没想到长郡会这么小，原以为操场后面一排贴了运动标志的建筑也是长郡教学楼，原以为体育馆后面还有一半只是平常未开放，原以为一教一层有三间教室。\n\n起初是没有想法高中就读长郡的，来考理实也是抱着碰碰运气的想法。但是，当我慢慢了解这个学校，我就慢慢地理解了她的包容、朴实、严谨。这些正是我所向往的。\n\n从附中系初中毕业到长郡是不容易的，在这过程中我要非常感谢国家、砣哥耐心的帮助我分析选择，在我做出选择后坚定不移地支持我。最终这个选择也没有让我后悔。\n\n总之，在长郡的生活仿佛就是一个人生的新开始，新的同学，新的校园文化，新的老师都让我兴奋无比。\n\n### 长郡信息组\n\n很感谢遇见了tham，tham是我所有教练中最负责、最有耐心、最和同学相处融洽的教练。至今还记得在云机房，tham讲一道题，讲着讲着就策不清了，借口出去打电话，打了一个小时电话后回来继续策。讲到最后我们也是云里雾里，这样的情况下tham竟重头再讲了一遍（虽然第二遍讲完听懂的人没有变多）。\n\n机房的巨佬就不一一列举了，伤心。。\n\n虽然CSP2019没有取得期望的成绩 [[4]](#references-4)，但是它暴露了许多此前我不曾发现的问题，这些问题在过去的每一场考试中都有出现但都没有引起重视。\n\n## 2020展望\n\n### 祖国富强\n\n2020决胜全面建成小康社会，再奋斗15年基本实现现代化。感谢祖国给我们带来的生活上实实在在的改善。\n\n### 文化课程\n\n应当摒弃此前的不切实际吃老本的幻想，一定要扎扎实实做好作业，实时跟踪复习，独立完成每一道习题才会在考试的时候不会有这样或那样的失误。\n\n### 竞赛课程\n\n保持一定的刷题时间，学习一些新的知识。千万记住，一定要培养自己独立解题的能力，没事多做点codeforces、atcoder的比赛。及时总结所学。\n\n## 后记\n感谢过去一年中陪伴我的老师、同学、好伙伴，祝各位在新的一年中实现理想，学业有成，工作顺利！\n\n2019年，充实度过，但是，也留下了一些遗憾。虽付出努力，但未能获得自己想要的成果。这固然是对自己预期过高、实力不够的必然结果，但是2020年，我不会允许这样的错误再次发生，希望自己无悔付出！\n\n希望明年在写下2021年展望时可以想起现在立的flag。\n\n多年以后再回头看看这篇文章应该会是非常愉快的事情。\n\n## 引用\n<span id=\"references-1\"></span><br>\n[1]. 猫狗联赛\n> C1625班级内部联赛，分为狗队和猫队。由于狗队（其实是我）发动迁移球员运动，狗队集中了一大批有着充足精力和爆发力的球员，故除了第一赛季猫队获得冠军外，第二、三、四赛季狗队以不败战绩连续卫冕。\n>\n<span id=\"references-2\"></span><br>\n[2]. [国语近人](https://guo.micdz.cn/)（一个咕咕的项目）\n<span id=\"references-3\"></span><br>\n[3]. 关于将12.1设立为“放火纪念日”的通告\n <center>关于将12.1设立为“放火纪念日”的通告 </center>\n<blockquote>\n<p>\n2018年的12月1日8:55分左右，老针、周君等一众革命志士，在中栋五楼废弃办公室旁点燃了饮水机，吹响了反国运动的冲锋号，并在国家、严志等人的严刑逼供下拒不招认，把血液里的党性保留到了生命的最后一刻，两人于当天下午在蔡毅的办公室里英勇就义。 但烈士的鲜血不会白流！经中诡中央主要领导人lyz、mj、qy（钱勇）等人研究决定，将12.1设立为“放火纪念日”，以此激励广大中诡党员干部砥砺奋进，在各自的岗位上大有作为！ \n中诡中央党总支 2019年11月30日\n</p>\n</blockquote>\n<span id=\"references-4\"></span><br>\n[4]. 由于一些特殊情况，踩线2=.","tags":["Resoultion"],"categories":["Review & Resoultion"]},{"title":"【tyvj1061】Mobile Service 题解","path":"/article/tyvj1061-solution/","content":"[tyvj1061](http://www.joyoi.cn/problem/tyvj-1061)\n\n<!--more-->\n\n## 核心思路\n\n首先可以直接思考到的是设 $f_{i,a,b,c}$ 表示，进行到第 $i$ 个任务时，三个服务员分别在 $a,b,c$ 的最小花费。\n\n这个的复杂度为 $O(NL^3)$ ，显然过不了。\n\n然后就是比较套路的步骤了。发现记录的三个位置并不是都会用到，因为在完成了第 $i$ 个任务后，必定有一个服务员在 $P_i$，这样就可以优化到 $O(NL^2)$ 了。\n\n然后发现卡空间，滚动数组优化下就可以了。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=(e); i<=(s); i++)\n#define DREP(i,e,s) for(register int i=(e); i>=(s); i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1000+1,MAXL=200+1,INF=0x3f3f3f3f;\n\nint c[MAXL][MAXL],p[MAXN],f[2][MAXL][MAXL];\n\nint main() {\n\tint l=read(),n=read();\n\tREP(i,1,l) REP(j,1,l) c[i][j]=read();\n\tREP(i,1,n) p[i]=read();\n\t\n\tint o=0;\n\tmemset(f[o],127,sizeof(f[o]));\n\tp[0]=3;\n\tf[0][1][2]=0;\n\n\tREP(i,0,n) {\n\t\to^=1;\n\t\tmemset(f[o],127,sizeof(f[o]));\n\t\tREP(x,1,l) REP(y,1,l) {\n\t\t\tf[o][x][y]=min(f[o][x][y],f[o^1][x][y]+c[p[i]][p[i+1]]);\n\t\t\tf[o][p[i]][y]=min(f[o][p[i]][y],f[o^1][x][y]+c[x][p[i+1]]);\n\t\t\tf[o][x][p[i]]=min(f[o][x][p[i]],f[o^1][x][y]+c[y][p[i+1]]);\n\t\t}\n\t}\n\n\tint ans=INF;\n\n\tREP(i,1,l) REP(j,1,l) {\n\t\tif(i==j) continue;\n\t\tans=min(ans,f[o][i][j]);\n\t}\n\n\tDE(\"%.2f MB\\n\",(sizeof(c)+sizeof(p)+sizeof(f))*1.0/1048576);\n\tprintf(\"%d\\n\",ans);\n\treturn 0; \n}\n\n```","tags":["题解","动态规划"],"categories":["OI","题解"]},{"title":"每周学习总结","path":"/article/weekly/","content":"每周学习总结\n\n<!--more-->\n\n## 2019.11.30-2019.12.6\n准备月考\n\n思考了CSP2019没有做出来的题目\n\n学习了换根DP，还未完成[POJ3585](http://poj.org/problem?id=3585)，准备重写\n\n## 2019.12.7-2019.12.13\n\n进行《进阶指南》上的DP练习\n\n| 来源 | 题目名称 | 大致思路 | 解题报告 |\n| ------ | ------ | ------ | ------ |\n| [POJ3585](http://poj.org/problem?id=3585) | Accumulation Degree | 换根DP | 无 |\n| [HDU2196](http://acm.hdu.edu.cn/showproblem.php?pid=2196) | Computer | 换根DP，相对模板 | 无 |\n| [IOI1999](https://www.luogu.com.cn/problem/P1854) | 花店橱窗布置 | 线性DP，注意下边界 | 无 |\n| [TYVJ1061](http://www.joyoi.cn/problem/tyvj-1061) | Mobile Service | 线性DP，滚动数组优化空间 | [链接](https://www.micdz.cn/article/tyvj1061-solution/) |\n| [POJ1821](http://poj.org/problem?id=1821) | Fence | 单调队列优化DP，注意边界 | 无 |\n\n## 2019.12.14-2019.12.20\n\n| 来源 | 题目名称 | 大致思路 | 解题报告 |\n| ------ | ------ | ------ | ------ |\n| [CF915F](http://codeforces.com/problemset/problem/915/F) | Imbalance Value of a Tree | 图论，技巧 | 无 |\n| [HNOI2012](https://www.luogu.com.cn/problem/P3225) | 矿场搭建 | 图论，割点 | 无 |","tags":["总结"],"categories":["OI"]},{"title":"【POI2017】flappybird 题解","path":"/article/POI2017-flappybird-solution/","content":"[POI](https://www.lydsy.com/JudgeOnline/problem.php?id=4723)\n\n<!--more-->\n\n## 核心思路\n\n乍一看，这道题像是NOIP的flappybird的加强版。然而，认真分析一下好像任何dp都不能解决这道题。\n\n那么考虑一下题目有什么特殊性质：\n\n1. 不能多次点击\n2. 每一次要么加一，要么减一\n\n考虑直接模拟小鸟飞行的过程。\n\n从第 $i$ 个障碍物到第 $i+1$ 个障碍物，小鸟飞行的区间：\n$$\n\\begin{cases}\n\\max_i=\\min\\{\\max_{i-1}+x_i-x_{i-1},\\mathrm{high}_i\\}\\\\\n\\min_i=\\max\\{\\min_{i-1}-(x_i-x_{i-1}),\\mathrm{low}_i)\\}\n\\end{cases}\n$$\n推完之后你会发现，小鸟并不能出现在这个区间的每一个位置上，因为点一次与不点产生的差距为 $2$ ，即你无法改变最终到达位置的奇偶性。那么再判一下奇偶性即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=5e5+10,INF=0x3f3f3f;\n\nint x[MAXN],low[MAXN],up[MAXN];\n\nint main() {\n\tint n=read(),X=read();\n\tREP(i,1,n) x[i]=read(),low[i]=read(),up[i]=read();\n\t\n\tint a=0,b=0;\n\n\tREP(i,1,n) {\n\t\ta=min(a+(x[i]-x[i-1]),up[i]-1);\n\t\tb=max(b-(x[i]-x[i-1]),low[i]+1);\n\t\tif((a&1)!=(x[i]&1)) a--;\n\t\tif((b&1)!=(x[i]&1)) b++;\n\n\t\tif(a<b) {\n\t\t\tputs(\"NIE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",(x[n]+b)/2);\n\treturn 0;\n}\n```","tags":["题解","贪心"],"categories":["OI","题解"]},{"title":"【NOIP2015】运输计划 题解","path":"/article/NOIP2015-yunshujihua-solution/","content":"NOIP2015std1std3","tags":["题解","LCA"],"categories":["OI","题解"]},{"title":"【nowcoder-1103A】复读数组 题解","path":"/article/nowcoder-1103A-solution/","content":"[nowcoder-1103](https://ac.nowcoder.com/acm/contest/1103)\n\nCSP-S提高组赛前集训营4 A题\n\n<!--more-->\n\n刚拿到题就觉得比较神仙，又因为之前做过一道长得很像但几乎没什么关系的神仙题更加深了这种感觉。\n\n看左右两位神仙半小时就交了一发还写了拍，我才刚读完题，感觉这场凉凉，结果还真凉了。\n\n## 题目大意\n\n给定长为 $n$ 的数列 $a_1,a_2,\\cdots,a_n$ ，将这个数列循环 $k$ 次。求\n$$\n\\sum_{1\\leq i\\leq j\\leq n\\times k}\\left| \\bigcup_{k=i}^j\\{a_k\\}\\right|\n$$\n的值 $\\bmod 10^9+7$ 。\n\n## 核心思路\n\n首先想想可不可以写一个 $O(nk)$ 的暴力，设 $f_i$ 为以 $i$ 为右端点区间的贡献。\n\n这个式子一开始分类讨论要死。写了几十行还一直WA，调自闭后，冷静分析一下，好像是一个傻逼转移。\n\n设 $pre_i$ 为最后一个与 $a_i$ 相同点的编号。转移如下：\n$$\nf_i=f_{i-1}+i-pre_i\n$$\n这样你就获得了70pts的好成绩。\n\n这时离下考差不多只有1.5h了，我决定继续刚这题。\n\n直接推式子，……，经过一番努力，你发现式子并不好推，但是把一些因数提出来之后貌似有等差数列的性质。\n\n于是愉快地开始打表，打出每 $k$ 个的 $f_i$  之和，发现从第三项开始即为等差数列。\n\n然后用高斯求和公式就愉快地解决了。\n\n代码还是有些小细节。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n \nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n \n \nint read() {\n    int x=0,f=1,ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n \nconst ll MOD=1e9+7,MAXN=6e5+10;\nint a[MAXN],b[MAXN],pos[MAXN],pre[MAXN],f[MAXN];\n \nint qpow(int a) {\n    int ans=1,b=MOD-2;\n    while(b) {\n        if(b&1) ans=ans*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return ans;\n}\n \nint sum[4];\n \nsigned main() {\n    int n=read(),k=read();\n    REP(i,1,n) b[i]=a[i]=read();\n    sort(b+1,b+1+n);\n    int num=unique(b+1,b+1+n)-b-1;\n    REP(i,1,n) a[i]=lower_bound(b+1,b+1+num,a[i])-b;\n     \n    REP(i,n+1,3*n) a[i]=a[i-n];\n    REP(i,1,3*n) pre[i]=pos[a[i]],pos[a[i]]=i;\n    REP(i,1,3*n) f[i]=f[i-1]+i-pre[i];\n     \n     \n    REP(i,1,3) {\n        sum[i]=0;\n        REP(j,1+(i-1)*n,i*n) sum[i]=(sum[i]+f[j])%MOD;\n    }//直接找出前3n个的每一节答案\n     \n    int ans=(sum[1]+(2*sum[2]%MOD+(sum[3]-sum[2]+MOD)%MOD*(k+MOD-2)%MOD)%MOD*(k+MOD-1)%MOD*qpow(2))%MOD;\n    //从第二节开始为等差数列\n    printf(\"%lld\\n\",ans%MOD);\n    return 0;\n}\n//考场代码略丑，轻D\n```","tags":["题解","数学"],"categories":["OI","题解"]},{"title":"【JXOI2018】游戏 题解","path":"/article/JXOI2018-youxi-solution/","content":"[JXOI2018](https://www.luogu.org/problem/P4562)\n\n<!--more-->\n\n~~数学专题都好神仙啊~~\n\n这道题神奇的有两个题面。\n\n## 核心思路\n\n我们把 $[l, r]$ 内不是其它任何数的倍数的数称为关键数，那么 $t(p)$ 显然等于该排列中最后一个关键点的位置。\n\n设 $num$ 为 $[l,r]$ 中关键点的个数，那么枚举最后一个关键点的位置，答案就很显然了\n$$\n\\sum_{i=1}^ni\\times(i-1)!\\times num \\times{n-s\\choose n-i}\\times(n-i)!\n$$\n 稍微解释一下， $i$ 后面位置是不能再放关键点的，因此有 $n-s\\choose n-i$ 种选法。 $i$ 位置必须为关键点，因此有 $num$ 种选法， $i$ 前与 $i$ 后随便选取，那么有 $(i-1)!\\times(n-i)!$ 种选法。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MOD=1e9+7,MAXN=1e7+10;\n\nint vis[MAXN],num,fac[MAXN],inv[MAXN];\n\nint qpow(int a,int b) {\n\tint ans=1;\n\twhile(b) {\n\t\tif(b&1) ans=ans*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nint c(int n,int m) {\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\n\nsigned main() {\n\tint l=read(),r=read(),n=r-l+1;\n\tREP(i,l,r) {\n\t\tif(vis[i]) continue;\n\t\tnum++;\n\t\tfor(int j=i+i; j<=r; j+=i) vis[j]=1;\n\t}\n\t\n\tfac[0]=fac[1]=1;\n\tREP(i,2,n) fac[i]=fac[i-1]*i%MOD;\n\n\tinv[n]=qpow(fac[n],MOD-2);\n\tDREP(i,n-1,0) inv[i]=inv[i+1]*(i+1)%MOD;\n\n\tint ans=0;\n\t\n\tREP(i,1,n) ans=(ans+i*fac[i-1]%MOD*num%MOD*c(n-num,n-i)%MOD*fac[n-i]%MOD)%MOD;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n//常数过大，开O2过\n```","tags":["题解","数学","组合"],"categories":["OI","题解"]},{"title":"【JOI 2018 Final】美术展览 题解","path":"/article/JOI2018-artshow-solution/","content":"[JOI 2018 Final](https://loj.ac/problem/2348)\n\n<!--more-->\n\n这场挂分好惨啊😭\n\n## 核心思路\n\n首先，你所选取的美术品肯定是一个按照尺寸排序的连续区间。因为最终贡献只与最大尺寸与最小尺寸有关，中间的肯定是要全部加上。\n\n观察这个式子\n$$\n\\begin{aligned}\n&S-(A_{max}-A_{min})\\\\\n=&S-A_{max}+A_{min}\n\\end{aligned}\n$$\n可以直接维护一个后缀max，再 $\\Theta(n)$ 地扫过统计答案。\n\n官方题解强行解释部分分的操作真的很。。大家可以去看看\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=5000000+10,INF=0x3f3f3f3f3f3f;\n\nstruct work {\n\tint s,v;\n} a[MAXN];\n\nbool cmp(work a,work b) {\n\treturn a.s<b.s;\n}\n\nint jian[MAXN],far[MAXN],qianz[MAXN];\n\nsigned main() {\n\tint n=read();\n\tREP(i,1,n) {\n\t\ta[i].s=read();\n\t\ta[i].v=read();\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tREP(i,1,n) qianz[i]=qianz[i-1]+a[i].v;\n\n\tif(0&&n<=5000) {\n\t\tint ans=0;\n\t\tREP(i,1,n) REP(j,i,n) {\n\t\t\tans=max(ans,qianz[j]-qianz[i-1]+a[i].s-a[j].s);\n\t\t}\t\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\t\n\tint sum=0;\n\tDREP(i,n,1) {\n\t\tjian[i]=-a[i].s-sum;\n\t\tsum+=a[i].v;\n\t}\n\tfar[n]=n;\t\n\tDREP(i,n-1,1) {\n\t\tif(jian[i]>jian[far[i+1]]) far[i]=i;\n\t\telse far[i]=far[i+1];\n\t}\n\tint ans=0;\n\tREP(i,1,n) {\n\t\tint l=i,r=far[i];\n\t\tans=max(ans,qianz[r]-qianz[l-1]+a[l].s-a[r].s);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```","tags":["题解"],"categories":["OI","题解"]},{"title":"【NOIP2016】愤怒的小鸟 题解","path":"/article/NOIP2016-fennudexiaoniao-solution/","content":"[NOIP2016](https://www.luogu.org/problem/P2831)\n\n<!--more-->\n\n## 核心思路\n\n直接搞肯定不行。考虑状压。 \n\n设 $f(S)$ 表示，射落集合为 $S$ 的小猪所需要的最少鸟数。转移就很显然了：\n$$\n\\begin{aligned}\n\\begin{cases}\nf(0)=0\\\\\nf(S\\lor\\mathrm{line}_{i,j})=\\min \\{f(S)+1\\}\\\\\nf(S\\lor2^{i-1})=\\min\\{f(S)+1\\}\n\\end{cases}\n\\end{aligned}\n$$\n其中 $\\mathrm{line}_{i,j}$ 表示的为经过 $i,j$ 两点的抛物线可以射落的小猪的集合。\n\n在枚举 $i,j$ 的时候考虑 $S$ ，找到 $S\\lor2^{x-1}=0$ 的最小正整数，这样由 $S$ 拓展的所有点都要经过这个点。就将原来的 $\\Theta(Tn^22^n)$ 变为了 $\\Theta(Tn+Tn2^n)$ 。\n\n$\\Theta(Tn2^n)$ 实在和 $\\Theta(Tn^22^n)$ 没什么区别啊。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define eps 1e-8\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=20+5;\n\ndouble x[MAXN],y[MAXN];\nint dp[(1<<20)+5],line[MAXN][MAXN];\n\ndouble a,b;\nvoid calc(int i,int j) {\n\ta=(y[j]-(y[i]*x[j])/x[i])/(x[j]*x[j]-x[i]*x[j]);\n\tb=y[i]/x[i]-x[i]*a;\n}\n\nint lowx[(1<<20)+5];\n\nint main() {\n\tint t=read();\n\twhile(t--) {\n\t\tmemset(dp,127,sizeof(dp));\n\t\tmemset(line,0,sizeof(line));\n\t\tdp[0]=0;\n\t\tint n=read(),m=read();\n\t\tREP(i,1,n)\tscanf(\"%lf%lf\",&x[i],&y[i]);\n\t\tREP(i,1,n) REP(j,1,n) {\n\t\t\tif(fabs(x[i]-x[j])<eps||x[i]*x[j]==0) continue;\n\t\t\tcalc(i,j);\n\t\t\tif(a>-eps) continue;\n\t\t\tREP(k,1,n) if(fabs(a*x[k]*x[k]+b*x[k]-y[k])<=eps) line[i][j]|=(1<<(k-1));\n\t\t}\n\t\t\n\t\tREP(s,0,(1<<n)-1) {\n\t\t\tint i=1;\n\t\t\twhile(i<=n&&s&(1<<(i-1))) i++;\n\t\t\tdp[s|(1<<(i-1))]=min(dp[s|(1<<(i-1))],dp[s]+1);\n\t\t\tREP(j,1,n) dp[s|line[i][j]]=min(dp[s|line[i][j]],dp[s]+1);\n\t\t}\n\t\tprintf(\"%d\\n\",dp[(1<<n)-1]);\n\t}\n\treturn 0;\n}\n```","tags":["题解","状压"],"categories":["OI","题解"]},{"title":"【NOIP2014】解方程 题解","path":"/article/NOIP2014-jiefangcheng-solution/","content":"NOIP2014核心思路说实话刚拿到这道题时，除了30pts，没有任何思路。设原多项式方程的对应函数为：$$f(x)=a_0+a_1x+\\cdots+a_nx^n$$题目所求就是 $f(x)=0$ 在 $x\\in [1,m]$ 的整数解。考虑 $f(x) \\bmod p$ ，当 $f(x)=0$ 时显然等于$0$。那么直接 $\\Theta(nm)$ 暴力枚举 $[1,m]$ 并计算答案 $f(x) \\bmod p$ 是否为$0$。选择一个好的模数很重要。读入的时候用快读，边读边模。完整代码```cpp#include<iostream>#include<cstdio>#include<cmath>#include<cstring>#include<algorithm>using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i<=s; i++)#define DREP(i,e,s) for(register int i=e; i>=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)const int MAXN=100000+10,MOD=19260817;int read() {\tint x=0,f=1,ch=getchar();\twhile(ch>'9'ch<'0'){if(ch=='-')f=-1;ch=getchar();}\twhile(ch>='0'&&ch<='9'){x=(x*10+ch-'0')%MOD;ch=getchar();}\treturn x*f;}int a[MAXN],n,m;int f(int x) {\tint ans=0,prod=1;\tREP(i,0,n) {\t\tans=(ans+prod*a[i])%MOD;\t\tprod=(prod*x)%MOD;\t}\treturn ans;}int book[MAXN];int ans[MAXN],cnt;signed main() {\tn=read(),m=read();\t\tREP(i,0,n) a[i]=read();\tREP(i,1,m) if(f(i)==0) ans[++cnt]=i;\t\tprintf(\"%lld\\n\",cnt);\tREP(i,1,cnt) printf(\"%lld\\n\",ans[i]);\treturn 0;}```","tags":["题解","数学","黑科技"],"categories":["OI","题解"]},{"title":"【NOIP2012】国王游戏 题解","path":"/article/NOIP2012-guowangyouxi-solution/","content":"[NOIP2012](https://www.luogu.org/problem/P1080)\n\n<!--more-->\n\n## 核心思路\n\n很经典的贪心了。这道题从17年的附中集训第一次看到，到现在才写下总结。\n\n证明很多大佬有非常高级的方法。这里用邻项交换法。\n$$\n\\begin{aligned}\n&s\\\\ \n&a_i\\ \\  b_i\\\\\n&a_{i+1}\\ \\ b_{i+1}\n\\end{aligned}\n$$\n$$\n\\begin{aligned}\n&s\\\\ \n&a_{i+1}\\ \\  b_{i+1}\\\\\n&a_i\\ \\ b_i\n\\end{aligned}\n$$\n\n考虑上面的两种情况，假设第二种比第一种更优。\n$$\nS_1=\\frac{s}{b_i}+\\frac{s+a_i}{b_{i+1}}\\\\\nS_2=\\frac{s}{b_{i+1}}+\\frac{s+a_{i+1}}{b_i}\n$$\n令 $S_2<S_1$\n$$\nsb_{i+1}+sb_i+a_ib_i+b_i>sb_i+sb_{i+1}+a_ib_{i+1}\\\\\na_ib_i>a_{i+1}b_{i+1}\n$$\n所以按照这个排序就是最终的顺序了。\n\n这道题要用到高精度和一定的常数优化，这里就不给出代码了。","tags":["题解","搜索"],"categories":["OI","题解"]},{"title":"【CSP模拟】merchant 题解","path":"/article/merchant-solution/","content":"19.10.18\n\n<!--more-->\n\n## 题目描述\n\n有 $n$ 个物品，第 $i$ 个物品有两个属性 $k_i$ ， $b_i$ ，表示它在时刻 $x$ 的价值为 $k_i\\times x + b_i$ 。\n\n当前处于时刻 $0$ ，你可以选择不超过 $m$ 个物品，使得存在某个整数时刻 $t$ ， $t \\geq 0$ ，你选择的 所有物品的总价值大于等于 $S$ 。 \n\n给出 $S$  ，求 $t$ 的最小值。 \n\n$n\\leq10^5$\n\n## 核心思路\n\n题目显然就是 \n$$\n\\sum(kx+b)=\\sum kx+\\sum b>s\n$$\n这个式子非常难维护。\n\n考虑是否具有单调性，显然，这个必然是先减后增的。直接二分答案。\n\n考虑如何二分答案，只需要先检查 $0$ 的位置是否合法，就可以直接忽略掉递减的部分了。\n\n考虑如何check，题目规模要求 $\\Theta(n)$ 地检查。这里有一个玄学操作`nth_element`，复杂度玄学，可以卡过随机数据。\n\n考试的时候没想清楚这一点，想着有一定的概率二分可以过。然后看到题目有一个subtask是 $\\forall i,k_i<0$ ，就自己特判了一下 $0$ 的情况，就比别人多了12分。\n\n代码略","tags":["二分答案"],"categories":["OI","题解"]},{"title":"【TJOI2013】拯救小矮人 题解","path":"/article/TJOI2013-xiaoairen-solution/","content":"[TJOI2013](luogu.org/problem/P4823)\n\n<!--more-->\n\n## 核心思路\n\n将小矮人按逃生的能力排序，然后再做一个背包。\n\n思路比较容易猜到，但是证明不是很简单。\n\n## 完整代码 \n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int INF=0x3f3f3f3f,MAXN=100000+10;\nint h;\nstruct airen {\n\tint a,b;\n} a[MAXN];\n\nbool cmp(airen a,airen b) {\n\treturn a.a+a.b<b.a+b.b;\n}\nint dp[MAXN];\nint main() {\n\tint n=read();\n\tREP(i,1,n) a[i].a=read(),a[i].b=read();\n\th=read();\n\tsort(a+1,a+1+n,cmp);\n\tint sum=0,ans=0;\n\n\tREP(i,1,n) sum+=a[i].a;\n\tREP(i,1,n) dp[i]=-INF;\n\t\n\tdp[0]=sum;\n\tREP(i,1,n) DREP(j,i,1) if(a[i].b+dp[j-1]>=h) dp[j]=max(dp[j],dp[j-1]-a[i].a);\n\tDREP(i,n,0)\t\n\t\tif(dp[i]>=0) {\n\t\t\tans=i;\n\t\t\tbreak;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```","tags":["题解","贪心"],"categories":["OI","题解"]},{"title":"【JSOI2011】柠檬 题解","path":"/article/JSOI2011-ningmeng-solution/","content":"[JSOI2011](https://www.luogu.org/problem/P5504)\n\n<!--more-->\n## 核心思路\n\nM_sea写的是真的好啊\n\n设$\\mathrm{dp}_i$为前$i$个贝壳可以得到的最多柠檬，转移方程显然：\n$$\n\\begin{aligned}\n\\mathrm{dp}_i&=\\max_{j=1}^i\\{\\mathrm{dp}_{j-1}+s_i(c_i-c_j+1)\\}\\\\\n&=\\mathrm{dp}_{j-1}+s_ic_i^2+s_ic_j^2-2s_ic_ic_j+2s_ic_i-2s_ic_j+s_i\n\\end{aligned}\n$$\n\n按照斜率优化的套路，将含$i$，$j$分开，转化为一次函数，可以得到：\n$$\nm_i=s_ic_i^2+2s_ic_i+s_i,\\ \\ y=\\mathrm{dp}_{i-1}+s_ic_i^2-2s_ic_i,\\ \\ k=2c_i,\\ \\ x=s_ic_i\n$$\n\n$$\n\\mathrm{dp}_i=y-kx+m_i\n$$\n\n答案就在这些点的上凸包上，用一个单调栈维护即可。\n\n求大佬轻D。\n\n## 完整代码\n\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n    int x=0,f=1,ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n \nconst int MAXN=100000+10;\n \nint s[MAXN],p[MAXN],c[MAXN],dp[MAXN];\n \nint x(int i) {return s[i]*c[i];}\nint y(int i) {return dp[i-1]+s[i]*c[i]*c[i]-2*s[i]*c[i];}\n \ndouble calc1(int i,int j) {\n    return 1.0*(y(i)-y(j))/(x(i)-x(j));\n}\n \nint calc2(int i,int j) {\n    return dp[j-1]+s[i]*(c[i]-c[j]+1)*(c[i]-c[j]+1);\n}\n \nvector<int> stack[MAXN];\n \nsigned main() {\n    int n=read();\n    REP(i,1,n) s[i]=read(),c[i]=c[p[s[i]]]+1,p[s[i]]=i;\n    REP(i,1,n) {\n        while (stack[s[i]].size()>=2&&calc1(stack[s[i]][stack[s[i]].size()-2],i)>=calc1(stack[s[i]][stack[s[i]].size()-2],stack[s[i]][stack[s[i]].size()-1])) stack[s[i]].pop_back();\n        stack[s[i]].push_back(i);\n        while (stack[s[i]].size()>=2&&calc2(i,stack[s[i]][stack[s[i]].size()-1])<=calc2(i,stack[s[i]][stack[s[i]].size()-2])) stack[s[i]].pop_back();\n        dp[i]=calc2(i,stack[s[i]].back());  \n    }//上凸包\n    printf(\"%lld\\n\",dp[n]);\n    return 0;\n}\n```","tags":["题解","动态规划","斜率优化"],"categories":["OI","题解"]},{"title":"【CF10D】LCIS 题解","path":"/article/CF10D-solution/","content":"[Codeforces Beta Round #10](https://codeforces.com/contest/10)D题\n\n<!--more-->\n\n## 核心思路及完整代码\n\n$f_{i,j}$表示$a$中前$i$个与$b$中前$j$个的LCIS\n$$\nf_{i,j}=\n\\begin{cases}\n\\begin{aligned}\n&f_{i,j-1},\\ \\ &a_i\\neq b_j\\\\\n&\\max_{k=0}^{j-1}\\{dp_{i-1,k}+1\\}, \\ \\ &b_k<a_i\\ and \\ \\ a_i=b_j\n\\end{aligned}\n\\end{cases}\n$$\n时间复杂度$\\Theta(n^3)$\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=500+10;\n\nint n,m,a[MAXN],b[MAXN],dp[MAXN][MAXN],ans[MAXN][MAXN];\n\nvoid print(int j) {\n\tif(!j) return ;\n\tprint(ans[n][j]);\n\tprintf(\"%d \",b[j]-1);\n}\n\nint main() {\n\tn=read(),m;\n\tREP(i,1,n) a[i]=read()+1;\n\tm=read();\n\tREP(i,1,m) b[i]=read()+1;\n\t\n\tREP(i,1,n) REP(j,1,m) {\n\tans[i][j]=ans[i-1][j];\n\t\tif(a[i]!=b[j]) dp[i][j]=dp[i-1][j];\n\t\telse {\n\t\t\tREP(k,0,j-1) \n\t\t\t\tif(b[k]<a[i]) {\n\t\t\t\t\tif(dp[i-1][k]+1>dp[i][j]) {\n\t\t\t\t\t\tdp[i][j]=dp[i-1][k]+1;\n\t\t\t\t\t\tans[i][j]=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\n\tint pos=0,ans=0;\n\tREP(i,1,m) if(dp[n][i]>ans) ans=dp[n][i],pos=i;\n\tprintf(\"%d\\n\",ans);\n\tprint(pos);\n\treturn 0;\n}\n```\n\n\n\n每次$k$都从$0$开始检查到$j-1$浪费了时间，只需要记录下上次的结果和计算一下$b_{j-1}$与$a_i$关系即可。\n$$\nf_{i,j}=\n\\begin{cases}\n\\begin{aligned}\n&f_{i,j-1},\\ \\ &a_i\\neq b_j\\\\\n&\\max\\{max',b_{j-1}\\}+1, \\ \\ &b_{j-1}<a_i\\ and \\ \\ a_i=b_j\\\\\n&max', \\ \\ &b_{j-1}\\geq a_i\n\\end{aligned}\n\\end{cases}\n$$\n时间复杂度$\\Theta(n^2)$\n\n我就没写了，大家去查xgzc、M_sea的啊。","tags":["题解","动态规划"],"categories":["OI","题解"]},{"title":"【HNOI2008】玩具装箱 题解","path":"/article/HNOI2008-toy-solution/","content":"[HNOI2008](https://www.luogu.org/problem/P3195)\n<!--more-->\n\nTham题目的难度跨度真大。\n\n## 核心思路\n\n首先有一个很显然的dp，设$\\mathrm{dp}_i$为前$i$个的最小花费\n$$\n\\mathrm{dp}_i=\\min_{j=0}^{i-1}\\{\\mathrm{dp}_j+(i-j-1+\\mathrm{sum}_i-\\mathrm{sum}_j-L)^2\\}\n$$\n斜率优化的套路就是把含$i$、$j$的分离开来，为了更加方便：\n$$\na_i=\\mathrm{sum}_i+i\\ ,\\ b_i=\\mathrm{sum}_i+i+L+1\\\\\n$$\n\n方程转化为：\n$$\n\\begin{aligned}\n\\mathrm{dp}_i&=\\min_{j=0}^{i-1}[(a_i-b_j)^2+\\mathrm{dp}_j]\\\\\n\n\\mathrm{dp}_i&=(a_i-b_j)^2+\\mathrm{dp}_j\\\\\n\\end{aligned}\n$$\n\n\n$$\n2\\times a_ib_j+\\mathrm{dp}_i-a_i^2=\\mathrm{dp}_j+b_j^2\n$$\n\n再将这个式子看做一个一次函数，$a_i$是已知的\n$$\nk=2a_i,x=b_j,y=\\mathrm{dp}_j+b_j^2\n$$\n\n$$\ny=kx+\\mathrm{dp_i}-a_i^2\n$$\n\n$$\n\\mathrm{dp}_i=y-kx+a_i^2\n$$\n\n任务是要找到$\\mathrm{dp}_i$的最小值\n\n数形结合可以理解为，上述直线过点$(b_j,\\mathrm{dp}_j+b_j^2)$，直线在$y$轴截距增加$a_i^2$。\n\n最优解即在这些点的下凸包上。\n\n用单调队列维护一下就可以求出下凸包。边求边统计答案。\n\n##　完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n\n#define int ll\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=50000+10;\n\nint c[MAXN],f[MAXN],q[MAXN],a[MAXN],b[MAXN];\n\ndouble calc(int i,int j) {\n\tint yi=f[i]+b[i]*b[i],yj=f[j]+b[j]*b[j];\n\treturn 1.0*(yi-yj)/(b[i]-b[j]);\n}\n\nsigned main() {\n\tint n=read(),L=read()+1,l=1,r=1;\n\tREP(i,1,n) c[i]=read()+c[i-1];\n\tREP(i,0,n) a[i]=c[i]+i;\n\tREP(i,0,n) b[i]=a[i]+L;\n\n\tREP(i,1,n) {\n\t\twhile(l<r&&calc(q[l],q[l+1])<2*a[i]) l++;\n\t\tf[i]=f[q[l]]+(a[i]-b[q[l]])*(a[i]-b[q[l]]);\n\t\twhile(l<r&&calc(i,q[r-1])<calc(q[r-1],q[r])) r--;\n\t\tq[++r]=i;\n\t}\n\n\tprintf(\"%lld\\n\",f[n]);\n\treturn 0;\n}\n```","tags":["题解","动态规划"],"categories":["OI","题解"]},{"title":"【NOIP2016】换教室 题解","path":"/article/LG1850-solution/","content":"[NOIP2016](https://www.luogu.org/problem/P1850)\n\n<!--more-->\n\n## 核心思路\n\n设$dp_{i,j,0/1}$表示前$i$个教室，提交了$j$个申请，第$i$个教室是否成功的最小期望体力。\n\n$\\mathrm{dis}_{i,j}$表示从$i$到$j$的最短距离，Floyd初始化。\n\n下面是完整的转移方程。\n$$\n\\begin{aligned}\ndp_{i,j,0}&=\\min\\begin{cases}dp_{i-1,j,0}+dis_{c_{i-1},c_i}\\\\dp_{i-1,j,1}+(1-k_{i-1})dis_{c_{i-1},c_i}+k_{i-1}dis_{d_{i-1,c_i}}\\end{cases}\n\\\\\ndp_{i,j,1}&=\\min\\begin{cases} dp_{i-1,j-1,0}+dis_{c_{i-1},c_i}(1-k_i)+dis_{c_{i-1},d_i}k_i\\\\dp_{i-1,j-1,1}+dis_{d_{i-1},d_i}k_ik_{i-1}+dis_{d_{i-1},c_i}k_{i-1}(1-k_i)+dis_{c_{i-1},d_i}(1-k_{i-1})k_i+dis{c_{i-1},c_i}(1-k_i)(1-k_{i-1})\\end{cases}\n\\end{aligned}\n$$\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=2000+10,INF=0x3f3f3f;\n\nint c[MAXN],d[MAXN],a[MAXN][MAXN];\ndouble dp[MAXN][MAXN][2],k[MAXN];\n\nsigned main() {\n\tint n=read(),m=read(),v=read(),e=read();\n\tREP(i,1,n) c[i]=read();\n\tREP(i,1,n) d[i]=read();\n\tREP(i,1,n) scanf(\"%lf\",&k[i]);\n\n\tREP(i,0,v) REP(j,0,v) a[i][j]=INF;\n\tREP(i,1,v) a[i][i]=a[i][0]=a[0][i]=0;\n\n\tREP(i,1,e) {\n\t\tint x=read(),y=read(),w=read();\n\t\ta[x][y]=a[y][x]=min(a[x][y],w);\n\t}\n\n\tREP(t,1,v) REP(i,1,v) REP(j,1,v) a[i][j]=min(a[i][j],a[i][t]+a[t][j]);\n\tREP(i,0,n) REP(j,0,m) dp[i][j][0]=dp[i][j][1]=INF;\n\t\n\tdp[1][0][0]=dp[1][1][1]=0;\n\t\tDE(\"in\");\n\tREP(i,2,n) {\n\t\tdp[i][0][0]=dp[i-1][0][0]+a[c[i-1]][c[i]];\n\t\tREP(j,1,min(i,m)) {\n\t\t\tdp[i][j][0]=min(dp[i-1][j][0]+a[c[i-1]][c[i]],dp[i-1][j][1]+a[c[i-1]][c[i]]*(1-k[i-1])+a[d[i-1]][c[i]]*k[i-1]);\n\t\t\tdp[i][j][1]=min(dp[i-1][j-1][0]+a[c[i-1]][c[i]]*(1-k[i])+a[c[i-1]][d[i]]*k[i],\n\t\t\tdp[i-1][j-1][1]+a[d[i-1]][d[i]]*k[i]*k[i-1]+a[d[i-1]][c[i]]*k[i-1]*(1-k[i])+a[c[i-1]][d[i]]*(1-k[i-1])*k[i]+a[c[i-1]][c[i]]*(1-k[i])*(1-k[i-1]));\n\t\t}\n\t}\n\n\t\n\tdouble ans=INF;\n\t\n\tREP(i,0,m) DE(\"%.2lf\\n\",ans=min(ans,min(dp[n][i][1],dp[n][i][0])));\n\tprintf(\"%.2lf\\n\",ans);\n\treturn 0;\n}\n```","tags":["题解","图论","期望","容斥"],"categories":["OI","题解"]},{"title":"【CF5E】Bindian Signalizing 题解","path":"/article/CF5E-solution/","content":"[Codeforces Beta Round #5](https://codeforces.com/contest/5)E题\n\n<!--more-->\n\n## 核心思路\n\n大佬们用的都是[单调栈](https://www.cnblogs.com/tham/p/8038828.html) 。~~考场没想（想不到）那么多~~直接打了一个RMQ。\n\n官方题解貌似不是单调栈维护的，实现起来也非常简单。\n\n首先显然的是，全局最高一定不会被两块石头跨过（如果有多个最高，任意一个均可）。那么可以直接从这里断开，将此之前的接到最后，变成一条链。处理起来就简单很多了。\n\n但存在的问题是，一块石头很有可能绕过形成的链的最后一个点与全局最高产生贡献。解决的方案是，在形成的链末尾再补上一个全局最高。还需要减去因此而重复的点。\n\n现在开始统计答案。设$\\mathrm{l}_i$为$i$的左边第一个严格大于$i$的石头，$r_i$同理。$\\mathrm{cnt}_x$表示所有高达$x$且位于$x$和$y$之间的山丘。\n\n那么实现就很好做了。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=2000000+10;\n\nint h[MAXN],a[MAXN],c[MAXN],l[MAXN],r[MAXN];\n\nsigned main() {\n//file(\"promise\");\n\tint t=1;\n\twhile(t--) {\n\t\tmemset(c,0,sizeof(c));\n\t\tmemset(l,0,sizeof(l));\n\t\tmemset(r,0,sizeof(r));\n\t\tint n=read();\n\t\tREP(i,1,n) h[i]=read();\n\t\tint p=1;\n\t\tREP(i,1,n) if(h[i]>=h[p]) p=i;\n\t\tREP(i,0,n) a[i]=h[(i+p)%n==0?n:(i+p)%n];\n\t//\tREP(i,0,n) printf(\"%d \",a[i]);\n\t\t\n\t\t//a[n]=h[p];\t\n\t\tDREP(i,n-1,0) {\n\t\t\tr[i]=i+1;\n\t\t\twhile(r[i]<n&&a[i]>a[r[i]]) r[i]=r[r[i]];\n\t\t\tif(r[i]<n&&a[i]==a[r[i]]) c[i]=c[r[i]]+1,r[i]=r[r[i]];\n\t\t}\n\n\t\tint ans=0;\n\n\t\tREP(i,0,n-1) {\n\t\t\tans+=c[i];\n\t\t\tif(a[i]!=a[0]) {\n\t\t\t\tans+=2;l[i]=i-1;\n\t\t\t\twhile(l[i]>0&&a[i]>=a[l[i]]) l[i]=l[l[i]];\n\t\t\t\tif(l[i]==0&&r[i]==n) ans--;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n```","tags":["题解","单调栈"],"categories":["OI","题解"]},{"title":"【CF859E】Desk Disorder 题解","path":"/article/CF859E-solution/","content":"[MemSQL Start UP 3.0 - Round 1](https://codeforces.com/contest/859)E题\n\n<!--more-->\n\n## 核心思路\n\n首先，对于每一个人，都只有一种或两种选法。\n\n那么将人与位置对应连两条边。所形成的的图可以分为以下三种情况。\n\n1. 无环图（树），有$x-1$ 个椅子与$x$个点，有$x$种情况\n2. 这个图中包含一个非自环的环，整个图都是有前后依赖的，确定一条边整个图的取法就确定了，那么有$2$种情况\n3. 这个图中包含了一个自环。整个图都被自环锁定，只有一种情况\n\n最后用乘法原理把情况统计起来。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=200000+10,MOD=1e9+7;\n\nint fa[MAXN],size[MAXN],selfloop[MAXN],loop[MAXN];\n\nint find(int x) {\n\tif(fa[x]==x) return fa[x];\n\treturn fa[x]=find(fa[x]);\n}\nint link(int x,int y) {\n\tfa[find(x)]=find(y);\n}\n\nint main() {\n\tint n=read();\n\t\n\tREP(i,1,(n<<1)) fa[i]=i,size[i]=1;\n\t\n\tll ans=1;\n\t\n\tREP(i,1,n) {\n\t\tint u=read(),v=read();\n\t\tif(u==v) {selfloop[u]=1;continue;}\n\t\tu=find(u),v=find(v);\n\t\tif(u!=v) fa[u]=v,selfloop[v]|=selfloop[u],size[v]+=size[u];\n\t\telse loop[u]=1;\n\t}\n\n\tREP(i,1,(n<<1)) \n\t\tif(find(i)==i&&!selfloop[i]) {\n\t\t\tif(loop[i]) ans=1ll*ans*2;\n\t\t\telse ans=1ll*ans*size[i];\n\t\t\tans%=MOD;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```","tags":["题解","数学"],"categories":["OI","题解"]},{"title":"【POI2015】KIN 题解","path":"/article/LG3582-solution/","content":"[洛谷P3582](https://www.luogu.org/problem/P3582)\n\n<!--more-->\n\n## 核心思路\n\n此题与求解最大子段和唯一的区别在于，每一部电影如果重复则不能计入贡献。\n\n处理起来比较巧妙。\n\n我们从左往右扫过每一部电影。假设扫到了第$i$部，当前求解的$\\mathrm{ans}_i$就是$1-i$部电影的子序列电影产生贡献的最大值。\n\n考虑如何高效地处理这个问题。对于第一次出现的电影，直接在对应位置$+w_i$，为了去除重复的贡献，在第二次出现这部电影时，我们将上一次出现的位置更改为$-w_i$，在第二次出现的位置设为$w_i$。这样当同时选到第二个与第一个同样的电影时的贡献为$0$，而单独选择第二个电影的贡献可以直接包含（即不选到第一个相同的电影），单独包含第一个电影的贡献已经计算在了$\\mathrm{ans}_{i-1}$中。选到第三个相同电影时，为了避免多次减去，需要将第一个相同电影位置处设为0，第二次位置处设为$-w_i$，当前位置设为$w_i$，如此往复。\n\n最终答案就为\n$$\n\\max_{i=1}^n\\{ans_i\\}\n$$\n是不是非常ZZ。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1000000+10,INF=0x3f3f3f3f;\n\nint a[MAXN];\n\nstruct SegmentTree {\n\tint l,r,prel,prer,res,sum;\n\t#define l(x) tree[x].l\n\t#define r(x) tree[x].r\n\t#define prel(x) tree[x].prel\n\t#define prer(x) tree[x].prer\n\t#define res(x) tree[x].res\n\t#define sum(x) tree[x].sum\n} tree[MAXN<<2];\n\nvoid pushup(int p) {\n\tsum(p)=sum(p*2)+sum(p*2+1);\n\tprel(p)=max(prel(p*2),sum(p*2)+prel(p*2+1));\n\tprer(p)=max(prer(p*2+1),sum(p*2+1)+prer(p*2));\n\tres(p)=max(prer(p*2)+prel(p*2+1),max(res(p*2),res(p*2+1)));\n}\n\nvoid build(int p,int l,int r) {\n\tl(p)=l,r(p)=r;\n\tif(l==r) {\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(p*2,l,mid);\n\tbuild(p*2+1,mid+1,r);\n}\n\nvoid change(int p,int x,int d) {\n\t\n\tif(l(p)==r(p)) {\n\t\tprel(p)=prer(p)=res(p)=sum(p)=d;\n\t\treturn ;\n\t}\n\tint mid=(l(p)+r(p))>>1;\n\tif(x<=mid) change(p*2,x,d);\n\telse change(p*2+1,x,d);\n\tpushup(p);\n}\n\n\nint f[MAXN],pre[MAXN],last[MAXN];\n\nsigned main() {\n\tint n=read(),m=read();\n\tREP(i,1,n) f[i]=read();\n\tREP(i,1,m) a[i]=read();\n\tbuild(1,1,n);\n\tint ans=0;\n\tREP(i,1,n) {\n\t\tpre[i]=last[f[i]],last[f[i]]=i;\n\n\t\tif(pre[i]) change(1,pre[i],-a[f[i]]);\n\t\n\t\tif(pre[pre[i]]) change(1,pre[pre[i]],0);\n\t\tchange(1,i,a[f[i]]);\n\t\tans=max(ans,res(1));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```","tags":["线段树","最大子段和"],"categories":["OI","题解"]},{"title":"首届CSP非专业软件能力认证第一轮游记","path":"/article/2019CSP-r1/","content":"爆零了，退役了。**首届**CSP S/JDay -5Tham把几百页的初赛复习资料发到了群里，转成pdf后就再没看过了。貌似最后考的和上面没有任何关系康一康？Day -4考了一次初赛模拟，还算简单，30min做完，80+吃了一颗定心丸，感觉初赛没啥问题Day -3又考了一次初赛模拟，简直毒瘤，做了一个小时还有整整一张试卷没写。光荣32分，要是真正考试也这样就直接退役了。Day -1Tham又给考了一套初赛模拟卷，题目有些原题，做得还算流畅。没什么压力。考出来成绩不怎么样？80+当晚23:40更完最后一篇博客就睡了。---Day 1早上7:40起床，被老妈狠狠批了一顿说起床晚，看1902的大佬早就坐在教室搞学习了我还躺床上。。。飞速洗漱完，吃完早饭（一半）就往学校赶了。大概8:13到达抱朴楼门口，大伙到得差不多了。但是好像还少了那个男人。。过了大概五分钟，那个男人徐徐走来。又过了几分钟谢总赶到，清点完人数就由M_sea带队出发了。早上南门口地铁站人还蛮少，不一会儿就上了站台，当大伙正准备上车的时候，突然发现又少了那个男人，大伙集体下车。其实那个男人早就踏上前一班车到黄土岭等我们了。下地铁，步行几分钟就到了湖大综合楼，然后看到嗯，这个首届的确很。。。醒目。很搞笑。。我的考场。嗯，找了蛮久，鬼知道要从天台穿过去。当时大概的指引就是一个箭头指向一个连着天台的玻璃墙。这个墙中间有一道玻璃门。。。发卷。湖大的老教授在讲台上讲了一堆东西，什么也没听。一开始监考老师还以为没有草稿纸。前面两页做得还是蛮顺利的，只不过数学题好像全错了。做到写结果第二题，子序列问题彻底懵逼，掉了半个小时鱼才写出4.5分qwq，貌似还没对。当我知道这是一个Div3 D的时候。。。只想****CCF。这个时候窗外传来了全国人民喜闻乐见的`洒水车生日快乐歌和` `翻新旧沙发，空调zhu`？然后距离下考就只有30min了，还有一堆题没做。开始人品大法。想着考前模考错一堆今天考试人品一定会大爆发。然鹅。。没有。总之，最后一个状压DP貌似爆零了。Update：对完答案后发现只错了一个😝考完回家吃了两碗猪油拌粉和一杯Coco奶茶就睡午觉了。","tags":["游记"],"categories":["OI"]},{"title":"【SDOI2015】寻宝游戏 题解","path":"/article/SDOI2015-xunbaoyouxi-solution/","content":"[SDOI2015](https://www.luogu.org/problemnew/show/P3320)\n\n<!--more-->\n\n## 核心思路\n\n题目要求的就是关键点的极小联通子树。可以算半个结论题了。~~这个结论也不难想~~\n\n再求出图的DFS序之后，所有关键点$\\{a_1,a_2,...,a_n\\}$的极小联通子树的边权和的两倍为\n$$\n\\sum_{i=1}^{n-1}\\mathrm{dist}(a_i,a_{i+1}+\\mathrm{dist}(a_n,a_1))\n$$\n手玩一下很好理解。\n\n那么每次修改$x$的贡献就为\n$$\n\\mathrm{dist}(x,pre)+\\mathrm{dist}(x,nxt)-\\mathrm{dist}(pre,nxt)\n$$\n$\\mathrm{dist}$就拿LCA直接维护就好了，找前驱和后继用STLset最方便\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<set>\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=100000+10;\n\nint head[MAXN],_next[MAXN<<1],to[MAXN<<1],weigh[MAXN<<1],cnt;\n\nvoid addedge(int u,int v,int w) {\n\tcnt++;\n\t_next[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n\tweigh[cnt]=w;\n}\n\nint dfn[MAXN],tot,fa[MAXN][21],dept[MAXN],dist[MAXN];\n\nint lca(int u,int v) {\n\tif(dept[u]>dept[v]) swap(u,v);\n\tint len=dept[v]-dept[u];\n\tDREP(i,20,0) if((1<<i)&len) v=fa[v][i];\n\tif(u==v) return u;\n\tDREP(i,20,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];\n\treturn fa[u][0];\n}\n\nint dis(int u,int v) {\n\treturn dist[u]+dist[v]-2*dist[lca(u,v)];\n}\nint have[MAXN],pos[MAXN],id[MAXN];\n\nvoid dfs(int u,int f) {\n\tdfn[u]=++tot;id[tot]=u;\n\tfor(int i=head[u]; i; i=_next[i]) {\n\t\tint v=to[i];\n\t\tif(dfn[v]) continue;\n\t\tfa[v][0]=u;\n\t\tdept[v]=dept[u]+1;\n\t\tdist[v]=dist[u]+weigh[i];\n\t\tdfs(v,u);\n\t}\n}\n\nset<int> s;\n\nsigned main() {\n\tint n=read(),m=read();\n\tREP(i,1,n-1) {\n\t\tint u=read(),v=read(),w=read();\n\t\taddedge(u,v,w);\n\t\taddedge(v,u,w);\n\t}\n\n\tdfs(1,0);\n\t\n\n\tREP(j,1,20) REP(i,1,n) fa[i][j]=fa[fa[i][j-1]][j-1];\n\tint ans=0;\n\tREP(i,1,m) {\n\t\tint x=dfn[read()],y,z;\n\t\tset<int> :: iterator it;\n\n\t\tif(!have[id[x]]) {\n\t\t\ts.insert(x);\n\t\t\t\n\t\t\ty=id[(it=s.lower_bound(x))==s.begin()?*--s.end():*--it];\n        \tz=id[(it=s.upper_bound(x))==s.end()?*s.begin():*it];\n\t\t\t\n\t\t\tx=id[x];\n\t\t\tans+=(dis(x,y)+dis(x,z)-dis(y,z));\n\t\t\thave[x]=1;\n\n\t\t}\n\t\telse {\n\t\t\ty=id[(it=s.lower_bound(x))==s.begin()?*--s.end():*--it];\n        \tz=id[(it=s.upper_bound(x))==s.end()?*s.begin():*it];\n\t\t\ts.erase(x);\n\t\t\tx=id[x];\n\n\t\t\tans-=(dis(x,y)+dis(x,z)-dis(y,z));\n\t\t\thave[x]=0;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n```","tags":["题解","LCA"],"categories":["OI","题解"]},{"title":"【NOI2016】区间 题解","path":"/article/NOI2016qujian-solution/","content":"NOI2016\n\n<!--more-->\n\n## 核心思路\n\n答案只跟区间长度有关，代价只与长度最大值和长度最小值有关。\n\n显然优先取长度短的，再向长区间拓展。确定了最短的和最长的区间，中间的区间对答案就没有任何意义，就可以全部取。\n\n那么将区间按照长度排序，以尺取法的思想进行拓展。\n\n考虑怎么统计是否有区间被全部覆盖，线段树直接暴力加减即可。\n\n当然，$l$和$r$那么大，肯定是要离散化的。\n\n复杂度$\\Theta(n\\log^2 n)$。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1000000+10,INF=0x3f3f3f3f;\n\nint q[MAXN];\n\nstruct edge {\n\tint l,r,len;\n} a[MAXN];\n\nbool cmp(edge a,edge b) {\n\treturn a.len<b.len;\n}\n\nstruct SegmentTree {\n\tint l,r,maxx,add;\n\t#define l(x) tree[x].l\n\t#define r(x) tree[x].r\n\t#define maxx(x) tree[x].maxx\n\t#define add(x) tree[x].add\n} tree[MAXN<<2];\n\nvoid build(int p,int l,int r) {\n\tl(p)=l,r(p)=r;\n\tif(l==r) {maxx(p)=0; return ;}\n\tint mid=(l+r)>>1;\n\tbuild(p*2,l,mid);\n\tbuild(p*2+1,mid+1,r);\n}\n\nvoid spread(int p) {\n\tif(add(p)) {\n\t\tadd(p*2)+=add(p);\n\t\tadd(p*2+1)+=add(p);\n\t\tmaxx(p*2)=maxx(p*2)+add(p);\n\t\tmaxx(p*2+1)=maxx(p*2+1)+add(p);\n\t\tadd(p)=0;\n\t}\n}\n\nvoid change(int p,int l,int r,int d) {\n\tif(l(p)>=l&&r(p)<=r) {\n\t\tadd(p)+=d;\n\t\tmaxx(p)=maxx(p)+d;\n\t\treturn ;\n\t}\n\t\n\tspread(p);\n\t\n\tint mid=(l(p)+r(p))>>1;\n\tif(l<=mid) change(p*2,l,r,d);\n\tif(r>mid) change(p*2+1,l,r,d);\n\tmaxx(p)=max(maxx(p*2),maxx(p*2+1));\n}\n\n\nsigned main() {\n\tint n=read(),m=read(),cnt=0;\n\tREP(i,1,n) a[i].l=read(),a[i].r=read(),a[i].len=a[i].r-a[i].l,q[++cnt]=a[i].l,q[++cnt]=a[i].r;\n\t\n\tsort(q+1,q+1+cnt);\n\t\n\tint num=unique(q+1,q+1+cnt)-q-1;\n\t\n\tsort(a+1,a+1+n,cmp);\n\tint st=INF,ed=0;\t\n\tREP(i,1,n) {\n\t\ta[i].l=lower_bound(q+1,q+1+num,a[i].l)-q;\n\t\ta[i].r=lower_bound(q+1,q+1+num,a[i].r)-q;\n\t\t\n\t}\n\t\n\tbuild(1,1,num);\n\t\n\tint l=0,r=0,ans=INF;\n\n\twhile(r<n) {\n\t\twhile(maxx(1)<m&&r<=n) {\n\t\t\tr++;\n\t\t\tchange(1,a[r].l,a[r].r,1);\n\t\t}\n\t\tif(maxx(1)<m) break;\n\t\twhile(maxx(1)>=m&&r>=l) {\n\t\t\tl++;\n\t\t\tchange(1,a[l].l,a[l].r,-1);\n\t\t\tans=min(ans,a[r].len-a[l].len);\n\t\t}\n\t}\n\n\tprintf(\"%lld \\n\",ans==INF?-1:ans);\n\n\treturn 0;\n}\n```","tags":["题解","线段树","尺取法"],"categories":["OI","题解"]},{"title":"【BZOJ3714】Kuglarz 题解","path":"/article/BZOJ3714-solution/","content":"PA2014\n\n<!--more-->\n\n## 核心思路\n\n知道了 $a$ 到 $b$ 、 $b$ 到 $c$ 的奇偶性，就知道了 $a$ 到 $c$ 的奇偶 性。要知道任意两点间的奇偶性就只需要保证图联通即可，问题转化为最小生成树。由于是一个完全图，kruskal的复杂度为 $O(n^2\\log n^2)$ 的会TLE，只能上prim。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n#define int ll\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=2000+10,INF=0x3f3f3f3f3f3f3f3f;\n\nint a[MAXN][MAXN];\n\nint dist[MAXN],vis[MAXN];\n\nSigned main () {\n\tint n=read(),cnt=0;\n\t\n\tREP(i,1,n) REP(j,i,n) a[i-1][j]=a[j][i-1]=read();\n\n\tREP(i,0,n) dist[i]=a[1][i];\t\n\t\n\tvis[1]=1;\n\tint ans=0;\n\tREP(u,1,n) {\n\t\tint minn=INF,pos;\n\t\tREP(i,0,n) if(!vis[i]&&dist[i]<minn) minn=dist[i],pos=i;\n\t\tans+=minn;vis[pos]=1;\n\t\tREP(i,0,n) dist[i]=min(dist[i],a[pos][i]);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```","tags":["题解","最小生成树"],"categories":["OI","题解"]},{"title":"【CF891C】Envy 题解","path":"/article/CF891C-solution/","content":"[Codeforces Round #446 (Div. 1)](https://codeforces.com/contest/891)C题\n\n<!--more-->\n\n## 核心思路\n\n这道题考察了一些最小生成树与边有关的的性质：对于一个图的所有 $\\mathrm{MST}$，每种边权的边的数量都相等。\n\n那么我们可以分别考虑每一种边权的边，将其还原至加入这条边以前的状态然后再检验是否有环。\n\n考虑如何还原到此前的状态，~~可持久化并查集~~，直接将加入该种边时两端点的联通块记录下来，在询问这种边的时候直接更改即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=500000+10;\n\nstruct edge {\n\tint u,v,w,id;\n} a[MAXN],p[MAXN];\n\nbool cmp1(edge a,edge b) {\n\treturn a.w<b.w;\n}\n\nbool cmp2(edge a,edge b) {\n\treturn a.id<b.id;\n}\n\nint fa[MAXN];\n\nint find(int x) {\n\tif(fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\n\nint link(int x,int y) {\n\tfa[find(x)]=find(y);\n}\n\nint main() {\n\tint n=read(),m=read();\n\tREP(i,1,m) a[i]=(edge){read(),read(),read(),i};\n\n\tsort(a+1,a+1+m,cmp1);\n\n\tREP(i,1,n) fa[i]=i;\n\t\n\tfor(int i=1,j=1; i<=m; i=j=j+1) {\n\t\twhile(j<m&&a[j].w==a[j+1].w) j++;\n\t\tREP(k,i,j) a[k].u=find(a[k].u),a[k].v=find(a[k].v);\n\t\tREP(k,i,j) {\n\t\t\tif(find(a[k].u)==find(a[k].v)) continue;\n\t\t\tlink(a[k].u,a[k].v);\n\t\t}\n\t}\n\n\tsort(a+1,a+1+m,cmp2);\n\n\tint q=read();\n\n\tREP(t,1,q) {\n\t\tbool flag=1;\n\t\tint w=read();\n\t\tREP(i,1,w) p[i]=a[read()];\n\t\tsort(p+1,p+1+w,cmp1);\n\t\tfor(int i=1,j=1; i<=w; i=j=j+1) {\n\t\t\twhile(j<w&&p[j].w==p[j+1].w) j++;\n\t\t\tREP(k,i,j) fa[p[k].u]=p[k].u,fa[p[k].v]=p[k].v;\n\t\t\tREP(k,i,j) {\n\t\t\t\tif(find(p[k].u)==find(p[k].v)) flag=0;\n\t\t\t\tlink(p[k].u,p[k].v);\n\t\t\t}\n\t\t}\t\n\t\tif(flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\treturn 0;\n}\n```","tags":["题解","图论","最小生成树"],"categories":["OI","题解"]},{"title":"CSP前的做题日志记录","path":"/article/before-CSP/","content":"CSP前的做题日志记录\n\n<!--more-->\n<div>\n<iframe src=\"http://cdn.micdz.cn/%E5%81%9A%E9%A2%98%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95.html\" width=\"700px\" height=\"800px\"></iframe>\n</div>\n\n[单机打开](https://cdn.micdz.cn/做题日志记录.html)","tags":["记录"],"categories":["OI"]},{"title":"【CF1051F】The Shortest Statement 题解","path":"/article/CF1051F-solution/","content":"[Educational Codeforces Round 51 (Rated for Div. 2)](https://codeforces.com/contest/1051)E题\n\n<!--more-->\n\n~~也许是一道码题~~\n\n## 核心思路\n\n直接floyd是肯定过不了的，注意到$m-n\\leq20$，那么这个图可以看做为一棵树和至多20条非树边构成的。那么在树上求距离就很简单了，对于剩下的20条非树边直接暴力从两个端点开始求一遍最短路，在所有经过至少一条非树边与树上距离中找到最小值即为答案。\n\n$u\\to v$至少经过一条$(u_0,v_0)$的边的最小值为$\\min \\{\\mathrm{dist}_{id(u_0)}u+\\mathrm{dist}_{id(v_0)}v\\}$。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define int ll \n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=200000+10,INF=0x3f3f3f3f3f3f3f;\n\nstruct edge {\n\tint u,v,w;\n} a[MAXN];\n\nint f[MAXN];\n\nint find(int x) {\n\tif(f[x]==x) return x;\n\treturn f[x]=find(f[x]);\n}\n\nint link(int x,int y) {\n\tf[find(x)]=find(y);\n}\n\nint head[MAXN],_next[MAXN<<1],to[MAXN<<1],weigh[MAXN<<1],cnt;\n\nvoid addedge(int u,int v,int w) {\n\tcnt++;\n\t_next[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n\tweigh[cnt]=w;\n}\n\nqueue<int> q1;\n\nint n,m,dept[MAXN],dis[MAXN],fa[MAXN][25];\n\nvoid bfs(int s) {\n\tq1.push(s);\n\twhile(!q1.empty()) {\n\t\tint u=q1.front();q1.pop();\n\t\tfor(int i=head[u]; i; i=_next[i]) {\n\t\t\tint v=to[i];\n\t\t\tif(fa[u][0]==v) continue;\n\t\t\tfa[v][0]=u;\n\t\t\tdept[v]=dept[u]+1;\n\t\t\tdis[v]=dis[u]+weigh[i];\n\t\t\tq1.push(v);\n\t\t}\n\t}\n}\n\npriority_queue<pair<int,int> > q;\n\nint book[MAXN],dist[44][MAXN];\n\nvoid dij(int op,int s) {\n\tq.push(make_pair(0,s));\n\tREP(i,1,n) book[i]=0;\n\tREP(i,1,n) dist[op][i]=INF;\n\tdist[op][s]=0;\n\twhile(!q.empty()) {\n\t\tint u=q.top().second;q.pop();\n\t\tif(book[u]) continue;\n\t\tbook[u]=1;\n\t\tfor(int i=head[u]; i; i=_next[i]) {\n\t\t\tint v=to[i];\n\t\t\tif(dist[op][v]>dist[op][u]+weigh[i]) {\n\t\t\t\tdist[op][v]=dist[op][u]+weigh[i];\n\t\t\t\tq.push(make_pair(-dist[op][v],v));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n} \n\nint used[MAXN];\n\nint lca(int u,int v) {\n\tif(dept[u]>dept[v]) swap(u,v);\n\tint len=dept[v]-dept[u];\n\tDREP(i,19,0) if((1<<i)&len) v=fa[v][i];\n\tif(u==v) return u;\n\tDREP(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];\n\treturn fa[u][0];\n}\n\nsigned main() {\n\tn=read(),m=read();\n\tREP(i,1,m) \n\t\ta[i].u=read(),a[i].v=read(),a[i].w=read();\n\t\n\tREP(i,1,n) f[i]=i;\n\t\n\tint num=0;\n\t\n\tREP(i,1,m) {\n\t\tif(find(a[i].u)==find(a[i].v)) continue;\n\t\tlink(a[i].u,a[i].v);\n\t\taddedge(a[i].u,a[i].v,a[i].w);\n\t\taddedge(a[i].v,a[i].u,a[i].w);\n\t\tused[i]=1;\n\t\tnum++;\n\t\tif(num==n-1) break;\n\t}\n\tbfs(1);\n\tREP(j,1,19) REP(i,1,n) fa[i][j]=fa[fa[i][j-1]][j-1];\n\t\n\n\tREP(i,1,m)\n\t\tif(!used[i]) \n            addedge(a[i].u,a[i].v,a[i].w),addedge(a[i].v,a[i].u,a[i].w);\n\tint op=0;\n\tREP(i,1,m) {\n\t\tif(!used[i]) {\n\t\t\tdij(++op,a[i].u);\n\t\t\tdij(++op,a[i].v);\n\t\t}\n\t}\n\tint q=read();\n\tREP(i,1,q) {\n\t\tint u=read(),v=read();\n\t\tint ans=dis[u]+dis[v]-2*dis[lca(u,v)];\n\t\tREP(j,1,op) ans=min(ans,dist[j][u]+dist[j][v]);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}\n```","tags":["题解","图论","最短路","LCA"],"categories":["OI","题解"]},{"title":"【CF1037D】Valid BFS? 题解","path":"/article/CF1037D-solution/","content":"[Manthan, Codefest 18 (rated, Div. 1 + Div. 2)](https://codeforces.com/contest/1037)D题\n\n<!--more-->\n\n## 核心思路\n\n直接照题意模拟bfs的过程，顺序加入每个点与当前点的出边对应。用一个set维护最为直观。\n\nnzr表示让我们不要学习这种$\\Theta(n\\log n)$的做法。\n\n## 完整代码\n\n我的代码太丑了，大家看nzr神仙的代码吧\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200010;\nint n,m;\nstruct edge\n{\n\tint to,next;\n}e[N<<1];\nint head[N],cnt;\nvoid adde(int a,int b)\n{\n\te[++cnt].to=b;e[cnt].next=head[a]; head[a]=cnt;\n}\nqueue<int>q;\nint dep[N];\nint a[N];\nvoid out()\n{\n\tputs(\"No\");\n\texit(0);\n}\nint now=1;\nvoid bfs()\n{\n\tdep[1]=1;\n\tq.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front(); q.pop(); int ct=0;\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t{\n\t\t\tint v=e[i].to;\n\t\t\tif(dep[v])continue;\n\t\t\tdep[v]=dep[x]+1;ct++; \n\t\t}\n\t\tfor(int i=now+1;i<=now+ct;i++)\n\t\t\tif(!dep[a[i]])out();\n\t\t\telse\n\t\t\t\tq.push(a[i]);\n\t\tnow=now+ct;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint u,v;\n\tfor(int i=1;i<n;i++)\n\t\tscanf(\"%d%d\",&u,&v),adde(u,v),adde(v,u);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tif(a[1]!=1)out();\n\tbfs();\n\tputs(\"Yes\");\n\treturn 0;\n}\n```","tags":["题解","图论","模拟"],"categories":["OI","题解"]},{"title":"【CF525D】Arthur and Walls 题解","path":"/article/CF525D-solution/","content":"Codeforces Round #297 (Div. 2) D题\n\n<!--more-->\n\n虽然是在贪心题的集训里面的，但是这题好像和贪心没有什么关系。\n\n## 题目大意\n\n给出一个$n\\times m$的矩阵，里面有星号和点两种符号，要求把最少的星号变成点，使得点的联通块构成一个矩形。求最少需要变几个星号。\n\n \n\n## 核心思路\n\n直接寻找矩形、合并是非常困难的。相交重叠的部分不好统计，并且每合并两个矩形还有可能影响到此前已经合并好的矩形。~~玄学合并也许可以卡过去~~\n\n正解非常之不好想，思路相当巧妙。对于每一个星号，当它的周边有三个点，时，这个星号就必须要改为点。这样修改下去，直到没有一个星号的周边有三个点。\n\n考虑如何修改，因为每修改一个星号为点，都只会对这个点上下左右四个方向的8个点产生影响，bfs的时候把上下左右四个方向丢进队列即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define ll long long\n#define DE(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n//#define int ll\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=2000+10;\n\nchar a[MAXN][MAXN];\n\nqueue<pair<int,int> > q;\nint n,m;\nint tx[]={0,1,-1,1,-1};\nint ty[]={0,-1,1,1,-1};\n\nvoid bfs() {\n\twhile(!q.empty()) {\n\t\tint x=q.front().first,y=q.front().second;\n\t\tq.pop();\n\t\tREP(i,1,4) {\n\t\t\tint xx=x+tx[i],yy=y+ty[i];\n\t\t\tif(xx>n||yy>m||xx<1||yy<1) continue;\n\t\t\tif(a[x][yy]+a[xx][y]+a[xx][yy]+a[x][y]==3*'.'+'*') {\n\t\t\t\tif(a[x][yy]=='*') q.push(make_pair(x,yy)),a[x][yy]='.';\n\t\t\t\tif(a[xx][y]=='*') q.push(make_pair(xx,y)),a[xx][y]='.';\n\t\t\t\tif(a[xx][yy]=='*') q.push(make_pair(xx,yy)),a[xx][yy]='.';\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tn=read(),m=read();\n\tREP(i,1,n) {\n\t\tREP(j,1,m) a[i][j]=getchar();\n\t\tgetchar();\n\t}\n\t\n\tREP(i,1,n) REP(j,1,m) \n\t\tif(a[i][j]=='.') q.push(make_pair(i,j));\n\t\n\tbfs();\n\n\tREP(i,1,n) {REP(j,1,m) printf(\"%c\",a[i][j]); puts(\"\");}\n}\n```","tags":["题解","数学"],"categories":["OI","题解"]},{"title":"2022高考倒计时","path":"/article/time/","content":"2022高考倒计时是MicDZ由2019中考倒计时项目更改得来。\n\n<!--more-->\n\n访问[https://t.micdz.cn/](https://t.micdz.cn/)\n\n\n项目地址[GitHub](https://github.com/MicDZ/Count-down)","tags":["项目"]},{"title":"【CF1203E】Boxers 题解","path":"/article/CF1203E-solution/","content":"Codeforces Round #579 (Div. 3)  E题\n\n<!--more-->\n\n## 题目大意\n\n给定你$n$ 个数，你可以对每个数加一或减一或不变，求使最后序列不同数最多的个数。\n\n## 核心思路\n\n将$n$个数排序，然后从小到大对每个数优先减一，再不济就不变，再不济就加一。这是因为，如果你优先加一很有可能就会错过最小的数减一这个答案。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__);\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define ll long long\n \nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n \nconst ll INF=0x3f3f3f,MAXN=150000+10;\n \nint a[MAXN],have[MAXN];\n \nint main() {\n    int n=read();\n    REP(i,1,n) a[i]=read();\n    sort(a+1,a+1+n);\n    int ans=0;\n    REP(i,1,n) {\n        if(have[a[i]-1]||a[i]-1<=0) {\n            if(have[a[i]]) {\n                if(have[a[i]+1]) continue;\n                else have[a[i]+1]=1,ans++;\n            }\n            else have[a[i]]=1,ans++;\n        }\n        else have[a[i]-1]=1,ans++;\n    }\n \n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n```","tags":["题解","贪心","排序"],"categories":["OI","题解"]},{"title":"【CF1203D】Remove the Substring 题解","path":"/article/CF1203D-solution/","content":"Codeforces Round #579 (Div. 3)  D题\n\n<!--more-->\n\n## 题目大意\n\n给定你字符串$s$ 与字符串$t$，求解最多能从$s$中删去多少个元素使得$s$中仍包含$t$为子串（不要求连续，保证给定的$t$为$s$的子串）。\n\n## 核心思路\n\nD1的暴力十分好写，~~但码量似乎比D2还大些~~。\n\n$O(n^2)$ 枚举左右端点，暴力加点然后判断加完后的串还有没有$t$这个子串。正宗的暴力写法。\n\n## 完整代码\n\n```cpp\n//submit on LG\n\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__);\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define ll long long\n \nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n \nconst ll INF=0x3f3f3f,MAXN=200+10;\n \nchar s[MAXN],t[MAXN],now[MAXN];\nint lens,lent;\n \nbool check(int l,int r) {\n    int cnt=0;\n    REP(i,1,l-1) now[++cnt]=s[i];\n    REP(i,r+1,lens) now[++cnt]=s[i];\n    \n    int find=1;\n    //printf(\"cnt: %d\\n\",cnt);\n    REP(i,1,cnt) {\n        if(now[i]==t[find]) find++;\n    }\n    if(find==lent+1) return 1;\n    return 0;\n}\n \nint main() {\n    scanf(\"%s\",s+1);\n    scanf(\"%s\",t+1);\n    \n    lens=strlen(s+1),lent=strlen(t+1);\n \n    int ans=0;\n \n    REP(i,1,lens) REP(j,i,lens) {\n        if(check(i,j)) {\n            ans=max(ans,j-i+1);\n            //printf(\"%d %d\\n\",i,j);\n        }\n    }   \n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\nD2的数据范围很容易联想到二分答案，但是有了NOIp2018年积木大赛的教训后，看到$10^5$也要提防一下是不是线性的做法。\n\n首先线性地扫一遍对于$t$中的每一个一个位置$i$，求出它之前在$s$中最早能够被满足的位置，再从右边扫一遍。那么得到这个位置之后我们就可以知道任意一段区间是否能够满足。最后再线性地统计一下答案即可。","tags":["题解","暴力","线性"],"categories":["OI","题解"]},{"title":"【CF1203C】Common Divisors 题解","path":"/article/CF1203C-solution/","content":"Codeforces Round #579 (Div. 3)  C题\n\n<!--more-->\n\n## 题目大意\n\n给定你$n$个数字组成的数列，求解能将这$n$个数都整除的数的个数有多少。\n\n## 核心思路\n\n找到这$n$个数的$\\gcd$，然后求解这个$\\gcd$的因数个数即可。但是由于数字过大，需要用$\\Theta(\\sqrt a)$的复杂度求解。\n\n$n$个数的GCD求解方法可以参考：$\\gcd(a,b,c)=\\gcd(\\gcd(a,b),c)$\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__);\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define ll long long\n \nll read() {\n\tll x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n \nconst ll INF=0x3f3f3f,MAXN=400000+10;\n \nll a[MAXN];\n \nll gcd(ll a,ll b){\n    ll t;\n    while(b) {\n        t=a;\n        a=b;\n        b=t%b;\n        }\n    return a;\n}\n \nll count(ll n){\n    ll s=1;\n    for(ll i=2; i*i<=n; i++) {\n        if(n%i==0){\n            ll a=0;\n            while(n%i==0) {\n                n/=i;\n                a++;\n            }\n            s=s*(a+1);\n        }\n    }\n    if(n>1) s=s*2;\n    return s;\n}\n \nint main() {\n\tll n=read();\n    REP(i,1,n) a[i]=read();\n    ll ans=gcd(a[1],a[2]);\n    REP(i,3,n) ans=gcd(ans,a[i]);\n \n    printf(\"%lld\\n\",count(ans));\n    return 0;\n}\n \n```","tags":["题解","数学"],"categories":["OI","题解"]},{"title":"【CF1203B】Equal Rectangles 题解","path":"/article/CF1203B-solution/","content":"Codeforces Round #579 (Div. 3)  B题\n\n<!--more-->\n\n## 题目大意\n\n给定你$4*n$个小木条，让你检测是否能组成$n$个面积相等的长方形。\n\n## 核心思路\n\n考虑到组成长方形的问题，必须要有$2*n$组相同的小木条才能构成长方形。首先将序列排序，从小到大抽出奇数位的与偶数位的查看是否相等，然后存入一个$b$数组中。\n\n对于$b$数组中的任意两个数字都可以构成一个以他们为宽和高的长方形。\n\n考虑使长方形面积相等的问题。\n\n由上述的推到可得出\n\n$$\n\\forall b_i(i< n),b_i\\leq b_{i+1}\n$$\n\n那么考虑$b_n$的搭配方式，如果$b_n$选择了$b_1$，那么组成的长方形面积则为$b_n\\times b_1$，没有问题；如果选择$b_2$，那么组成的长方形为$b_n\\times b_2$，此时的$b_1$ 无论与谁进行组合都不可能与$b_n\\times b_2$相等。\n\n所以首尾搭配是唯一的解决办法。如果首位依次向内不能保证乘积相等的话就没有对应的组合方法就输出 `NO`即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__);\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define ll long long\n \nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n \nconst int INF=0x3f3f3f,MAXN=10000+10;\n \nint a[MAXN],b[MAXN];\n \nint main() {\n\tint t=read();\n\twhile(t--) {\n\t\tint n=read();\n        REP(i,1,4*n) a[i]=read();\n \n        sort(a+1,a+1+4*n);\n        bool flag=0;\n        int cnt=1;\n        for(int i=1; i<=4*n-1; i+=2) {\n            if(a[i]==a[i+1]) b[cnt++]=a[i];\n            else flag=1;\n        }\n        int times=b[1]*b[2*n];\n        REP(l,2,n) {\n            int r=2*n-l+1;\n            if(b[l]*b[r]!=times) flag=1;\n        }\n \n        if(flag) puts(\"NO\");\n        else puts(\"YES\");\n    }\n\treturn 0;\n}\n \n```","tags":["题解","数学"],"categories":["OI","题解"]},{"title":"【CF1203A】Circle of Students 题解","path":"/article/CF1203A-solution/","content":"Codeforces Round #579 (Div. 3)  A题\n\n<!--more-->\n\n## 题目大意\n\n$n$个小朋友围坐一圈，要求从$1$号小朋友开始报数，依次以顺时针或逆时针报数，如能报到$n$则输出`YES`否则输出`NO`。\n\n## 核心思路\n\n首先想到的是线性的做法，从左到右扫一遍，要求前一个为后一个加一或减一，但是实现较复杂。后来想到可以直接模拟，找到编号为$1$ 的小朋友向左或向右找，找到一边有答案就记为`YES`，否则就是`NO`。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n#define DE(...) fprintf(stderr,__VA_ARGS__);\n#define DEBUG(a) DE(\"DEBUG: %d\\n\",a)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define ll long long\n \nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n \nconst int INF=0x3f3f3f,MAXN=200+10;\n \nint p[MAXN];\n \nint main() {\n\tint t=read();\n\twhile(t--) {\n\t\tint n=read();\n\t\tREP(i,1,n) p[i]=read();\n\t\tbool flag1=0,flag2=0;\n\t\t\n\t\tint pos;\n\t\tREP(i,1,n) if(p[i]==1) pos=i;\n\t\tint cnt=1;\n\t\tREP(i,1,n-1) {\n\t\t\tint now=(i+pos)%n;\n\t\t\tif(now==0) now=n;\n\t\t\tcnt++;\n\t\t\tif(p[now]!=cnt) flag1=1;\n\t\t\t//cout<<now<<\" \";\n\t\t}\n\t//puts(\"\");\n\t\tcnt=n+1;\n \n\t\tREP(i,1,n-1) {\n\t\t\tint now=(pos+i+n)%n;\n\t\t\tif(now==0) now=n;\n\t\t\tcnt--;\n\t\t\tif(p[now]!=cnt) flag2=1;\n\t\t}\n \n\t\tif(!flag1||!flag2) puts(\"YES\");\n\t\telse puts(\"NO\"); \n\t}\n\treturn 0;\n}\n```","tags":["题解","模拟"],"categories":["OI","题解"]},{"title":"暑期学习总结","path":"/article/summer-vacation/","content":"暑期所学知识的总结本文递交已结束。","tags":["总结"],"categories":["OI"]},{"title":"Flyioi离线版","path":"/article/flyioi-offline/","content":"flyioi离线版是由MicDZ维护的flyioi本地版本。基于uoj前端，部署于github，无后端设计。\n\nUpd2019.12.03 MicDZ已停止维护该项目，请联系ratingeater\n\n[![](https://www.micdz.cn/img/2019-10-02-25.png)](https://yl.micdz.cn/)\n项目地址[GitHub](https://github.com/MicDZ/Flyioi-offline)\n\n<!--more-->","tags":["项目"]},{"title":"最近公共祖先的倍增求法总结","path":"/article/LCA-new/","content":"高效求解最近公共祖先的价值是巨大的。其中最简单的应用就是求解树任意两点之间的距离。\n\n本文递交已结束。\n\n  <!--more-->\n\n![](https://www.micdz.cn/img/2019-10-02-21.png)\n\n对于要求解节点$u$与节点$v$的最近公共祖先，朴素的思想是将$u$ 与$v$ 同时向上跳，并标记跳到过的点如果当任意一个点第一次跳到某一个被标记过的点时即为这两点的最近公共祖先。当树退化成链时求解的复杂度变为了 $O(n)$ 。利用倍增思想优化是十分简单的，“即将$u$、$v$成倍地向上跳”。但是为了方便从上向下跳更为简单。首先将两点调至同一高度，由于知道高度差，这一步只需要对高度差进行二进制拆分即可。然后，将两点向上跳$2^{\\log n}$（即为一个极大的值，超过根就记为根）步，此时两点所到之处一定是相同，那么则说明跳多了，则将两点向上跳$2^{\\log n-1}$ 步，此时如果两节点不在同一位置这说明它们的公共祖先在它们原来位置的$2^{\\log n-1}$ 与$2^{\\log n}$之间。重复上述过程则可以在$\\Theta(\\log n)$的级别下求出最近公共祖先。考虑上述算法的过程，只有在所到之点不同时两点才会向上跳即更新起点的位置，那么算法最后一定会停留在两点起点不相同但向上跳$2^0$所到之点就相同的位置，即为最近公共祖先的儿子，最后返回答案时返回其父亲即可。\n\n还有一种效率极高但空间复杂度为$O(n^2)$的最近公共祖先的算法。大概的思路是从叶子节点开始灌水，但空间复杂度极高几乎没用。","tags":["图论","LCA"],"categories":["OI"]},{"title":"最小生成树算法总结","path":"/article/minimum-spanning-tree/","content":"最小生成树是最简单的图论算法。\n\n本文递交已结束。\n\n  <!--more-->\n\n## kruskal\n\nkruskal算法是基于贪心的最小生成树算法。其算法实现流程如下：将边按照边权从小到大排序，从最小的边开始加入生成树，如果当前边的两端点未联通则可以加入生成树不会形成环，直至加到第$n-1$ 条边为止。算法的复杂度决定于排序与并查集大致为$m\\log m$。\n\n证明kruskal的正确性在课堂上没有严格说明（？），参考《算法竞赛进阶指南》证明方法如下：\n    \n\n**定理**：任意一棵最小生成树一定包含无向图中权值最小的边。\n\n证明：假设有一棵在无向图$G$中的最小生成树不包含权值最小的边。设边$e(u,v,w)$为该无向图中权值最小的边。将$e$加入树种则会和树上从$u$ 到$v$的路径一起构成一个环，且环上其他边的权都比$w$大，那么$e$可以替代任何其他边形成一棵比当前最小更小的生成树，产生矛盾，则假设不成立，原命题成立。\n\n\n有了上述的定理推导即可得出kruskal的正确性。\n    \n\n## Prim\n\nPrim算法也基于上面的定理，不同的是其思路由向生成树中加边变为加点，实现流程类似于Dijkstra算法。每次选择距离已确定生成树最短的点加入生成树，用堆优化可以实现$\\Theta(m\\log n)$的复杂度。\n    \n\n考虑kruskal算法与Prim算法的区别，Prim在处理稠密图时效率高于kruskal算法。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN=400000+10;\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint head[MAXN],_next[MAXN],to[MAXN],weigh[MAXN],cnt,dis[MAXN];\nbool vis[MAXN];\nvoid addedge(int u,int v,int w) {\n\tcnt++;\n\t_next[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n\tweigh[cnt]=w;\n}\n\ntypedef pair<int,int> p;\npriority_queue <p,vector<p>,greater<p> > q;\n\n\nint main() {\n\t\t//freopen(\"test.in\",\"r\",stdin);\n\tint n=read(),m=read();\n\tREP(i,1,m) {\n\t\tint u=read(),v=read(),w=read();\n\t\taddedge(u,v,w);\n\t\taddedge(v,u,w);\n\t}\n\n\tmemset(dis,127,sizeof(dis));\n\tdis[1]=0;\n\tq.push(make_pair(0,1));\n\tint tot=0,sum=0;  \n\twhile(!q.empty()&&tot<n) {\n\t\tint d=q.top().first,u=q.top().second;\n\t\t//puts(\"in\");\n\t\tq.pop();\n\t\tif(vis[u]) continue;\n\t\ttot++; sum+=d;\n\t\tvis[u]=1;\n\t\tfor(int i=head[u]; i; i=_next[i]) if(weigh[i]<dis[to[i]]) {\n\t\t\tdis[to[i]]=weigh[i];\n\t\t\tq.push(make_pair(dis[to[i]],to[i]));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n} \n```","tags":["图论","最短路","最小生成树"],"categories":["OI"]},{"title":"最短路径算法总结","path":"/article/shortest-path/","content":"单源最短路径又分为单源单汇与单源多汇问题，它们的复杂度几乎相同那么只考虑单源多汇问题。\n\n本文递交已结束。\n\n<!--more-->\n\nDijkstra算法是一种基于贪心的最短路径算法，通过堆优化后可以实现$\\Theta(m\\log n)$ 的复杂度。其算法实现流程如下：首先从起点出发，更新与起点相连所有点的dist 值为起点到该点的距离，再选定全局中dist 值最小的点重复上述过程，等到所有点都被作为起点拓展过一遍时算法结束。特别的该算法无法解决存在负边权的图的最短路问题。\n\n该算法的证明也是显然的。\n\n![](https://www.micdz.cn/img/2019-10-02-22.png)\n    \n证明：对于上面的这一张图,若设定1 为起点，首先会将3、5、6节点更新，此时全局最小则为6号节点，可以证明在不存在负边权的情况下，起点到6 的最短路径一定是从1 到6，这是因为任何其他到达6 的路径都需要经过非1到6这条边，那么到达6 时的距离一定会大于直接从1到6。同理从6 再更新时也是如此。更严谨的来说是，全局最小的dist值的点的最短路径是确定的，再利用该已确定最短路径的点进行拓展一定可确定另一个或在此之前的已确定的比通过该最小点拓展更小的点为下一次的出发点，该出发点的最短路径也是确定了的。\n    \nSPFA是对Bellman-Ford算法的队列优化版本，其复杂度为$\\Theta(km)$，在段凡丁论文中提出$k$是一个极小的常数是错误的，该算法的最坏复杂度为$\\Theta(nm)$，不如Dijkstra算法稳定，但对于一般的图而言（例如USACO热浪），SPFA效率是Dijkstra 的许多倍。其算法思路类似于Bellman-Ford算法，记录通过几次中转到达某地的最优情况，思路类似于BFS。队列优化后的代码非常好写。","tags":["图论","最短路"],"categories":["OI"]},{"title":"求割点、割边、强连通分量总结","path":"/article/tarjan/","content":"tarjan求图的联通性问题是一种高效的模板化方法。其依赖于$dfn$与$low$求解，十分巧妙。\nkosaraju依赖更加巧妙的性质，证明略为复杂。\n\n本文递交已结束。\n\n<!--more-->\n\n## tarjan求解\n\n对于一棵树树，其各节点时间戳如下图：\n\n![](https://www.micdz.cn/img/2019-10-02-23.png)\n\n研究树的联通性问题是没有意义的，除了时间戳（$dfn$）外，另外引入一个追溯值（$low$）记录对于一个节点$u$其本身及其**深度优先搜索子树**所有点可以回到的最小的时间戳，对于一个普通的有向图其深度优先搜索时间戳[]及追溯值() 为：\n\n![](https://www.micdz.cn/img/2019-10-02-24.png)\n\n割点判定法则：在无向图中，当某一点$u$，其任意一个出边所连的点$v$ 当且仅当满足$dfn[u]<=low[v]$（该点有一个子树中所有的点都没有办法追溯回$u$ 的祖先，则当将$u$ 删除时该子树会断开）时$u$ 为该图的割点，特别的若$u$ 为根节点，只要有超过两个子节点即为割点。\n\n割边判定法则：在无向图中，与求解割点类似的在深度优先搜索生成树中某一条边$(u,v)$，当且仅当$dfn[u]<low[v]$时，该边为割边。\n\n强连通分量的求解方法：在有向图的深度优先搜索生成树中若存在某一点$u$当满足$dfn[u]=low[u]$时，$u$ 与其子树中所有的点都在同一个强连通分量中。利用栈记录下搜索顺序，当找到一个节点$u$ 时从栈顶到栈中的$u$之间的所有元素即为其子树，它们在同一个强连通分量中。\n\n## Kosaraju求强连通分量\n\n谭老师在课堂上详细地证明了Kosaraju的正确性，证明思路较为复杂。Kosaraju与Tarjan思路相类似，首先在图中任选一个节点的作为起点开始dfs，按照退出的顺序给节点编号就是搜索森林的后序序列。再每次选择未访问的标号最大的点进行搜索，其搜索树的节点都在同一个强连通分量中。\n\n证明是比较复杂的。首先对于第一次搜索，编号小的到编号大的一定存在一条直接路径，除非它们不在同一棵树中。将图求逆后，编号小的一定不能再通过原来的路径到达编号大的，那么从编号大的节点开始dfs一遍，能够到达的节点在原图一定至少存在两条路径是让它们互相相连的。","tags":["图论","tarjan"],"categories":["OI"]},{"title":"搜索的压缩方法总结","path":"/article/search-compress/","content":"搜索的压缩是搜索中的常用技巧，能够使搜索更便于保存状态、查询状态。\n\n本文递交已结束。\n\n<!--more-->\n\n## 进制压缩法\n\n我的黑白棋游戏二进制压缩的代码如下：\n```cpp\nint binary_hash(char str[][]) {\n    int ans=0;\t\n    REP(i,1,4) REP(j,1,4)\n    \tans=(ans<<1)+str[i][j]-'0';\t\n    return ans;\n}\n```\n\n二进制压缩适用于对于状态的每一个位置有且仅有两种可能值的情况，否则需要多进制的压缩方式。其支持$\\Theta(1)$的单位置查询、$\\Theta(n)$的压缩。\n\n## 康托展开压缩法\n\n康托展开的公式如下：\n$$\n\\begin{aligned}\nX&=\\sum_{i=1}^na_i\\prod_{j=1}^{i-1}j\\\\\n&=a_n(n-1)!+a_{n-1}(n-2)!+...+a_1*0!\n\\end{aligned}\n$$\n\n其中，$a_i$表示的是表示原数的第i 位在当前未出现的元素中是排在第几个。\n\n康拓展开求出的是一个序列在对应长度序列的全排列中由小到大的顺序。求解某一序列的康托序与通过康托序逆推排列都是可以完成的。但是康托展开的朴素复杂度为$\\Theta(n^2)$，用$\\log$的数据结构优化可以实现$\\Theta(n\\log n)$ 但是实现过于复杂，逆康托展开的复杂度则更高，优化更为复杂。\n\n## 哈希压缩法\n\n还有另一种高效率的状压方法是哈希，它能够适用于各种类型的序列，例如字符串、矩阵，不受限于状态的位置及可能情况。但是无法做到通过散列值逆推出原序列，只能保证在大概率下每个序列有且仅有一个对应散列值。所以哈希更广泛应用于去重与互联网加密等环节中。哈希仍可能存在冲突即多个序列对应一个散列值的情况，但是发生错误的概率极低。无错哈希对内存的占用较高也不常用。\n\n哈希的代码如下：\n```cpp\nint hash(char s[]) {\n    int len=strlen(s);\n    int ans=0;\n    REP(i,0,len-1)\n        ans=(ans*base+s[i])%mod+prime;\n    return ans;\n}\n```\n朴素哈希的复杂度为$\\Theta(len)$，STLmap映射的复杂度要再乘上一个$\\log$的级别。","tags":["搜索"],"categories":["OI"]},{"title":"拓展欧几里得","path":"/article/ex-euclid/","content":"数论是学习OI的自闭之路。QAQ\n\n<!--more-->\n\n问题如下：\n\n求不定方程的整数解\n$$\nax+by=\\gcd(a,b)\n$$\n的解。\n\n通过欧几里得原理：\n$$\n\\gcd(a,b)=\\gcd(b,a\\%b)\n$$\n那么原式可化为：\n$$\nbx'+a\\%by'=gcd(b,a\\%b)\n$$\n那么只需求出$x$与$x'$，$y$与$y'$的关系即可：\n$$\n\\begin{aligned}\nbx'+a\\%by'&=gcd(b,a\\%b)\\\\=\\gcd(a,b)&=ax+by\\\\\n\\end{aligned}\n$$\n\n将含$a$与含$b$的合并\n\n$$\n\\begin{aligned}\n&bx'+a\\%by'=ax+by\\\\\n&bx'+ay'-\\lfloor\\frac{a}{b}\\rfloor b\\times y'=ax+by\\\\\n&b(x'-y-\\lfloor\\frac{a}{b}\\rfloor\\times y')+a(y'-x)=0\n\\end{aligned}\n$$\n\n已知该式恒成立，则：\n\n$$\n\\begin{aligned}\nx&=y'\\\\\ny&=x'-\\lfloor\\frac{a}{b}\\rfloor\\times y'\n\\end{aligned}\n$$\n\n再利用辗转相除的函数递归计算$x$，$y$即可。\n\n代码如下：\n\n```cpp\nint x,y;\n\nint exgcd(int a,int b) {\n\tif(b==0) {x=1,y=0;return a;}\n\tint g=exgcd(b,a%b);\n\tint oldx=x,oldy=y;\n\tx=oldy;\n\ty=oldx-a/b*oldy; \n\treturn g;\n}\n```\n\n这里需要注意的是，递归的边界为$x=1,y=0$时的一组特解。\n\n那么将此式拓展为一般结论，即求解：\n\n$$\nax+by=c\n$$\n首先讨论有无解，当$\\gcd(a,b)\\nmid c$一定无解，这里就不给出证明。我们另$k=\\frac{c}{\\gcd(a,b)}$：\n$$\nax'k+by'k=\\gcd(a,b)\\times k=c\n$$\n就得到了$x=x'k$，$y=y'k$。\n\n如果要求$x$非负且最小，另$t=\\frac{b}{\\gcd(a,b)}$，则$(x\\%t+t)\\%t$就是$x$的最小非负解。加$t$主要是为了处理负数的问题。\n\n有关例题：","tags":["数学","笔记"],"categories":["OI"]},{"title":"【HAOI2006】Travel 题解","path":"/article/HAOI2006-travel/","content":"[HAOI]()\n\n<!--more-->\n\n## 题目大意\n\n给定一张图，求从s到t经过边权最大与最小之比最小值。\n\n## 核心思路\n\n因为要保证$s$、$t$联通，所以按照普通的bfs思路是行不通的，会导致更新错乱的问题，因为可能到这个点的所经过最大边的最小值的路径与所经过最小边的最大值的路径是不同的，但是似乎有大佬写出了此题的bfs解法。\n\n那么考虑最小生成树的算法。考虑如下问题，如果固定图中的最小边，那么存在此边的使$s$、$t$联通的路径的最大边最小值一定是固定的。\n\n那么在这固定的含有固定的最小边的使$s$、$t$联通的路径的最大边一定是含有此固定边的使$s$、$t$联通的图中中最长边最短的。\n\n那么对于每一条边，向其中加入比它长的边，直至联通，再用图中最长边与最短边更新答案即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=500+10,MAXM=50000+10;\n\nstruct edge {\n\tint u,v,w;\n}a[MAXM];\n\nbool cmp(edge a,edge b) {\n\treturn a.w<b.w;\n}\nint fa[MAXN];\n\nint find(int x) {\n\tif(fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint link(int x,int y) {\n\tfa[find(x)]=find(y);\n}\nint main() {\n\tint n=read(),m=read();\n\tREP(i,1,n) fa[i]=i;\n\tREP(i,1,m) {\n\t\ta[i].u=read();\n\t\ta[i].v=read();\n\t\ta[i].w=read();\n\t\tlink(a[i].u,a[i].v);\n\t}\n\t\n\tint s=read(),t=read();\n\t\n\tif(find(s)!=find(t)) {puts(\"IMPOSSIBLE\");return 0;}\n\n\t\n\tsort(a+1,a+1+m,cmp);\n\t\n\t\n\tint maxx=0,minn=0;\n\tREP(i,1,m) {\n\t\tREP(j,1,n) fa[j]=j;\n\t\tint now=0;\n\t\tfor(now=i; now<=m; now++) {\n\t\t//\tnow=j;\n\t\t\tif(find(a[now].u)==find(a[now].v)) continue;\n\t\t\tlink(a[now].u,a[now].v);\n\t\t\tif(find(s)==find(t)) break;\n\t\t}\n\t\tif(find(s)!=find(t)) break;\n\t\tif(maxx*a[i].w>=a[now].w*minn) maxx=a[now].w,minn=a[i].w;\n\t}\n\tint g=__gcd(maxx,minn);\n\tif(minn/g!=1)\n\tprintf(\"%d/%d\\n\",maxx/g,minn/g);\n\telse printf(\"%d\\n\",maxx/g);\n\treturn 0;\n}\n```","tags":["题解","图论"],"categories":["OI"]},{"title":"【CJOJ】 甜点","path":"/article/Z-solution/","content":"CJ NOIp模拟赛动态规划。\n\n<!--more-->\n\n## 题目描述\n\n小 z 准备举办一个比赛。他需要提供一些甜点给参赛者来补充能量。每种甜品有一定的能量 $t_i$和大小 $u_i$，且每种甜点最多有$v_i$个。小 z 准备用箱子来包装甜点。箱子可以容纳一定体积的甜点且需要一定的费用。小 z有一种魔法，可以将一个甜点分成多份装在箱子里，最后再合在一起（但合成之后必须是完\n整的一个）。小 z 想知道准备能量至少为 P 的甜点的最小大小和最少需要多少费用来购买箱子，如果最少费用超过小 z 所拥有的钱数 k 则输出` FAIL`。\n\n## 核心思想\n\n经过分析，对于糖的能量与箱子的容量都为完全背包。只需要对糖和箱子做两次完全背包即可。这里有一个问题是，我们并不知道糖的最大体积，我们可以假定其为2000（由具体题目数据范围而定），然后在$dp[1-2000]$中找到第一个大于所需能量的最小糖果体积。再将此数值记录下来用于下次的箱子的完全背包中。\n\n## 完整代码\n\n```cpp\n//考场代码略丑\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\n#define DREP(i,e,s) for(register ll i=e; i>=s; i--)\n#define REP(i,e,s) for(register ll i=e; i<=s; i++)\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n\n\nll read() {\n\tll x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0') {if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst ll MAXN=6000+10,INF=0x3f3f3f3f3f3f3f3f;\nll w[MAXN][2],v[MAXN][2],l[MAXN][2],dp[MAXN*1000];\nint main() {\n\tfile(\"z\");\n\tll n=read(),m=n,t=20000,p=read(),q=p,power_need=read(),money_have=read();\n\tREP(i,1,n) {\n\t\tv[i][0]=read();\n\t\tw[i][0]=read();\n\t\tl[i][0]=read();\n\t}\n\tREP(i,1,p) {\n\t\tv[i][1]=read();\n\t\tw[i][1]=read();\n\t\tl[i][1]=read();\n\t}\n\tREP(i,1,n) {\n\t\tint maxx=log(l[i][0])/log(2);\n\t\tREP(j,1,maxx-1) {\n\t\t\tm++;\n\t\t\tw[m][0]=(1<<j)*w[i][0];\n\t\t\tv[m][0]=(1<<j)*v[i][0];\n\t\t\t//cout<<w[m]<<\" \"<<v[m]<<endl;\n\t\t\tl[i][0]-=(1<<j);\n\t\t}\n\t\tl[i][0]-=1;\n\t\tif(l[i][0]>0) {\n\t\t\tm++;\n\t\t\tw[m][0]=l[i][0]*w[i][0];\n\t\t\tv[m][0]=l[i][0]*v[i][0];\t\t\n\t\t\t//cout<<w[m]<<\" \"<<v[m]<<endl;\n\t\t}\n\t}//用到了log的优化\n\tREP(i,1,m) DREP(j,t,w[i][0]) dp[j]=max(dp[j],dp[j-w[i][0]]+v[i][0]);\n\tll ans=-INF;\n\tREP(i,1,t) if(dp[i]>=power_need) {printf(\"%d\\n\",i);ans=i;break;}\n\tint qerwer=ans;\n\tt=20000;\n\n\tn=m=p;\n\t\tREP(i,1,n) {\n\t\tint maxx=log(l[i][1])/log(2);\n\t\tREP(j,1,maxx-1) {\n\t\t\tm++;\n\t\t\tw[m][1]=(1<<j)*w[i][1];\n\t\t\tv[m][1]=(1<<j)*v[i][1];\n\t\t\t//cout<<v[m]<<\" \"<<w[m]<<endl;\n\t\t\tl[i][1]-=(1<<j);\n\t\t}\n\t\tl[i][1]-=1;\n\t\tif(l[i][1]>0) {\n\t\t\tm++;\n\t\t\tw[m][1]=l[i][1]*w[i][1];\n\t\t\tv[m][1]=l[i][1]*v[i][1];\t\t\n\t\t\t//cout<<v[m]<<\" \"<<w[m]<<endl;\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\n\tREP(i,1,m) DREP(j,t,w[i][1]) dp[j]=max(dp[j],dp[j-w[i][1]]+v[i][1]);\n\n\t\n\tREP(i,1,t) {\n\t\t//printf(\"%d \",dp[i]);\n\t\tif(dp[i]>=qerwer) {ans=i;break;}\n\t}\n\n\n\tif(ans>money_have) puts(\"FAIL\");\n\telse printf(\"%d\\n\",ans);\n}\n```\n\n此题的自测数据[onedrive](https://1drv.ms/f/s!AmkbL8SRgVRrge86PjqOwD4nuFyLYA)。可能需要科学上网。","tags":["题解","动态规划","背包"],"categories":["OI","题解"]},{"title":"【UVA11538】Chess Queen题解","path":"/article/UVA11538-solution/","content":"此题有$\\Theta(T)$的做法，感谢lrc大佬讲解\n\n<!--more-->\n\n已经得到了\n$$\nans_1=C_m^1A_n^2=nm(n-1)\n$$\n\n$$\nans_2=C_n^1A_m^2=nm(m-1)\n$$\n$ans_1$与$ans_2$为在同一行与同一列互相攻击的皇后数\n\n$ans_3$为在同一斜列的互相攻击皇后数\n显然\n$$\nans_3=2\\times[A_2^2+A_3^2+...+A_n^2\\times(m-n+1)+...+A_3^2+A_2^2]\n$$\n\n如何化简？将此式展开\n$$\nans_3=[1\\times2+2\\times3+...+(n-1)\\times n]\\times4+2n(n-1)(m-n)\n$$\n\n前半部分就像小学奥数中的通项求和问题了\n\n\n$$\nans_3=\\sum_{i=1}^{n-1}{i(i+1)}\\times 4+2n(n-1)(m-n)\n$$\n\n$$\n=\\sum_{i=1}^{n-1}{i^2} \\times 4+ \\sum_{i=1}^{n-1} \\times 4+2n(n-1)(m-n)\n$$\n\n由$\\sum_{i=1}^ni^2=\\frac{n(n+1)(2n+1)}{6}$得\n\n$$\nans_3=[\\frac{n(n-1)(2n-1)}{6}+\\frac{n(n-1)}{2}]\\times4+2n(n-1)(m-n)\n$$\n$$\n=\\frac {2n(n-1)(2n-1)}{3}+2n(n-1)(m-n)\n$$\n\n最后再把$ans_1$，$ans_2$，$ans_3$加起来即可\n\n\n\nPs：此题不能通过分析边角与非边角位置的攻击数来统计答案，这样会使解答更为复杂。","tags":["题解","数学"],"categories":["OI","题解"]},{"title":"香港、澳门、马尼拉、杜马盖地游玩攻略","path":"/article/php-2019/","content":"MicDZ退役后的第一个寒假去菲律宾好好放松了一把。途径了香港、马尼拉、澳门等城市。今天在此处总结一些经验，形成一篇攻略。\n\n<!--more-->\n\n## 香港\n\n### 高铁\n\n我从长沙出发，乘坐复兴号动车组到达香港西九龙。香港西九龙的入境流程十分繁琐。出站台以后首先出中国境，这里常驻只有两个窗口，排队要许久，下车一定要用跑的。注意，从香港西九龙出境如果是到香港转机的话用护照+机票订单就好了。过了中国境入香港境的时候就要填写一个单子，但去香港旅游的不需要，车站有普通话的广播提醒。在你填单子的时候会有几名警卫来抽查机票、行李。与西九龙高铁站相连的有两座地铁站，走路都要蛮久，注意选择。西九龙没有外币找兑服务，记得提前换好必要交通费用。市内基本可以用在线支付，按实时汇率来，不必担心。\n\n### 市内交通\n\n香港市区内有许多条机场快线，我住在凯德酒店，旁边就有机场快线21A，40分钟到机场。坐公车或地铁20分钟就可以到维多利亚港。可以说这个位置是十分方便的。在香港可以使用谷歌服务，记得在酒店好好享（xuan）受（yao）。\n\n![一张维多利亚港的夜景](https://www.micdz.cn/img/2019-10-02-19-1.jpg)\n\n### 餐饮\n\n香港的早餐十分丰富，价格都不菲，人均50人民币左右。大部分饭店、超市都支持了微信支付（WeChat pay）和支付宝（Ali pay）。微信偶尔有一些活动记得留意。\n\n### 香港国际机场\n\n香港国际机场我到过三遍，两次转机，一次出发。赤鱲角机场有两个航站楼、两条跑道。两座航站楼之间有“地铁”相连。gate105以上的都在小航站楼，小航站楼只能从大航站楼坐地铁到达并且小航站楼里没有什么商店、餐厅。想要吃饭的只能在大航站楼解决。记得提前动身，地铁每十分钟一趟。国际航班（香港机场全是国际航班）提前15分钟登机，你至少需要提前30分钟从大航站楼出发。我们提前20分钟结果全机场通报名字finalcall。如果你到的比较早，你可以到大航站楼的gate旁边有“免费互联网服务”，这里有苹果iMac、华硕、华为等公司的电脑。使用的人非常少，足够你嗨一把。香港国际机场的延误量比较小，基本可以放心安排2h以后的航班转机，1h以内最好不要考虑。\n\n### 购物\n\n港币的汇率在0.84左右，在香港购物是一件十分明智的选择。以Apple为例，Apple China定价与Apple HK 在数值上的定价是一致的但是港币要比人民币便宜不少。购置一台iPhoneXs Max可以便宜1000-2000元人民币。\n\n### 语言\n\n香港大部分人会粤语，在这其中有少部分人会普通话。如果你不会粤语但和你交流的人只会粤语，你最好和他直接说英语，香港人的英语还是蛮靠得住的。\n\n\n\n## 马尼拉\n\n### 马尼拉国际机场\n\n我在马尼拉只在机场呆过，具体原因是马尼拉的治安有一点问题，马尼拉机场是全市最安全的地方。尽管如此，还是让人充斥着不安。\n\n马尼拉国际机场没有国际转国内的transfer，你必须在马尼拉入海关。马尼拉机场的到达层与出发层在同一位置。千万不要搞混了你是要出机场还是要转机。如果你买的是联程机票，你可以直接凭借机票进入候机楼，但你仍然需要出马尼拉机场。所以你从马尼拉转机的流程可以这样概括：\n\n> 入菲律宾境->出马尼拉机场->入马尼拉机场->安检->候机。\n\n而国内（例如香港）的机场一般是这样：\n\n> 入香港境->候机\n\n但是，如果你没有买联程机票，因为出发层与到达层是同一层，那么这个流程将会更繁琐。\n\n> 入菲律宾境->出马尼拉机场->安检->入马尼拉机场->等待登机牌窗口更新->领取登机牌->安检->候机\n\n彻底对马尼拉机场无语。😓我们晕头转向提着大包小包问了无数工作人员，花费了整整1.5小时从到达层跑到隔壁候机楼。\n\n马尼拉机场的餐饮比较贵，我们吃的一个日系面粉花了500人民币7个人。但是味道很中国，甚至怀疑是中国人开的日料店。\n\n马尼拉机场延误很严重，经过两次乘机我大概明白了它延误的原因。飞机在taxiing的时候，飞机并不会立即开始与塔台确定是否可以起飞，这将导致飞机滑行到了跑道上再花费5分钟以上的时间与塔台确定。每架飞机5分钟，后面的航班自然就延误了。香港国际机场与之不同的是，每一名空管对应1-2架飞机，实时与飞行员确定跑道情况及排队情况，这就创造了5分钟一飞机起飞、一飞机降落的奇迹。\n\n马尼拉的夜景十分漂亮，起飞建议坐在左侧的位置，这样在起飞之后可以低空直接看到错综复杂的城市网络，坐在右侧可能只能看到茫茫大海。\n\n马尼拉国际机场有三家航空公司，分别是宿务航空公司(Cebu)、菲律宾航空公司(PHP)、亚洲航空公司(AS)注意代号的不同，三家航空公司有不同的航站楼，但也不固定。我在马尼拉坐两次飞机，两次都改了登记口，其中一次还改了航站楼，幸好到的早，但还是全机场通报了名字finalcall。\n\n## 杜马盖地\n\n杜马盖地是东内格罗斯省的省会，有全亚洲最古老的大学。\n\n### 杜马盖地机场\n\n![](https://www.micdz.cn/img/2019-10-02-20.png)\n\n这是一个非常小的机场，全机场只有一个塔台、一个跑道和两个帐篷。这两个帐篷构建起了到达处和出发处。菲律宾人非常友好，在下飞机时还给每个人发了一把伞。\n\n## 澳门\n\n至于为什么选择回程到澳门转机，最主要的原因是这架航班太便宜了。某程只要300人民币，这比我们回来的高铁票还要便宜许多。\n\n### 澳门国际机场\n\n澳门是出了名的小，但是这机场也实在是把空间利用到了极限，跑道是填出来的就不说了，就论着陆之后从跑道滑行到航站楼就花了25分钟。澳门国际机场又没有引客闸，全程摆渡车，工作人员极其冷漠爱理不理还一顿教训。到了国际到达处的时候，就被澳门的冷空调震撼了，室外温度20+，市内估计只有17左右。怕冷的我立马穿上了羽绒服。入境有大约5个柜台，不要担心排队的问题，15分钟应该足够了。持护照入境会有一张小小的纸片，告诉你一些注意事项，别搞丢了，出境可能会用到。\n\n### 交通\n\n澳门的士费用十分昂贵，并且不得超载，在国内一辆小轿车载3个大人4个小孩绰绰有余，但在澳门不行。我们从机场打的到酒店足足花了100人民币。澳门的公交系统十分发达，基本可以转一次车到全市。但是澳门没有地铁，只有动车。但是动车只有一条线路。贯穿了澳门半岛以及凼仔（澳门本地的“氹”为异体字）岛东部，终点到科技大学。港珠澳大桥好像不准游客出。\n\n### 购物\n\n澳门的苹果可以说太便宜了，定价在数值上比大陆贵100，但澳门元要比港币还便宜一点，低点甚至可以到0.75左右。这个时机去买还不是最好的时机。我们一行有人买了iPhoneXs Max256GB，花费9000人民币左右。澳门的教育优惠也比较大但是必须本地学生才能享受。\n\n我们在watson买了12罐奶粉，比大陆便宜50/罐的样子，其实没便宜多少，但是他们说澳门的东西比大陆真一些。\n\n未完待续。。。","tags":["生活"],"categories":["Others"]},{"title":"基础不等式","path":"/article/basic-inequalities-problems/","content":"这里将会持续添加一些基础的不等式定理、题目。\n\n<!--more-->\n\n## Basic Inequalities\n\n> Theorem1. 1\n>\n>  $xy\\geq2\\sqrt{xy}$. $x,y\\in \\R ^+$\n\n*Proof*\n$$\n\\begin{aligned}\n(x-y)^2&\\geq0\\\\\nx^2-2xy+y^2&\\geq0\\\\\nx^2+2xy+y^2&\\geq4xy\\\\\n(x+y)^2&\\geq4xy\\\\\nx+y&\\geq2\\sqrt{xy}\\\\\n\\Leftrightarrow xy&\\leq\\frac{x+y}{2}\\\\\nEqualitiy\\ \\ occurs\\ \\ if\\ \\ and\\ \\ only\\ \\ if\\ \\ x=y.\n\\end{aligned}\n$$\n\n> Exercise1. 1\n>\n> Use *Theorem1. 1* to solve this problem.\n>\n> Let $0<x<4$ . Prove the inequality: \n> \n>$x(8-2x)\\leq8$ .\n\n*Solution*\n$$\n\\begin{aligned}\n2x+(8-2x)=8\\\\\nx(8-2x)=\\frac{1}{2}[2x(8-2x)]\\leq\\frac{1}{2}(\\frac{2x-8-2x}{2})^2=8\n\\end{aligned}\n$$\n\n> Exercise1.2\n>\n> Let $n\\in R$ . Prove the inequality:\n>\n> $1+\\frac{1}{2^2}+\\frac{1}{3^2}+...+\\frac{1}{n^2}\\leq2$ .\n\n*Solution*\n\nIt's easy to know:\n$$\n\\frac{1}{a\\times a}\\leq\\frac{1}{a\\times(a-1)}.\n$$\nSo\n$$\n\\begin{aligned}\n1+\\frac{1}{2^2}+\\frac{1}{3^2}+...+\\frac{1}{n^2}<1+\\frac{1}{1\\times2}+\\frac{1}{2\\times3}+...+\\frac{1}{(n-1)\\times n}\\\\\n=1+\\frac1 1 -\\frac1 2 +\\frac1 2-\\frac1 3+...+\\frac{1}{n-1}-\\frac{1}{n}=2-\\frac{1}{n}<2\n\\end{aligned}\n$$","tags":["不等式"],"categories":["Math"]},{"title":"在hexo上使用KaTeX","path":"/article/katex-on-volantis/","content":"{% note  color:yellow 更新记录Upd2019.10.19：以适配新版本的hexo-renderer-markdown-it-plus<br>Upd2019.12.11：一些复杂公式的渲染问题可以在katex.org上进行测试，如果katex.org上无法正常渲染且您的TeX源码无语法错误的话，请与 KaTeX 的开发者联系。<br>Upd2022.9.19：已根据最新的主题文档改写%}随着hexo的使用用户越来越多、使用用户的范围越来越广。不少用户被如何在hexo上渲染公式所困扰。*注：本文部分素材来自网络，相关插件来源github。*存在的问题至于为什么有一些复杂的公式为什么渲染不了，主要原因是有几种 $\\LaTeX$ 的符号与markdown冲突，在渲染时发生转义错误。错误通常会直接导致无法渲染文件。操作原理具体的解决方案是卸载掉原来的渲染器，安装一个针对 $\\LaTeX$ 优化过的渲染器，并将 $\\KaTeX$ 作为公式渲染器。具体步骤 卸载与安装 卸载原有的渲染器，并安装优化后的渲染器```npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-markdown-it-plus --save```注入资源文件最新的资源文件可以在katex.org上找到，这里提供的是我是用的版本。对于一般主题你需要找到主题的head路径，并在文件`<head>`标签内添加```<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.css\" integrity=\"sha384-1IGr2Yb8xuHjwTG+WoGjj2+I/a/N6z0gDD5YIGCQxywPROOKc3+orbn/R7arWQxD\" crossorigin=\"anonymous\"><script src=\"https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.js\" integrity=\"sha384-I2b1Pcl48X93GxEkGkaMo1hrd6n+IX8H2wgSsMimGbkZoGTve/87h1FjaDNvlpQi\" crossorigin=\"anonymous\"></script>```一种常见的路径是 `blog/themes/THEME_NAME/layout/_partial/head.ejs`。对于具备注入头文件功能的主题此处以Stellar为例。直接在根目录的配置文件`_config.yml`的注入头文件。```inject: head: - '<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.css\" integrity=\"sha384-1IGr2Yb8xuHjwTG+WoGjj2+I/a/N6z0gDD5YIGCQxywPROOKc3+orbn/R7arWQxD\" crossorigin=\"anonymous\">' - '<script src=\"https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.js\" integrity=\"sha384-I2b1Pcl48X93GxEkGkaMo1hrd6n+IX8H2wgSsMimGbkZoGTve/87h1FjaDNvlpQi\" crossorigin=\"anonymous\"></script>'```*注：最新的stellar设置中内置了相关设置，可以直接使用。*效果展示可以参见https://www.micdz.cn/article/ex-euclid/","tags":["katex","material-x"],"categories":["Solutions"]},{"title":"中考历史重大事件总结","path":"/article/history-big-event/","content":"本文总结九上的思想解放运动、资产阶级革命、相关的法律文献。\n\n<!--more-->\n\n## 思想解放运动\n\n\n| 思想解放运动 | 文艺复兴 | 启蒙运动 |\n| :----: | ------ | ------- |\n| 时间 | 14C-17C | 18C |\n| 性质 | 是一次资产阶级性质的思想解放、新文化运动| 欧洲继文艺复兴以来的第二次思想解放运动。 |\n| 影响 | 1. 推动了欧洲文化思想领域的繁荣<br>2. 为资本主义的产生奠定了思想文化基础<br>3. 有力打击了封建神学<br>4. 促进了人类思想的大解放 | 1. 为法国大革命作了重要理论准备<br>2. 启发了第三等级的反抗 |\n| 代表人物及其对应思想(作品) | 但丁《神曲》，文学三杰<br>达·芬奇《蒙娜丽莎的微笑》、《最后的晚餐》，美术三杰<br>莎士比亚《哈姆雷特》、《罗密欧与朱丽叶》 | 伏尔泰：反封建专制<br>孟德斯鸠：三权分立<br>卢梭：人民有权推翻违民意的统治者。 |\n\n## 资产阶级革命\n\n| 资产阶级革命 | 英国革命 | 美国独立战争 | 法国大革命 |\n| :----: | ------ | ------ | ------|\n| 标志 | 开始：1640年议会重新召开<br>结束：光荣革命 | 开始：莱克星顿的枪声<br>结束：英国被迫承认美国独立 | 开始：攻占巴士底狱<br>结束：无明确 |\n| 过程 | 查理一世独裁<br>1649年，英国宣布为共和<br>詹姆士二世引发资产阶级反抗<br>废詹姆士二世，迎请女儿及女婿 | 1776年发表独立宣言<br>萨拉托加大捷是战争的转折点 | 1789年《人权宣言》<br>路易十六致信呼吁武装干涉法国<br>热月政变，罗伯斯庇尔被送上断头台 |\n| 性质 |  | 1. 是一次民族解放战争<br>2. 也是一次资产阶级革命 |  |\n| 影响 | 1. 英国确立了议会在国家政治生活的最高地位<br>2. 逐渐形成了君主立宪制 | 国内：推动了美国资本主义的发展、结束了美国殖民地的统治、实现民族独立。<br>国外：刺激欧洲及拉丁美洲的独立 | 法国大革命摧毁了法国的君主统治，传播了资产阶级自由民主思想。 |","tags":["历史"],"categories":["Others"]},{"title":"2019年中考政治答题框架","path":"/article/politics-exam-tricks/","content":"政治答题框架归纳。有助于快速提高分数。\n\n<!--more-->\n\n## 原因类\n\n> 题目中出现：原因、为什么、……的必要性？\n\n1. 现实依据（表述现状问题的句子）\n\n例如：中国科技水平总体上面临创新能力不强、科技发展水平总体不高、科技对社经济增长的贡献率远低于发达国家水平。*（科技国情）*\n\n2. 理论依据（课本中阐述重要性的句子）\n\n例如：创新是国家综合国力的决定性因素、创新驱动是国家的命运所系。\n\n3. 有利于（分清主体，对国家、社会、个人）\n\n从材料中寻找主体，翻译材料中句子。\n\n## 怎么做\n\n1. 翻译材料中的措施\n2. 分主体回答\n\n# 辨析题（观点）\n\n1. 完全正确型：判断+为什么+总结。\n\n2. 完全错误型：判断+为什么错误+更正错误+总结\n\n3. 观点片面型：\n\n   ​\t正误复合型：判断+正确的部分+为什么正确+错误的部分+为什么错误+总结\n\n   ​\t条件缺少型：判断+如果……则正确+为什么+如果……则错误+为什么+总结\n\n   ​\t观点不完整：判断+需要……+为什么+还需要……+为什么+总结\n\n其中，判断是指直接指出辨析类型，总结是指怎样做。\n\n## 作用类\n\n> 题目中出现作用、意义、影响\n\n有利于国家、社会、个人、材料中的其他主体。\n\n## 图表题\n\n例如以下题为例：\n\n> 材料给出：\n>\n> ![](https://www.micdz.cn/img/2019-10-02-18.png)\n>\n> *注：中国GDP同美国相比仍有较大差距*\n>\n> 从表格中，你发现了什么？\n\n答：\n\n1. 小学生答题，描述现象\n\n中华人民共和国国内生产总值增长较快。\n\n2. 通过现象看本质\n\nGDP的提高代表中国经济不断发展、综合国力不断提升、国际地位不断提高。\n\n（收入提高代表人民生活水平提升）\n\n3. 对比（中国、发达国家、城乡）\n\n同美国发达国家相比还有一定差距。\n\n4. 注意一些特殊数字\n\n改革开放取得辉煌成就。\n\n\n\n## 感悟类\n\n是什么？为什么？怎么做（分主体回答）？","tags":["政治"],"categories":["Others"]},{"title":"NOIp2018总结","path":"/article/NOIp2018/","content":"NOIp2018总结\n\n<!--more-->\n\n## 解题（不是题解）\n\n### Day1\n\n#### T1-铺设道路\n\n看到数据范围，$n\\leq5\\times10^5$。第一反应，$\\log$级数据结构。想了想可以用线段树维护区间最小值，推了下复杂度差不多刚刚好，常数也很小。于是开码。0.75小时过后，线段树调试太难，突然想起考前集训的时候老师讲的——提高组考试出现线段树只可能是最后一题。于是就把线段树删去。开坑$\\Theta(n)$的算法。\n\n我简单分析了一下，样例表面上是找最小值然后断开，实际上是一层一层删去的。于是就有了下图的玄学解法。\n\n![](https://i.loli.net/2018/11/11/5be7bff43617d.png)\n\n首先将图从上至下以不同的高度扫一遍，看一层有多少段，拿ans加上就好了。\n\n可以证明复杂度是$\\Theta(n)$的，但是常数略大（实际上好像有$\\Theta(n\\times m)$），导致大样例跑了3s+。\n\n我冷静的算了一下，评测机是使用的Intel Core i7。而我们考试的电脑还是Intel奔腾。因此我认为卡卡常没准能过。事实。。。\n\n知道这是原题、并且**一年**前我还做过的时候是崩溃的。毕竟这题在考场上想了1小时还卡了常，还不知道能不能过。\n\n#### T2-货币系统\n\n正解是一个背包？考试的时候有往背包想。而且推出了两个性质：\n\n1. 最后等价的货币系统必须由原本的货币系统中有的得出。\n2. 有倍数关系的货币可以被替代。\n\n第二个性质可以说是非常显然了。第一个性质也非常容易想。\n\n于是就开坑打了个枚举+完全背包。复杂度大概是$\\Theta(n!+n\\times \\max\\{a_i\\})$。大概可以拿65分。本来枚举的部分已经写完了。但是心里总想着T1会不会卡不过去，又不知道哪里看错了把复杂度分析错了，一下就把代码删掉否认了这个解法。vim的寄存器又被我一不小心CTR+R清掉，然后就没了代码。\n\n实际上知道这个解法后，再把枚举改成背包就A了。。\n\n#### T3-赛道修建\n\n毒瘤。打了个树的直径光荣拿了5分（不记得考场上写没写了）。。。\n\n本来还想用二分求链的部分分，因为时间紧迫就没做了。\n\n### Day2\n\n#### T1-旅行计划\n\n用优先队列处理出边，dfs搜一遍拿走了60分跑路。\n\n$n=m$想用tarjan找到割边发现并没有什么用。\n\n#### T2-填数游戏\n\n推了一小时找$n=2,m=3$的情况有多少，还不知道数对没。。\n\n#### T3\n\n毒瘤，暴力都不晓得打。。。\n\n## 总结\n\n就目前阶段而言，拿1=的水平还是没有。回去好好考中考，在这次考试中吸取教训。以后一旦有思路，就坚持做下去，不要即将成功又因一时困难而放弃。在未来各种考试中也是这样。\n\n**革命尚未成功，同志仍需努力！**","tags":["总结"],"categories":["OI"]},{"title":"树状数组与逆序对","path":"/article/ni-xu-dui/","content":"在NOIp来之前，赶快奶一口会出逆序对毒瘤数学题，RP++。\n\n<!--more-->\n\n在前几年的NOIp的考试中，已经有很久没有出现过与逆序对有关的题目了。但是正因如此，逆序对在这次NOIp出现的几率就大大提高了。\n\n## 核心思路\n\n计算逆序对可以通过归并排序或桶排+数据结构优化的思路求解。\n\n又因为归并排序的应用范围不广，因此我更倾向于学习桶排+数据结构优化的方法求逆序对。\n\n下面给出一个样例：\n\n```\n1 8 2 1 4 14 2\n```\n\n如果我们以桶排的思路依次存下每一个元素出现的数量，那么我们只需要求出在它之前的比他大的元素数量，最后求和即可。\n\n因此我们可以对原数列离散化成：\n\n```\n1 4 2 1 3 5 2\n```\n\n对于这个数列，例如我们在计算以第4个`1`为右端点的逆序对的时候，我们只需要统计从第1个到第3个数字中大于`1`的数的个数。\n\n这里可应用桶排的思想，从左向右扫，将每一个数加入对应的桶中，再用树状数组对小于当前的元素的桶维护前缀和即可。这样动态单点修改，区间查询就成为了树状数组的强项，可以用树状数组优化到$\\log$级。\n\n\n## 完整代码\n\n同样也可以用线段树，这里只有树状数组的代码。\n\n解释见注释。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 500000+10\n#define lowbit(x) (x&(-x))\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n#define ll long long\nint read() {\n    int x=0,f=1,ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nint c[MAXN],temp[MAXN],n;\n\nstruct edge {\n    int id,num;\n} a[MAXN];\n\nbool cmp(edge q,edge w) {\n    if(q.num==w.num)\n        return q.id<w.id;\n    return q.num<w.num;\n}//使用stable_sort可以达到同样效果。\n\nvoid add(int x,int v) {\n    while(x<=n) {\n        c[x]+=v;\n        x+=lowbit(x);\n    }\n}\n\nint sum(int x) {\n    int ans=0;\n    while(x) {\n        ans+=c[x];\n        x-=lowbit(x);\n    }\n    return ans;\n}\n\nint main() {\n    n=read();\n    REP(i,1,n) {\n        a[i].num=read();\n        a[i].id=i;\n    }\n    \n    sort(a+1,a+1+n,cmp);\n    //stable_sort(a+1,a+1+n,cmp);\n    \n\tREP(i,1,n)\n        temp[a[i].id]=i;//temp存离散化后的值\n        \n    ll ans=0;\n    REP(i,1,n) {\n        add(temp[i],1);//将temp[i]加1\n        ans+=i-sum(temp[i]);//i为在这之前的数字总个数，sum(temp[i])表示就目前为止小于等于temp[i]的个数。\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n# 小结\n\n这是一种思路简单，代码实现简易的逆序对求法。唯一的不足就是~~常数~~可能会比较大。\n\n复杂度为$\\Theta(3\\times n\\log n)$。","tags":["随笔","笔记"],"categories":["OI"]},{"title":"快速读入的玄学","path":"/article/qread/","content":"在面对超大数据的读入时，我们不得不面对快速的读入方式。\n\n<!--more-->\n\n## 测试用数据\n\n测试所使用的数据通过以下代码生成。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n\nint main() {\n\tfreopen(\"testdata.in\",\"w\",stdout);\n\tint n=100000;\n\tprintf(\"%d\\n\",n);\n\tsrand(time(0));\n\tREP(i,1,n) printf(\"%d\\n\",rand());\n\treturn 0;\n}\n```\n\n第一行一个整数$n$，接下来$n$行一个随机数，行末无空格。\n\n## 使用cin读入测试用数据\n\n测试用代码如下：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n\nint main() {\n\tfreopen(\"testdata.in\",\"r\",stdin);\n\tdouble start=clock();\n\tint n;\n\tcin>>n;\n\tint a;\n\tREP(i,1,n) cin>>a;\n\tdouble end=clock();\n\n\tprintf(\"%.3llf\\n\",end-start);\n\treturn 0;\n}\n```\n\n如图所示![](https://www.micdz.cn/img/2019-10-02-14.png)\n\n使用cin为2011ms。\n\n## 使用scanf读入测试用数据\n\n测试用代码如下：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n\nint main() {\n\tfreopen(\"testdata.in\",\"r\",stdin);\n\tdouble start=clock();\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a;\n\tREP(i,1,n) scanf(\"%d\",&a);\n\tdouble end=clock();\n\n\tprintf(\"%.3llf\\n\",end-start);\n\treturn 0;\n}\n```\n\n如图所示![](https://www.micdz.cn/img/2019-10-02-15.png)\n\n使用scanf为970ms。\n\n## 使用快读读入测试用数据\n\n测试用代码如下：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n\nint read() {\n\tint x=0,f=1,ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint main() {\n\tfreopen(\"testdata.in\",\"r\",stdin);\n\tdouble start=clock();\n\tint n;\n\tn=read();\n\tint a;\n\tREP(i,1,n) a=read();\n\tdouble end=clock();\n\n\tprintf(\"%.3llf\\n\",end-start);\n\treturn 0;\n}\n```\n\n如图所示![](https://www.micdz.cn/img/2019-10-02-16.png)\n\n使用快读为364ms。\n\n## 使用关闭同步cin测试用数据\n\n\n测试用代码如下：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,e,s) for(register int i=e; i<=s; i++)\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tfreopen(\"testdata.in\",\"r\",stdin);\n\tdouble start=clock();\n\tint n;\n\tcin>>n;\n\tint a;\n\tREP(i,1,n) cin>>a;\n\tdouble end=clock();\n\n\tprintf(\"%.3llf\\n\",end-start);\n\treturn 0;\n}\n\n```\n\n如图所示![](https://www.micdz.cn/img/2019-10-02-17.png)\n\n使用关闭同步cin为624ms。\n\n但是此方法极其不稳定，不建议使用。\n\n## 小结\n\n当面对大数据读入的时候，一定要记得使用快读或scanf。","tags":["随笔","黑科技"],"categories":["OI"]},{"title":"线段树进阶","path":"/article/segment-tree-pro/","content":"在[上篇](https://www.micdz.cn/article/segment-tree/)文章中，已经进行了详细的对线段树单点修改和区间查询的描述。\n\n在这篇文章中将会更深入的了解线段树的区间修改。不过，在NOIp赛事中，几乎很少出现。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n## 核心思路\n\n在上篇文章中，已经证明了线段树的区间修改的时间复杂度是$\\Theta(\\log n)$的，可以以此为思路研究区间修改的方法。\n\n试想，如果我们在一次区间修改的操作中一次性将其子树的所有节点全部更新，而后面的查询操作根本不会用到这些节点，那么这些修改就完全浪费了。\n\n我们在修改操作的时候对$p$加入一个标记，标识“该节点曾经修改，但其子节点尚未被跟新”，每一次查询操作的时候再将该标记向下传递。\n\n我们称这种标记为“延迟标记”或“懒惰标记”。这就运用到了线段树优秀的性质。\n\n接下来，我们以POJ3468为例，了解区间修改的线段树。\n\n## 具体实现\n\n建树、查询、修改的框架保持不变，用`spread`函数实现向下传递。\n\n### 建树\n\n用与上一篇一样，但是我们可以用几个宏定义的方法减少代码量。\n\n```cpp\nstruct SegmentTree {\n\tint l,r;\n\tll sum,add;\n\t#define l(x) tree[x].l\n\t#define r(x) tree[x].r\n\t#define sum(x) tree[x].sum\n\t#define add(x) tree[x].add\n} tree[MAXN<<2];\n```\n\n利用上述的宏定义可以很方便地访问线段树。\n\n建树过程\n\n```cpp\nvoid build(int p,int l,int r) {\n\tl(p)=l,r(p)=r;\n\tif(l==r) {\n\t\tsum(p)=a[l];\n\t\treturn ;\t\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(p*2,l,mid);\n\tbuild(p*2+1,mid+1,r);\n\tsum(p)=sum(p*2)+sum(p*2+1);\n}\n```\n### 传递标记\n\n根据题目的维护内容改写。\n\n```cpp\nvoid speard(int p) {\n\tif(add(p)) {\n\t\tsum(p*2)+=add(p)*(r(p*2)-l(p*2)+1);//更新左字节点和\n\t\tsum(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1));//更新右子节点和\n\t\tadd(p*2)+=add(p);//更新标记\n\t\tadd(p*2+1)+=add(p);\n\t\tadd(p)=0;//切记不能忘记\n\t}\n}\n```\n\n### 区间修改\n\n思路算是比较简单，但是有许多细节容易忘记导致莫名RE或TLE。\n\n```cpp\nvoid change(int p,int l,int r,int d) {\n\tif(l<=l(p)&&r>=r(p)) {//完全覆盖\n\t\tsum(p)+=d*(r(p)-l(p)+1);//这里是区间长度\n\t\tadd(p)+=d;//只更新当前节点信息\n\t\treturn ;\n\t}\n\tspread(p);//向下传递\n\tint mid=(l(p)+r(p))>>1;\n\tif(l<=mid) change(p*2,l,r,d);//左区间覆盖\n\tif(r>mid) change(p*2+1,l,r,d);//右区间覆盖\n\tsum(p)=sum(p*2)+sum(p*2+1);\n}\n```\n\n### 区间查询\n\n与上一篇所描述的方法几乎相同，只不过每一次查询都需要花一点点时间向下传递标志。\n\n```cpp\nll ask(int p,int l,int r) {\n\tif(l<=l(p)&&r>=r(p)) return sum(p);\n\tspread(p);\n\tll val=0;\n\tif(l<=mid) val+=ask(p*2,l,r);\n\tif(r>mid) val+=ask(p*2+1,l,r);\n\treturn val;\n}\n```\n\n## 小结\n\n在NOIp赛事中，使用线段树、数状数组、平衡树等高级的数据结构一般是在T3或毒瘤的T2，因此掌握好这些数据结构有助于我们在考场上快速想到正解。","tags":["随笔","笔记","数据结构"],"categories":["OI"]},{"title":"一些可以在考场上用到的vim快捷键","path":"/article/vim/","content":"即将参加NOIp2018考试，在此做一个备忘录。\n\n<!--more-->\n\nPs: 在湖南赛区的NOIp得到noilinux中预置了廖老师的.vimrc文件。\n注意，在廖老师配置的.vimrc中缺少了`set mouse=a`。\n\n在终端中：\n\n1. 设置终端透明：键入`metacity -c`，在终端上方配置文件首选项即可在透明的vim下查看题面。\n2. 键入python2/3可以使用python。\n\n在vim中：\n\n1. 复制粘贴：在`选择`模式下，键入`y`复制，`p`粘贴。\n2. 撤销与撤回撤销： 在`普通`模式下，键入`u`撤销，`Ctrl`+`r`撤回撤销。\n3. 删除当前行：在`普通`模式下，键入`d`+`d`删除。\n4. 强制退出vim：在`命令`模式下，键入`:q!`。\n4. 保存并退出：在`命令`模式下，键入`:wq`。\n\n预祝大家取得完美成绩，RP++！\n\n\n\n> 2019.10.19更新\n\n在vim下向普通的文本编辑器一样使用Ctrl复制粘贴的方法","tags":["随笔","笔记"],"categories":["OI"]},{"title":"【FLYIOI63】逃离 题解","path":"/article/FLYIOI63-solution/","content":"题目链接[here](http://lxg.yali.edu.cn:8080/problem/63)\n\n这是一道非常有思维难度和代码强度的宽搜好题。\n\n<!--more-->\n## 题目大意\n\n在一个地图中有两个人物和一些障碍物。\n\n小z具有技能急速:每次移动可以走两步(允许这两步的方向不同,也允许不走第二步);\n\n小m具有技能跳跃:若移动的方向为障碍且障碍后为空地,可借助障碍直接跳跃至空地。\n\n计算两人相遇最少要花费多少秒。\n\n![](https://i.loli.net/2018/11/08/5be39f813bd58.png)\n\n如上图所示，黄色表示可以到达区域，黑色表示障碍物。\n\n## 核心思路\n\n通过数据范围可以发现此题的$n\\leq 1000$，就可以进行广搜，并且留下了可观的常数范围。\n\n### 广搜小z\n\n#### 分解小z技能\n\n小z的技能相当于在一秒内运用两次常规操作。因此我们只需要对小z做两次push即可。\n\n#### 小z的搜索代码\n```cpp\nvoid bfs1(int xs,int ys) {\n\tint tx[5]={0,1,0,-1,0};\n\tint ty[5]={0,0,1,0,-1};\n\tqueue<edge2> q;\n\tq.push((edge2){0,xs,ys});\n\thave[xs][ys]=1;\n\tz[xs][ys]=0;\n\twhile(!q.empty()) {\n\t\tint x=q.front().xq,y=q.front().yq,s=q.front().s;\n\t\tq.pop();\n\t\tif(a[x][y]) continue;\n\t\tfor(int i=1; i<=4; i++) {\n\t\t\tint xx=x+tx[i],yy=y+ty[i];\n\n\t\t\tif(xx<1||xx>n||yy<1||yy>n||a[xx][yy]) continue;\n\t\t\tif(!have[xx][yy]) {\n\t\t\t\thave[xx][yy]=1;\n\t\t\t\tz[xx][yy]=s+1;//答案存在z数组中\n\t\t\t\tq.push((edge2){s+1,xx,yy});//跳第一次到达的点\n\t\t\t}\n\t\t\tfor(int j=1; j<=4; j++) {\n\t\t\t\tint xr=xx+tx[j],yr=yy+ty[j];\n\t\t\t\tif(xr<1||xr>n||yr<1||yr>n||a[xr][yr]||have[xr][yr]) continue;//如果中间的这个点是障碍物则无法运用技能\n\t\t\t\thave[xr][yr]=1;\n\t\t\t\tz[xr][yr]=s+1;//答案存在z数组中\n\t\t\t\tq.push((edge2){s+1,xr,yr});//运用技能调达的点\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 广搜小m\n\n#### 分解小m技能\n\n小m的技能相当于如果常规操作跳到一个障碍物上，那么可以在跳跃方向上继续向前跳一格，但是要判断前面的这一格是否为障碍物。\n\n#### 小z的搜索代码\n```cpp\nvoid bfs1(int xs,int ys) {\n\tint tx[5]={0,1,0,-1,0};\n\tint ty[5]={0,0,1,0,-1};\n\t\n\tqueue<edge> q;\n\tq.push((edge){xs,ys});\n\twhile(!q.empty()) {\n\t\tint x=q.front().xq,y=q.front().yq;\n\n\t\tq.pop();\n\t\tfor(int i=1; i<=4; i++) {\n\t\t\tint xx=x+tx[i],yy=y+ty[i];\n\t\t\tif(have[xx][yy]||xx<1||xx>n||yy<1||yy>n) continue;\n\t\t\t\n\t\t\tif(a[xx][yy]) {\n\t\t\t\tif(i==1) xx++;\n\t\t\t\tif(i==2) yy++;\n\t\t\t\tif(i==3) xx--;\n\t\t\t\tif(i==4) yy--;\n\t\t\t}//如果xx,yy是障碍物则跳过障碍物，针对不同的来路要跳到指定的地方\n\t\t\t\n\t\t\tif(have[xx][yy]||xx<1||xx>n||yy<1||yy>n) continue;\n\t\t\t\n\t\t\tif(!a[xx][yy]) {\n\t\t\t\tm[xx][yy]=min(m[xx][yy],m[x][y]+1);//答案存储在m数组中\n\t\t\t\tq.push((edge){xx,yy});\n\t\t\t\thave[xx][yy]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n### 统计答案\n\n$\\Theta(nm)$扫整个图一遍，找到$\\max(z_{i,j},m_{i,j})$最小的点。\n```cpp\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++) {\n\t\t\tans=min(ans,max(m[i][j],z[i][j]));\n\t\t}\n```\n\n## 完整代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN 1000+10\n#define INF 0x3f3f3f3f\nint read() {\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,xa,xb,ya,yb;\n\nint a[MAXN][MAXN];\n\nint z[MAXN][MAXN],m[MAXN][MAXN];\n\n\nvoid debug1() {\n\tcout<<endl;\n\tfor(int i=1; i<=n; i++) {\n\t\tfor(int j=1; j<=n; j++) {\n\t\t\tprintf(\"%3d\",m[i][j]==INF?0:m[i][j]);\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n\nvoid debug2() {\n\tcout<<endl;\n\tfor(int i=1; i<=n; i++) {\n\t\tfor(int j=1; j<=n; j++) {\n\t\t\tprintf(\"%3d\",(z[i][j]==INF?0:z[i][j]));\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nstruct edge{\n\tint xq,yq;\n};\n\nint have[MAXN][MAXN];\n\nvoid bfs1(int xs,int ys) {\n\tint tx[5]={0,1,0,-1,0};\n\tint ty[5]={0,0,1,0,-1};\n\t\n\tqueue<edge> q;\n\tq.push((edge){xs,ys});\n\twhile(!q.empty()) {\n\t\tint x=q.front().xq,y=q.front().yq;\n\n\t\tq.pop();\n\t\tfor(int i=1; i<=4; i++) {\n\t\t\tint xx=x+tx[i],yy=y+ty[i];\n\t\t\tif(have[xx][yy]||xx<1||xx>n||yy<1||yy>n) continue;\n\t\t\t\n\t\t\tif(a[xx][yy]) {\n\t\t\t\tif(i==1) xx++;\n\t\t\t\tif(i==2) yy++;\n\t\t\t\tif(i==3) xx--;\n\t\t\t\tif(i==4) yy--;\n\t\t\t}\n\t\t\t\n\t\t\tif(have[xx][yy]||xx<1||xx>n||yy<1||yy>n) continue;\n\t\t\t\n\t\t\tif(!a[xx][yy]) {\n\t\t\t\tm[xx][yy]=min(m[xx][yy],m[x][y]+1);\n\t\t\t\tq.push((edge){xx,yy});\n\t\t\t\thave[xx][yy]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nstruct edge2{\n\tint s,xq,yq;\n};\n\nvoid bfs2(int xs,int ys) {\n\tint tx[5]={0,1,0,-1,0};\n\tint ty[5]={0,0,1,0,-1};\n\tqueue<edge2> q;\n\tq.push((edge2){0,xs,ys});\n\thave[xs][ys]=1;\n\tz[xs][ys]=0;\n\twhile(!q.empty()) {\n\t\tint x=q.front().xq,y=q.front().yq,s=q.front().s;\n\t\tq.pop();\n\t\tif(a[x][y]) continue;\n\t\tfor(int i=1; i<=4; i++) {\n\t\t\tint xx=x+tx[i],yy=y+ty[i];\n\n\t\t\tif(xx<1||xx>n||yy<1||yy>n||a[xx][yy]) continue;\n\t\t\tif(!have[xx][yy]) {\n\t\t\t\thave[xx][yy]=1;\n\t\t\t\tz[xx][yy]=s+1;\n\t\t\t\tq.push((edge2){s+1,xx,yy});\n\t\t\t}\n\t\t\tfor(int j=1; j<=4; j++) {\n\t\t\t\tint xr=xx+tx[j],yr=yy+ty[j];\n\t\t\t\tif(xr<1||xr>n||yr<1||yr>n||a[xr][yr]||have[xr][yr]) continue;\n\t\t\t\thave[xr][yr]=1;\n\t\t\t\tz[xr][yr]=s+1;\n\t\t\t\tq.push((edge2){s+1,xr,yr});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tn=read(),xa=read(),ya=read(),xb=read(),yb=read();\n\tfor(int i=1; i<=n; i++) {\n\t\tfor(int j=1; j<=n; j++) a[i][j]=getchar()-'0';\n\t\tgetchar();\n\t}\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++) \n\t\t\tm[i][j]=INF,z[i][j]=INF;\n\tm[xb][yb]=0;\n\tbfs1(xb,yb);\n\t\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++) \n\t\t\thave[i][j]=0;\n\tz[xa][ya]=0;\n\tbfs2(xa,ya);\n\t//debug1();\n\t//debug2();\n\tint ans=INF;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++) {\n\t\t\tans=min(ans,max(m[i][j],z[i][j]));\n\t\t}\n\tcout<<ans<<endl;\n}\n```\n\n# 小结\n\n此题码量较大，细节较多。调试较困难，一遍AC较难。\n\n但是是一道练习广搜的好题。","tags":["题解","图论","bfs","搜索"],"categories":["OI","题解"]},{"title":"浅析tarjan算法","path":"/article/basic-tarjan/","content":"几乎网上所有有关tarjan算法的介绍都会有下面这一段话：\n\nTarjan老爷子一生发明了许多算法下到 NOIP 上到 CTSC 难度的都有。\n\n(Tarjan 算法，并查集，Splay 树，Tarjan 离线求 lca)\n\n我们这里要介绍的是图论中的 Tarjan 算法，用来处理各种连通性相关的问题。\n\n<!--more-->\n\n## 有向图连通性\n\n### 一些定义\n\n1. 给定有向图 $G=(V,E)$ ，若存在 $r\\in V$ ，满足从 $r$ 出发能到达 $V$ 中的所有点，则称 $G$ 为一个“流图”，其中 $r$ 称为流图的源点。\n\n2. 在流图的深度优先遍历中，按照每个节点第一次被访问的顺序，以此给予$N$个节点 $1-n$ 的整数标记，该标记就称为 $dfn[x]$ ，中文名为“时间戳”。\n\n3. 给定一张有向图，若对于图中任意两个节点 $x$ , $y$ ，既存在 $x$ 到 $y$ 的路径，又存在从 $y$ 到 $x$ 的路径，则称该有向图强连通。\n\n4. 强连通分量在有向图G中，如果两个顶点 $x$ , $y$ 间 $(x>y)$ 有一条从 $x$ 到 $y$ 的有向路径，同时还有一条从 $x$ 到 $y$ 的有向路径。\n\n如下图：\n![](https://www.micdz.cn/img/2019-10-31-1.png)\n\n此图是一个非常经典的例图\n\n在图中， $\\{1,2,3\\}$ 在同一个强连通分量， $\\{4\\}$ 和 $\\{5\\}$ 单独两个强连通分量。\n\n6. 在强连通图中各种类型的边，定义边 $(x,y)$ 满足以下条件。\n\n>树枝边，指搜索树中的边，即 $x$ 是 $y$ 的父节点\n>\n>前向边， $x$ 是 $y$ 的祖先节点\n>\n>后向边， $y$ 是 $x$ 的祖先节点\n>\n>横叉边，除了以上条件的所有边，这种边一定满足 $dfn[y]<dfn[x]$ \n\n### Tarjan求强连通分量\n\n#### 核心思路\n\n##### 初始化\n\n在刚刚遍历到某一个节点时初始化 $low$ 和 $dfn$ 。\n\n而为什么此时的 $low$ 可以等于 $dfn$ ，请自行证明。\n\n对于上面的那一张图，转化成一个流图即为\n\n![](https://www.micdz.cn/img/2019-10-31-2.png)\n\n##### 利用栈存储\n\n每次到达一个节点时，就将该节点压入栈中，并且记录下该节点已入栈。\n\n当某一节点的出边的 $low==dfn$ 时，就将栈顶推出直至某一节点与栈顶相同为止，此时推出的所有节点均为同一强连通分量的节点，并且没有其他节点与此强连通。\n\n#### 完整代码\n\n```cpp\nvoid tarjan(int x) {\n\tdfn[x]=low[x]=++num;\n\t_stack[++top]=x;\n\tins[x]=1;\n\tfor(int i=head[x]; i; i=_next[i]) {\n\t\tint v=to[i];\n\t\tif(!dfn[v]) {\n\t\t\ttarjan(v);\n\t\t\tlow[x]=min(low[x],low[v]);\n\t\t}\n\t\telse if(ins[v]) low[x]=min(low[x],low[v]);\n\t}\n\tif(dfn[x]==low[x]) {\n\t\tcntt++;\n\t\tint y;\n\t\tdo{\n\t\t\ty=_stack[top--];\n\t\t\tins[y]=0;\n\t\t\tc[y]=cntt;\n\t\t\tscc[cntt].push_back(y);\n\t\t}while(x!=y);\n\t}\n}\n```\n\n在上述的代码中`scc`存储的的是新的有向无环图。`c`数组存储的是强连通分量。\n\n我们可以通过下面的这段代码建出新的有向无环图。\n\n\n```cpp\nvoid addedge_c(int u,int v) {\n\tcnt++;\n\tto_c[cnt]=v;\n\t_next_c[cnt]=head_c[u];\n\thead_c[u]=cnt;\n}\n//在main()中\nfor(int x=1; x<=n; x++)\n\tfor(int i=head[x]; i; i=_next[i]) {\n\t\tint y=to[i];\n\t\tif(c[x]==c[y]) continue;\n\t\tadd_c(c[x],c[y]);\n\t}\n```\n\n#### 对应例题\n\n>Network of Schools[POJ1236](http://poj.org/problem?id=1236)\n>\n>Popular Cows[POJ2186](http://poj.org/problem?id=2186)\n>\n>消息扩散[LG2002](https://www.luogu.org/problemnew/show/P2002)\n\n## 无向图连通性\n\n### 一些定义\n\n给定无向连通图 $G=(V,E)$：\n\n1. 若对于 $x\\in V$ ，从图中删除 $x$ 与其相邻的所有的边，使 $G$ 分裂为两个或两个以上的子图，则称 $x$ 为 $G$ 的割点。\n\n2. 若对于 $e\\in E$ ，从图中删除 $e$ ，使 $G$ 分裂为两个或两个以上的子图，则称 $e$ 为 $G$ 的割边或桥。\n\n3. 与有向图相似的 $dfn$ 与 $low$ 。\n\n### Tarjan求割点与桥\n\n#### 核心思路\n\n##### 割边判定法则\n\n如果边 $(x,y)$ 是一个桥，当且仅当满足：\n\n$$\n\\begin{aligned}\ndfn_x<low_y\n\\end{aligned}\n$$\n\n有了上述的判定法则，就可以很轻松地在有向图的基础上该写出割边的代码。\n\n特别的，我们可以引用一个`bridge`来存储割边的左右节点。\n\n###### 完整代码\n\n```cpp\nvoid tarjan(int x,int in_edge) {\n\tdfn[x]=low[x]=++num;\n\tfor(int i=head[x]; i; i=_next[i]) {\n\t\tint y=to[i];\n\t\tif(!dfn[y]) {\n\t\t\ttarjan(y,i);\n\t\t\tlow[x]=min(low[x],low[y]);//与有向图相同的操作\n\t\t\t\n\t\t\tif(low[y]>dfn[x]) bridge[i]=bridge[i^1]=1;//判定为割边\n\t\t\telse if(i!=(in_bridge^1)) low[x]=min(low[x],dfn[y]);\n\t\t}\n\t}\n}\n```\n###### 对应例题\n\n>暂无\n\n##### 割点判定法则\n\n当 $x$ 不是搜索树的根节点，如果 $x$ 是割点当且仅当搜索树上存在 $x$ 的一个子节点 $y$ 。满足：\n\n$$\n\\begin{aligned}\ndfn_x\\leq low_y\n\\end{aligned}\n$$\n\n###### 完整代码\n```cpp\nvoid tarjan(int x) {\n\tdfn[x]=low[x]=++num;\n\tint flag=0;\n\tfor(int i=head[x]; i; i=_next[i]) {\n\t\tint y=to[i];\n\t\tif(!dfn[y]) {\n\t\t\ttarjan(y);\n\t\t\tlow[x]=min(low[x],low[y]);\n\t\t\tif(low[y]>=dfn[x]) {\n\t\t\t\tflag++;\n\t\t\t\tif(x!=root||flag>1) cut[x]=1;\n\t\t\t}\n\t\t}\n\t\telse low[x]=min(low[x],dfn[y]);\n\t}\n}\n```\n###### 对应例题\n\n>【模板】割点（割顶）[LG3388](https://www.luogu.org/problemnew/show/P3388)","tags":["图论","随笔","强连通分量"],"categories":["OI"]},{"title":"【CF1066F】Yet another 2D Walking 题解","path":"/article/CF1066F-solution/","content":"此题可以用动态规划求解。\n\n<!--more-->\n\n## 题目描述\n\n题目链接[here](http://codeforces.com/problemset/problem/1066/F)\n\n小M在平面直角坐标系上的$(0,0)$点。他每次可以向上下左右走一格。\n如果两个点满足$\\max(X_i,Y_i)\\leq \\max(X_j,Y_j)$，那么从$i$到$j$就有一条有向路径。\n定义两点的距离为曼哈顿距离。\n最小化路径长度。\n\n![](https://i.loli.net/2018/11/08/5be39d473e10f.png)\n\n## 核心思路\n\n我们将所有的点按照$\\max(x,y)$分层，就如上图所示。可以证明只有到达某一层并且将该层完全走完再走下一层是最优的。\n\n定义$dp_{i,0}$表示到达第$i$条边的左端点的最小路径，$dp_{i,1}$表示到达第$i$条边的右端点的最小路径。\n\n转移方程显然。\n\n$$\n\\begin{aligned}\ndp_{i,1}&=\\min(dp_{i-1,1}+dist(right_{i-1},left_i),dp_{i-1,0}+dist(left_{i-1},left_i))+dis_{i-1};\\\\\ndp_{i,0}&=\\min(dp_{i-1,1}+dist(right_{i-1},right_i),dp_{i-1,0}+dist(left_{i-1},right_i))+dis_{i-1};\\\\\n\\end{aligned}\n$$\n\n在方程中$dis$表示某一层走完的长度。\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define  REP(i,e,s) for(register int i=e; i<=s; i++)\n#define DREP(i,e,s) for(register int i=e; i>=s; i--)\n\n#define MAXN 200000+10\n\nll read() {\n    ll x=0,f=1,ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nstruct edge{\n    ll x,y,id;\n}a[MAXN];\n\nbool cmp(edge a,edge b) {\n    ll as=max(a.x,a.y),bs=max(b.x,b.y);\n    if(as==bs) {if(a.x==b.x) return a.y>=b.y;else return a.x<b.x;} \n    return as<bs;\n}\n\nll dist(ll u,ll v) {\n    return abs(a[u].x-a[v].x)+abs(a[u].y-a[v].y);\n}\n\nll _right[MAXN],_left[MAXN],dis[MAXN];\nll dp[MAXN][2];\n\nint main() {\n\n    ll n=read();\n    \n    REP(i,1,n) {\n        a[i].x=read();\n        a[i].y=read();\n        a[i].id=max(a[i].x,a[i].y);\n    }\n\n    sort(a+1,a+1+n,cmp);\n    \n    ll now=-1,cnt=0;\n\n    ll ans=0;\n    \n\n    REP(i,1,n) {\n        if(a[i].id!=a[i-1].id) {\n            _right[cnt]=i-1;\n            dis[cnt]=dist(_right[cnt],_left[cnt]);\n            _left[++cnt]=i;\n        } \n    }\n    \n    _right[cnt]=n;\n    dis[cnt]=dist(_right[cnt],_left[cnt]);\n\n    REP(i,1,cnt) {\n        dp[i][1]=min(dp[i-1][1]+dist(_right[i-1],_left[i]),dp[i-1][0]+dist(_left[i-1],_left[i]))+dis[i-1];\n        dp[i][0]=min(dp[i-1][1]+dist(_right[i-1],_right[i]),dp[i-1][0]+dist(_left[i-1],_right[i]))+dis[i-1];\n    }\n\n    cout<<min(dp[cnt][1],dp[cnt][0])+dis[cnt]<<endl;\n\n    return 0;\n}\n//考场代码略丑\n```","tags":["题解","图论","动态规划"],"categories":["OI","题解"]},{"title":"期望与微积分","path":"/article/expectation-calculus/","content":"以NOIp2018初赛第7题为例：\n\n```\n 7. 在一条长度为1 的线段上随机取两个点，则以这两个点为端点的线段的期望长度是（ ）。\nA. 1 / 2\nB. 1 / 3\nC. 2 / 3\nD. 3 / 5\n```\n\n<!--more-->\n\n首先您需要理解**期望**是什么。\n\n假设您买彩票，不中奖概率为$50$%，得到1元的概率为$30$%，得到$50$%元的概率为$15$%，得到$1000$元的概率为$5$%，那么记 **买彩票获得的奖金** 这个事件为$A$，那么获得的奖金期望值记做$E(A)$\n\n那么$E(A)=0*0.5+1*0.3+50*0.15+1000*0.05=57.8$ 如您见，就是每一种可能乘上对应的概率之和\n\n我们可以来看这道题了。\n\n这道题要用的一点微积分的思想。**把这个线段平均分成$n$段，然后枚举左右端点，算出所有可能的值，再求平均值即可**！\n\n可能广大初中生并不知道怎么算，我来写一下过程吧\n\n下面先求总长度\n\n$\\sum_{i=0}^n \\sum_{j=0}^n \\dfrac{\\lvert i-j \\rvert}{n}$    考虑把第二层求和拆开\n\n$=\\sum_{i=0}^n (\\dfrac{\\lvert i-0 \\rvert}{n}+\\dfrac{\\lvert i-1 \\rvert}{n}+...+\\dfrac{\\lvert i-n \\rvert}{n})$ 分母相同，分子写到一起去\n\n$=\\sum_{i=0}^n (\\dfrac{\\lvert i-0 \\rvert+\\lvert i-1\\rvert+\\lvert i-2 \\rvert+...+|i-n|}{n})$ 陷入瓶颈\n\n如果右边这一坨东西是个等差数列就好了，但事实上不是，but……我们可以找一点规律\n\n我们以$n=4$为例子吧\n\n|$\\frac{|i-j|}{4}$  | 0 | 1 | 2 | 3 |4|\n| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |\n| 0 | $0$ | $\\dfrac{1}{4}$ | $\\dfrac{2}{4}$ | $\\dfrac{3}{4}$ | $\\dfrac{4}{4}$ |\n| 1 | $\\dfrac{1}{4}$ | $0$ | $\\dfrac{1}{4}$ |$\\dfrac{2}{4}$  | $\\dfrac{3}{4}$ |\n|  2| $\\dfrac{2}{4}$ | $\\dfrac{1}{4}$ | $0$ | $\\dfrac{1}{4}$ | $\\dfrac{2}{4}$ |\n|  3| $\\dfrac{3}{4}$ | $\\dfrac{2}{4}$ | $\\dfrac{1}{4}$ | $0$ | $\\dfrac{1}{4}$ |\n| 4 | $\\dfrac{4}{4}$ | $\\dfrac{3}{4}$ | $\\dfrac{2}{4}$ | $\\dfrac{1}{4}$ | $0$ |\n\n规律十分明显，每一行都** 以$0$为分界线拆成两个等差数列 **！于是我们可以愉快地往下面写了！\n\n$=\\sum_{i=0}^n (\\dfrac{(0+i)*(i+1)+(0+n-i)*(n-i+1)}{2n})$ 然后愉快的化简！\n\n$=\\sum_{i=0}^n (\\dfrac{i^2+i+n^2-ni+1-ni+i^2-i}{2n})$ 合并同类项\n\n$=\\sum_{i=0}^n (\\dfrac{2i^2-2ni+n^2+1}{2n})$ 分离常数\n\n$=\\sum_{i=0}^n (\\dfrac{2i^2}{2n}-\\dfrac{2ni}{2n}+\\dfrac{n^2+n}{2n})$\n\n$=\\sum_{i=0}^n (\\dfrac{i^2}{n}-i+\\dfrac{n+1}{2})$ 然后可以愉快的拆开 $\\sum$ 了！\n\n$=\\dfrac{0^2+1^2+2^2+3^2...+n^2}{n}-(0+1+2...+n)+\\dfrac{(n+1)(n+1)}{2}$\n\n$=\\dfrac{0^2+1^2+2^2+3^2...+n^2}{n}-\\dfrac{(0+n)*(n+1)}{2}+\\dfrac{(n+1)^2}{2}$ 陷入瓶颈\n\n我们被卡住关键在于$S_n=0^2+1^2+2^2+3^2...+n^2$的计算（高中不必看这一段），那么我们不如来推一推公式吧？\n\n怎么推公式？\n\n### 玄学技巧-差分\n\n把$n\\in[0,5]$的$S_n$值列成一排\n\n$0~~~~~~~~1~~~~~~~~5~~~~~~~~14~~~~~~~~30~~~~~~~~55$\t$~~~~~~~~$然后差分\n\n$~~~~1~~~~~~~~4~~~~~~~~9~~~~~~~~16~~~~~~~~25$ $~~~~~~~~~~~~~~~~$继续\n\n$~~~~~~~~3~~~~~~~~5~~~~~~~~7~~~~~~~~9$ $~~~~~~~~~~~~~~~~~~~~~~~~~~$继续\n\n$~~~~~~~~~~~~2~~~~~~~~2~~~~~~~~2$ $~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$所有的数字竟然相等了！\n\n这时候我们一共做了$3$次差分操作，那么我们可以得知$S_n$公式是一个$3$次整式！\n\n~~玄学吧~~\n\n此时设$S=ax^3+bx^2+cx+d$\n\n$\\begin{cases} a+b+c+d=1 \\\\ 8a+4b+2c+d=5 \\\\ 27a+9b+3c+d=14 \\\\ 64a+16b+4c+d=30\\end{cases}$\n\n然后解方程\n\n$\\begin{cases} 7a+3b+c=4 \\\\ 19a+5b+c=9 \\\\ 37a+7b+c=16 \\end{cases}$\n\n$\\begin{cases} 12a+2b=5 \\\\ 18a+2b=7 \\end{cases}$\n\n$6a=2~~~~~~~\\therefore a=\\dfrac{1}{3}$\n\n$\\therefore b=\\dfrac{1}{2},c=\\dfrac{1}{6},d=0$\n\n$\\therefore S_n=\\dfrac{1}{3}n^3+\\dfrac{1}{2}n^2+\\dfrac{1}{6}n$ 化简一下\n\n$=\\dfrac{1}{6}n(2n^2+3n+1)$  十字相乘分解\n\n$=\\dfrac{1}{6}n(n+1)(2n+1)$\n\n然后就可以愉快的往下面写了\n\n$\\dfrac{0^2+1^2+2^2+3^2...+n^2}{n}-\\dfrac{(0+n)*(n+1)}{2}+\\dfrac{(n+1)^2}{2}$\n\n$=\\dfrac{\\dfrac{1}{6}n(n+1)(2n+1)}{n}-\\dfrac{(0+n)*(n+1)}{2}+\\dfrac{(n+1)^2}{2}$\n\n$=\\dfrac{1}{6}(n+1)(2n+1)-\\dfrac{n^2+n}{2}+\\dfrac{n^2+2n+1}{2}$\n\n$=\\dfrac{(n+1)(2n+1)}{6}+\\dfrac{n+1}{2}$\n\n$=\\dfrac{2n^2+3n+1}{6}+\\dfrac{3n+3}{6}$\n\n$=\\dfrac{2n^2+6n+4}{6}$\n\n$=\\dfrac{n^2+3n+2}{3}$\n\n$=\\dfrac{(n+1)(n+2)}{3}$\n\n那么总长度算了出来，再除以情况数$(n+1)^2$\n\n$Ans=\\dfrac{(n+1)(n+2)}{3(n+1)^2}$\n\n$=\\dfrac{n+2}{3n+3}​$\n\n$\\lim_{\\Delta x\\to \\infty}Ans=\\dfrac{1}{3}$\n\n至此，我们做出了这道题，答案选$B$\n\n*By Imakf*\n\n[https://www.luogu.org/blog/Imakf/noip-ti-gao-chu-sai-t7-xie-xi](https://www.luogu.org/blog/Imakf/noip-ti-gao-chu-sai-t7-xie-xi)","tags":["期望","微积分"],"categories":["OI"]},{"title":"中东及非洲南部水资源现状及解决措施","path":"/article/sf-ea-water-resources/","content":"中东和非洲所面临的水资源情况不容乐观。对于这两个区域的水资源讨论是十分有意义的。","tags":["论文"],"categories":["Others"]},{"title":"线段树","path":"/article/segment-tree/","content":"线段树是一种基于分治思想的二叉树结构。用于在区间上进行信息统计。于树状数组相比，线段树更为通用。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n## 实现目标\n\n1. 区间修改\n2. 区间查询\n3. 可以基于所有具有可互逆运算法则的运算。\n\n## 核心思路\n\n### 线段树的建立\n\n![](https://www.micdz.cn/img/2019-10-02-13.png)\n\n在[基础数据结构](https://www.micdz.cn/article/basic-ds/)一文中，我有提到线段树是如上的结构。更为准确地描述，应该是一个二叉树。上图也可以很好地表现这一点。\n\n那么就可以使用存储二叉树的方式来存储线段树。\n\n```cpp\nstruct SegmentTree{\n    int l,r;\n    int dat;\n} t[MAXN<<2];\n```\n\n也可以使用链式前向星或是邻接表。但是因为已经是二叉树的结构就没有必要了。\n\n这里我们以查找最大值为例。其实任何有逆运算及结合律的操作都可以用线段树维护，这是因为线段树在合并时需要从左子树及右子树统计答案需要满足结合律，如果没有逆运算则无法更新答案。\n\n每一个节点代表的区间是从根节点的整个长度出发依次分半直至不能再分为止。因此线段树的每一个节点都表示一个区间的最大值，特别的每一个叶子节点就表示一个数（其实一个数也可以是一个区间）。\n\n```cpp\nvoid build(int p,int l,int r) {\n    t[p].l=l,t[p].r=r;\n    if(l==r) {\n        t[p].dat=a[l];\n        return ;\n    }//叶子节点的情况\n    int mid=(l+r)/2;\n    build(p*2,l,mid);//左子树\n    build(p*2+1,mid+1,r);//右子树\n    t[p].dat=max(t[p*2].dat,t[p*2+1].dat);//更新答案\n}\n```\n\n\n\n### 单点修改\n\n与建树十分相似。但是我们只需要找到$x$的位置即可。\n\n```cpp\nvoid change(int p,int x,int v) {\n    if(t[p].l==t[p].r) {\n        t[p].dat=v;\n        return ;\n    }//找到叶节点并修改\n\tint mid=(t[p].l+t[p].r)/2;\n    if(x<=mid) change(p*2,x,v);\n    else change(p*2+1,x,v);//在左区间还是右区间\n    t[p].dat=max(t[p*2].dat,t[p*2+1].dat);//更新答案\n}\n```\n\n调用入口为，将第$x$个节点更改为$v$。\n\n```cpp\nchange(1,x,v);\n```\n\n### 区间查询\n\n区间查询分为以下三种情况：\n\n1. 所查找的子区间将当前节点区间完全包含，直接得出答案\n2. 所查找的子区间与当前节点的左子节点有重叠\n3. 所查找的子区间与当前节点的右子节点有重叠\n\n对应三种情况我们可以用三个`if`语句解决。\n\n```cpp\nint ask(int p,int l,int r) {\n    int mid=(t[p].l+t[p].r)/2;\n    int val=-INF;\n    if(l<=t[p].l&&r>=t[p].r) return t[p].dat;\n\tif(l<=mid) val=max(val,ask(p*2,l,r));\n    if(r>mid) val=max(val,ask(p*2+1,l,r));\n    //切记此处不能写为else if\n}\n```\n\n调用入口为，返回值为答案。\n\n```cpp\nask(1,l,r);\n```\n\n考虑查询操作的时间复杂度：\n\n查询操作会将区间$[l.r]$在线段树上分为$\\log n$个节点。但是因为存在左子区间或右子区间有重叠的情况有可能会向下查找两次。但好在这种情况最多出现一次。\n\n因此查询操作的复杂度为$\\Theta(2\\log n)=\\Theta(\\log n)$。\n\n\n\n有关线段树的更多操作，请参考[线段树进阶](https://www.micdz.cn/article/segment-tree-pro/)","tags":["随笔","笔记","数据结构"],"categories":["OI"]},{"title":"【HDU1520】Anniversary party s题解","path":"/article/HDU1520-solution/","content":"题目链接[here](http://acm.hdu.edu.cn/showproblem.php?pid=1520)，是目前公认的树形dp的入门模板题。\n\n思路还是比较简单的。\n\n<!--more-->\n\n## 题目大意\n\n由若干个人在举行派对，给定你若干对从属关系，要求具有从属关系的两人不能同时参加派对，每个人都有一个权值让你求出权值的最大是多少。\n\n## 核心思路\n\n### 状态设计\n\n因为对于每一个节点都会有两种状态分别为选择和不选择，记$f[i][1]$表示以$i$为根结点的子树当选择了$i$的最大权值和，而$f[i][0]$表示以$i$为根结点的子树当没有选择$i$的最大权值和。\n\n对于任意叶子结点$k$，$f[k][1]$即为该节点的权值，而$f[k][0]$即为0。\n\n### 状态转移方程\n\n得到了上述的关系，我们可以发现，假设在一对从属关系中，“属点”是$u$，“从点”是$v$（即$u$是$v$的领导），将会有一条边从$u$指向$v$，并且当$u$被选择时，$v$就不能被选择，而$u$不被选择时$v$可以不被选择，也可以不选择。\n\n因此方程如下：\n$$\n\\begin{aligned}\nf[u][1]&=\\sum\\max(f[v][0],f[v][1])\\\\\nf[u][0]&=\\sum f[v][0]\\\\\n\\end{aligned}\n$$\n所以只需要dfs从根节点向叶子结点遍历，在回溯时修改即可。\n\n### dfs遍历\n```cpp\nvoid dfs(int u) {\n    int fa=0,tu=a[u];\n    for(int i=head[u]; i; i=_next[i]) {\n        int v=to[i];\n        dfs(v);\n\n       \t//切记是在回溯的时候修改\n    }\n    dp[u][0]=fa,dp[u][1]=tu;\n}\n```\n\n我这里使用的是链式前向星存图，当然也可以使用邻接表。邻接矩阵有可能会超时。\n\ndfs遍历的过程应该很好理解，在回溯的时候才可以更新答案。入口是`dfs(root)`。\n\n### 寻找根节点\n\n根据上面所说的需要寻找根节点，根据根节点的定义，入度为0的节点即为根节点。\n\n在存图的时候加入一个数组记录下每个节点的入度即可。\n\n值得注意的是有些题目会有多棵树，而有些题会明确指出只有一棵树，因此使用下面的代码最为保险。\n\n```cpp\nfor(int i=1; i<=n; i++) {\n\tif(!root[i]) {\n\t\tdfs(i);\n        //统计答案\n\t}\n}\n```\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN 6000+15\n#define MAXM 6000+15\nint read() {\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nint head[MAXN],to[MAXM],a[MAXM],_next[MAXN],root[MAXN],cnt;\n\nvoid addedge(int u,int v) {\n    cnt++;\n    to[cnt]=v;\n    _next[cnt]=head[u];\n    head[u]=cnt;\n}\n\nint dp[MAXN][2];\n\nvoid init() {\n    memset(root,0,sizeof(root));\n    memset(head,0,sizeof(head));\n    memset(dp,0,sizeof(dp));\n    cnt=0;\n}\n\nvoid dfs(int u) {\n    int fa=0,tu=a[u];\n    for(int i=head[u]; i; i=_next[i]) {\n        int v=to[i];\n        dfs(v);\n\n        fa=max(fa,fa+max(dp[v][0],dp[v][1]));\n        tu=max(tu,tu+dp[v][0]);\n    }\n    dp[u][0]=fa,dp[u][1]=tu;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\",&n)!=EOF) {\n        init();\n        for(int i=1; i<=n; i++) a[i]=read();    \n        int u,v;\n        while(scanf(\"%d%d\",&u,&v)==2&&u+v) {\n            addedge(v,u);\n            root[u]=1;\n        }\n        int ans=0;\n        for(int i=1; i<=n; i++) {\n            if(!root[i]) {\n                dfs(i);\n                ans+=max(dp[i][0],dp[i][1]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```","tags":["题解","动态规划","树形dp","dfs"],"categories":["OI","题解"]},{"title":"中秋节欢乐赛题解","path":"/article/zqj-solutions/","content":"比赛地址分别为：\n\n[中秋节欢乐赛DIV1](https://www.luogu.org/contest/show?tid=10826)\n\n[中秋节欢乐赛DIV2](https://www.luogu.org/contest/show?tid=10827)\n\n<!--more-->\n\n**所有比赛标程、数据都放置在了[Github ](https://github.com/MicDZ/Code/tree/master/contest/ZQJ)**\n\n## DIV1\n\n### 作业计数\n\n小凡一门学课的作业不做怒气总值增加$b$，那么$a$门作业不做怒气值即为$a\\times b$，答案为对$m$取膜的结果。\n\n数据范围为$1\\leq a,b,m\\leq 10^{18}$，此时你发现$a\\times b$会直接炸int。所以需要一些玄学的优化。\n\n~~Ps：很抱歉，这题没给部分分。~~\n\n#### 方法一\n\n使用自带高精度的python解决问题\n\n```cpp\na=int(input())\nb=int(input())\nm=int(input())\nprint(a*b%m)\n```\n\n#### 方法二\n\n使用高精度的乘法和魔法\n\n在这里推荐各位到[yali_hzy](https://blog.csdn.net/yali_hzy/article/details/81430514)的博客看看。我就不写了。。\n\n高精取膜的方法为：\n$$\n\\begin{aligned}\na-b\\times \\lfloor\\frac{a}{b}\\rfloor\n\\end{aligned}\n$$\n\n\n#### 方法三\n\n用快速乘的方法。\n\n原理类似于卡速米。\n\n```cpp\n#define ll long long\nll mul(ll a,ll b,ll m) {\n    ll ans=0;\n    while(b) {\n        if(b&1) b=(b+a)%m;\n        a=(a+a)%m;\n        b>>=1;\n    }\n    return ans;\n}\n```\n\n复杂度为$\\Theta(\\log b)$\n\n### 月饼采购\n\n这可以算是一个非常经典的题目了，紫书、蓝书上都有。\n\n和作业计数类似的，膜术可以这么算$a-b\\times \\lfloor\\frac{a}{b}\\rfloor$\n\n那么就可以得到以下推导\n$$\n\\begin{aligned}\nans&=\\sum^{n}_{i=1}k-i\\times\\lfloor\\frac{a}{b}\\rfloor\\\\\n&=n\\times k-\\sum^{n}_{i=1}i\\times\\lfloor\\frac{k}{i}\\rfloor\n\\end{aligned}\n$$\n然后可以从$\\lfloor\\frac{k}{i}\\rfloor$出发，得到答案。\n\n复杂度为$\\Theta{\\sqrt{k}}$。\n\n### 分配月饼\n\n$$\n\\begin{aligned}\nC^m_n&=\\frac{n!}{m!(n-m)!}\\\\\n&=\\frac{\\prod^{n}_{i=n-m}}{\\prod^{m}_{i=1}}\n\\end{aligned}\n$$\n\n得到了以上的结论后即可做到在$\\Theta(2\\times m)$，的复杂度内求解。\n\n而原题的$n\\leq2\\times10^5$，因此可以通过。\n\n值得一提的是，在做除法意义下的膜法时，需要用到逆元。\n\n## DIV2\n\n~~Ps：早知道就用OI赛制了，这样Imakf就不能AK了。~~\n\n### 价格统计\n\n直接依照题意模拟即可，把细节把握好。\n\n### 月光计算\n\n这是一道非常简单的数学题。\n\n$n$行，$n-1$列的星星加上一行不少于1的星星肯定是要大于$(n-1)^2$颗星星的。\n\n\n$$\n\\left\\{\n\\begin{aligned}\ny1&=n(n-1)+1=n^2-n+1\\\\\ny2&=(n-1)^2=n^2-2n+1\\\\\n\\end{aligned}\n\\right.\n$$\n所以可以得出$y1>y2$。答案即为$n^2$，不过记得开long long\n\n### 月饼管理\n\n提示中的数据结构是前缀和。\n\n您可以参考我的[这篇](https://www.micdz.cn/article/basic-ds/#%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86)文章。\n\n这里就不多累赘了。","tags":["题解"],"categories":["OI","题解"]},{"title":"树状数组基础","path":"/article/basic-bit/","content":"树状数组是一个非常高效的支持区间修改单点查询的数据结构。\n\n<!--more-->\n\n## 引入\n\n线段树和树状数组，是两个十分相似的数据结构。他们能使对一个区间的数修改以及查询的速度提升许多。两个结构本质相同，各有优缺点，今天我们来从单点修改，单点查询，区间修改，区间查询进行了解。\n\n## 内容及存储方式\n\n### 树的形式\n\n![](https://www.micdz.cn/img/2019-10-02-12.png)\n\n\n\n$A$数组是原数组，$C$数组是树状数组。\n\n$C$树状数组中的每一个元素都是其所有叶节点的总和。特别的，叶子结点就是对应的原数组。\n### 数的规律\n\n```cpp\nc1=a1;\nc2=a1+a2;\nc3=a3;\nc4=a1+a2+a3+a4;\n```\n\n根据树状数组的定义，可以得到如上。没有必要纠结为什么是这样，只需要知道这样有什么用，因为这个定义也是人为定义出来的。\n\n那么，这里的规律究竟是怎么样的？\n\n将上述表格中的下标转化为二进制后即可发现规律。\n\n```cpp\nc0001=a0001\nc0010=a0001+a0010\nc0011=a0011\nc0100=a0001+a0010+a0011+a0100\n```\n\n从左向右数，$C$数组下标有$n$个0就有$2^n$个元素。\n\n\n\n## 核心代码\n\n### 单点更新\n\n```cpp\nvoid change(int x,int v) {\n    while(x<=n) {\n        t[x]+=v;\n        x+=x&(-x);\n    }\n}\n```\n\n利用此操作，将第$x$个元素增加v。\n\n### 前缀查询\n\n```cpp\nint ask(int x) {\n    int ans=0;\n    while(x) {\n        ans+=t[x];\n        x-=x&(-x);\n    }\n    return ans;\n}\n```\n\n得到的结果是前$x$个元素的和。\n\n### 区间修改\n\n#### 差分存储\n\n我们将原数组的差分数组插入到树状数组中。\n\n例如 $[2,6,9,1,3,4]$ 的差分数组为 $[2,4,3,-8,2,1]$ ，可以看出，差分数组 $b_i=a_i-a_{i-1}$ 。\n\n这样的好处是查找某个元素可以直接树状数组求前缀和。\n\n#### 差分修改\n\n如果要将从 $[l,r]$ 的所有元素加上 $x$ ，只需要将 $b_l+x$ 和 $b_{r+1}-x$ 。在求前缀和时，只会对 $[l,r]$ 有影响。而对后面和前面的数没有影响。\n\n为了节省空间，可以如下进行插入：\n\n```cpp\nfor(int i=1; i<=n; i++) {\n    a=read();\n    change(i,a-b);\n    b=a;\n}\n```\n\n\n\n## 完整代码\n\n[ LG3368 【模板】树状数组 2](https://www.luogu.org/problemnew/show/P3368)\n\n```cpp\n#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n#define MAXN 500000+10\n#define ll long long\n\nint read() {\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nint n,m;\n\nint a,b,t[MAXN];\n\nvoid change(int x,int v) {\n    while(x<=n) {\n        t[x]+=v;\n        x+=x&(-x);\n    }\n}\n\nint ask(int x) {\n    int ans=0;\n    while(x) {\n        ans+=t[x];\n        x-=x&(-x);\n    }\n    return ans;\n}\n\nint main() {\n    n=read(),m=read();\n    for(int i=1; i<=n; i++) {\n        a=read();\n        change(i,a-b);\n        b=a;\n    }\n    for(int i=1; i<=m; i++) {\n        int pd=read();\n        if(pd==1) {\n            int x=read(),y=read(),k=read();\n            change(x,k);\n            change(y+1,-k);\n        }\n        else {\n            int x=read();\n            printf(\"%d\\n\",ask(x));\n        }\n    }\n}\n```","tags":["随笔","笔记","数据结构"],"categories":["OI"]},{"title":"苹果系统更新后无法使用gcc编译器解决方案","path":"/article/gcc-compiler-problem/","content":"谨以此篇文章，献给一整个晚上的艰难探索。\n\n<!--more-->\n\n今晚我安装了macOS Mojave操作系统，本是一件非常激动的事情，但是突然却变得十分悲伤。\n\n我的g++编译器崩溃了！\n\n经过了一晚上的艰难探索。为后来者提供解决方案。\n\n出现这种情况的原因是，苹果公司会在系统更新的时候自动清除usr目录下的一些没有用的东西。其中就有我们的include文件。当我们使用g++进行编译的时候，会从`/usr/include/`目录寻找头文件，而因为系统更新会发现找不到一堆头文件。\n\n此时你需要到你的别的电脑上把头文件们拷过来。（或许有更好的方法）","tags":["随笔"],"categories":["Solutions"]},{"title":"【LG2893】修路 题解","path":"/article/LG2893-solution/","content":"在最优解的排行榜中看到了一种神奇的方法。\n\n**声明**：此题解的思路来源于洛谷代码公开计划。\n\n<!--more-->\n\n## 核心思路\n\n这是一个DP的裸题，然而。。总有一些神人用神奇的方法解决了问题。\n\n首先建一个大根堆和一个小根堆，将每一个的路面高度push进去，这里可以用STL的优先队列。\n\n用大根堆模拟递增的情况，小根堆模拟递减的情况。\n\n接下来利用一种类似于贪心的方法解决这道题。\n\n因为这里有一个结论：修改后的道路高度在原来的道路的高度中。\n\n那么面对每一次插入的高度，如果它的高度要比小根堆中已插入的最小的高度要大的话，那么就可以把它休整到和最小的同样高度。同理，反之是相反的操作。\n\n这样尽管不能在每次操作的时候确定当前路段的花费，但是总和确是确定的。\n\n给张图理解下：\n\n![](https://i.loli.net/2018/08/19/5b7930629f335.png)\n\n\n## 完整代码\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\npriority_queue<int, vector<int>, greater<int> > q;\npriority_queue<int> p;\nint ans1,ans2;\n\nint main(){\n    int n=read();\n    for(int i=1; i<=n; i++) {\n        cin>>x;\n        p.push(x);\n        q.push(x);\n        if(q.top()<x) {\n            ans1+=abs(q.top()-x);//这里要加一个abs\n\t\t\tq.pop();\n\t\t\tq.push(x);\n        }  \n\t\tif(p.top()>x) {\n            ans2+=p.top()-x;\n\t\t\tp.pop();\n\t\t\tp.push(x);\n        }\n    }\n    printf(\"%d\\n\",min(ans1,ans2));\n    return 0;\n}\n```\n\n欢迎批评指正！","tags":["题解","动态规划","贪心"],"categories":["OI","题解"]},{"title":"Linux配置ssr客户端","path":"/article/Linux-ssr/","content":"ShadowsocksR\n\nA fast tunnel proxy that helps you bypass firewalls.\n\n<!--more-->\n\nServer\n------\n\n## Install\n\nDebian / Ubuntu:\n\n    apt-get install git\n    git clone https://github.com/shadowsocksr/shadowsocksr.git\n\nCentOS:\n\n    yum install git\n    git clone https://github.com/shadowsocksr/shadowsocksr.git\n\nWindows:\n\n    git clone https://github.com/shadowsocksr/shadowsocksr.git\n\n## Usage for single user on linux platform\n\nIf you clone it into \"~/shadowsocksr\"  \nmove to \"~/shadowsocksr\", then run:\n\n    bash initcfg.sh\n\nmove to \"~/shadowsocksr/shadowsocks\", then run:\n\n    python server.py -p 443 -k password -m aes-128-cfb -O auth_aes128_md5 -o tls1.2_ticket_auth_compatible\n\nCheck all the options via `-h`.\n\nYou can also use a configuration file instead (recommend), move to \"~/shadowsocksr\" and edit the file \"user-config.json\", then move to \"~/shadowsocksr/shadowsocks\" again, just run:\n\n    python server.py\n\nTo run in the background:\n\n    ./logrun.sh\n\nTo stop:\n\n    ./stop.sh\n\nTo monitor the log:\n\n    ./tail.sh","tags":["随笔","黑科技"],"categories":["Dev"]},{"title":"【LG1784】 解数独 题解","path":"/article/LG1784-solution/","content":"一道即水的搜索题，不过还是有需要留意的地方，题目链接[here](https://www.luogu.org/problemnew/show/P1784)。\n\n<!--more-->\n\n## 核心思路\n\n### dfs搜索\n\n由左上至右下一次搜索，当找到答案或到达最右下角时结束。\n\n值得一提的是，如何确定每一个格子所在的9宫格中的哪一个。\n\n我用了一个mark函数进行计算。\n\n```cpp\nint mark(int x,int y){\t\n    int u=ceil(x*1.0/3),v=ceil(y*1.0/3);\n    return (u-1)*3+v;\n}\n```\n\n整体的思维难度不大。但是我在题解中看到一种神奇的写法。\n\n```cpp\nint mark(int x,int y){\n    if(y<=3) if(x<=3) return 1; else if(x<=6) return 2; else return 3;\n    else if(y<=6) if(x<=3) return 4; else if(x<=6) return 5; else return 6;\n    else{\n        if(x<=3) return 7; else if(x<=6) return 8; else return 9;\n    }\n}\n```\n\n### 剪枝\n\n并没有什么值得剪枝的，复杂度其实完全复杂要求。唯一要做到的一点是，不能算重。\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN 10+1\n#define INF 0x3f3f3f\n#define file(a) freopen(\"j\"a\".in\",\"r\",stdin),freopen(\"j\"a\".ans\",\"w\",stdout)\n\nint read() {\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nint a[MAXN][MAXN],line[MAXN][MAXN],rall[MAXN][MAXN],box[MAXN][MAXN];\n\nint mark(int x,int y){\t\n\tint u=ceil(x*1.0/3),v=ceil(y*1.0/3);\n\treturn (u-1)*3+v;\n}\n\nbool found=0;\n\nvoid print() {\n\tfor(int i=1; i<=9; i++){\n\t\tfor(int j=1; j<=9; j++)\n\t\t \tcout<<a[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n}\n\nvoid dfs(int x,int y) {\n    if(x==10) y++,x=1;\n    if(y==10&&x==1){\n        print();\n        found=1;\n        return ;\n    }\n    if(a[x][y]){\n        dfs(x+1,y);\n        return ;\n    }\n    int q=mark(x,y);\n    for(int i=1;i<=9;i++){\n        if(!line[x][i]&&!rall[y][i]&&!box[q][i]){\n            line[x][i]=1,rall[y][i]=1,box[q][i]=1,a[x][y]=i;\n            dfs(x+1,y);\n            line[x][i]=0,rall[y][i]=0,box[q][i]=0,a[x][y]=0;\n        }\n    }\n}\n\nint main() {\n//file(\"44\");\n\tfor(int i=1; i<=9; i++) \n\t\tfor(int j=1; j<=9; j++) {\n\t\t\ta[i][j]=read();\n\t\t\tif(a[i][j]!=0) {\n\t\t\t\tline[i][a[i][j]]=1;\n\t\t\t\trall[j][a[i][j]]=1;\n\t\t\t\tbox[mark(i,j)][a[i][j]]=1;\n\t\t\t}\n\t\t}\n\tdfs(1,1);\n    return 0;\n}\n```\n\n# 趣事\n\n首先，你进入[百度百科](https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E6%9C%80%E9%9A%BE%E6%95%B0%E7%8B%AC/13848819?fr=aladdin)。然后仔细阅读。然后小心求证一下。\n\n很有趣不是么？","tags":["题解","dfs"],"categories":["OI","题解"]},{"title":"【LG1004】方格取数 题解","path":"/article/LG1004-solution/","content":"这是一道四维DP的模版题，思维难度也不大，题目链接[here](https://www.luogu.org/problemnew/show/P1004)\n\n<!--more-->\n\n## 核心思路\n\n定义$dp[i][j][k][l]$为第一次走到$(i,j)$第二次走到$(k,l)$的最优方案，$a[i][j]$为放在$(i,j)$处的数字。\n\n由于每一步只能从$i-1$、$j-1$、$k-1$、$l-1$转移\n\n状态转移方程就很好推出了：\n\n$dp[i][j][k][l]=\\max(dp[i-1][j][k-1][l],max(dp[i][j-1][k-1][l],dp[i][j-1][k][l-1],dp[i-1][j][k][l-1])++a[i][j]+a[k][l]$\n\n要尤其注意$(i,j)$和$(k,l)$相同的情况\n\n\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 10+5\n\nint read() {\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint dp[MAXN][MAXN][MAXN][MAXN],a[MAXN][MAXN];\n\nint main() {\n    int n=read();\n    while(1) {\n        int x,y,s;\n        x=read(),y=read(),s=read();\n        if(x==0&&y==0&&s==0) break;\n        a[x][y]=s;\n    }\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=n; j++)\n            for(int k=1; k<=n; k++)\n                for(int l=1; l<=n; l++) {\n                    dp[i][j][k][l]=max(dp[i-1][j][k-1][l],max(dp[i][j-1][k-1][l],max(dp[i][j-1][k][l-1],dp[i-1][j][k][l-1])))+a[i][j]+a[k][l];\n\n                    if(i==k&&j==l) dp[i][j][k][l]-=a[i][j];\n    }\n\n    printf(\"%d\",dp[n][n][n][n]);\n}\n```","tags":["题解","动态规划"]},{"title":"什么，你还在Mac上用Win！","path":"/article/macOS/","content":"*注：本文适于使用macOS High Sierra的OIER*\n\n*本文可能引起部分win用户的不良反应，请谨慎观看。*\n\n<!--more-->\n\n## 前言\n\n苹果将在今年秋季发布macOS mojave的正式版本，到时候可能会写一篇与mojave有关文章。小D还不敢在新买的iMac上安装测试版系统。废话不多说，下面直接进入正题。\n\n## VIM的配置及使用\n\n众所周知，在NOI linux这个膜改版的Ubuntu 14下，VIM可以说是效率最高，最方便的编辑器了。而macOS和Linux有着同一个祖先——Unix，自然他们俩的一些功能也就很相似了。\n\n接下来小D将会介绍如何在macOS下把vim 配置得与NOI linux一样好用。\n\n打开终端，终端的地址在应用程序-实用工具\n\n打开终端后，分别输入如下指令\n\n```\n$ cd ~\n```\n\n```\n$ vim ~/.vimrc\n```\n\n*经过实测，并不要专门为vim新建一个文件夹*\n\n![](https://www.micdz.cn/img/2019-10-02-2.png)\n\n你会得到一个全新的文件，此时你就可以在这个文件中进行操作了，不需要担心，在这里的一切操作都是可以复原的。\n\n你看到的可能与下面的有些许不同，是因为我已经把配色方案设置好了\n\n![](https://www.micdz.cn/img/2019-10-02-1.png)\n\n这是我的配置文件内容\n\n文档版\n\n```\nset encoding=utf-8\nset fileencoding=utf-8\nset fileencodings=ucs-bom,utf-8,chinese\ncolorscheme evening\nsyntax enable\nsyntax on\nset shiftwidth=4\nset nowrap\nset nu \nset mouse=a\nset tabstop=4\nset autoindent\nset ruler\nset cursorline\nset nobackup\ncolor evening\nmap <F5> <Esc>:w<CR> :call CompileRunGcc()<CR>\nimap <F5> <Esc>:w<CR> :call CompileRunGcc()<CR>\nfunc! CompileRunGcc()\n    exec \"w\" \n    if &filetype == 'c' \n        exec '!g++ % -o %< -lm -O2'\n        exec '!time ./%<'\n    elseif &filetype == 'cpp'\n        exec '!g++ % -o %< -lm -O2'\n        exec '!time ./%<'\n    elseif &filetype == 'sh'\n        :!time bash %\n    endif                                                                              \nendfunc \nmap <F6> <Esc>:w<CR>\nmap <F7> <Esc>:w<CR> :q<CR> \n```\n\n*更多的配置方案可以参考：[真实有效的Vim配置记录(macOS)](https://www.jianshu.com/p/a03fcb09924c)*\n\n利用以上的配置可以实现：\n\n1. F5一键运行cpp、c的代码，您可以自己进行添加以实现py、pa的功能。\n2. F6一键保存，F7一键保存并退出\n\n当您配置好文件后，按键盘左上角的Esc然后依次输入:w和:q即可完成配置。\n\n此时您可以到你的工作目录愉快地使用vim进行编程了。\n\n## 将VIM的编译器变成g++\n\n当你按照上面的方法完成对VIM的配置后，愉快地进行编程，按下F5后的那一刻\n\n![](https://www.micdz.cn/img/2019-10-02-3.png)\n\nwoc，macOS竟然不支持bits？！此时心中有千万只***奔腾而过。不要慌张，下面是最轻松的解决方法。\n\nmacOS 自带的C++编译器是Clang而这一个C++编译器是不支持bits下的所有头文件的，即使你添加了源码也不支持（为此我专门打开了macOS的安全模式关闭了rootless）。\n\n于是，我意识到，我可能需要安装一个g++，g++是肯定支持bits的。\n\n于是就有了解决方案：\n\n1. 没有安装HomeBrew 的利用下面的代码安装\n\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n2. 安装g++和gcc(4.9)\n\n```\nbrew install gcc@4.9 --with-all-languages\n```\n\n3. 将编译指令改为g++-4.9\n\n![](https://www.micdz.cn/img/2019-10-02-4.png)\n\n![](https://www.micdz.cn/img/2019-10-02-5.png)\n\n  \n\n4. 尝试执行下面的代码查看你的编译器\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n    cout << __VERSION__ << endl;\n    return 0;\n}\n```\n\n如果输出为g++-4.9，从此以后妈妈再也不用担心我忘记头文件。\n\n\n## 在macOS上与外界交流\n\n![](https://www.micdz.cn/img/2019-10-02-6.png)\n\n你只需要登陆你的iCloud账号就可以与任何拥有任意苹果设备的人（包括iPhone、iPod、Mac、iWatch、iPad）进行Facetime通话。如果你的手机在同一个局域网内并且登陆了同一个苹果账号即可进行普通的电话拨打给任意用户。\n\n![](https://www.micdz.cn/img/2019-10-02-7.png)\n\n同样的，如果你登陆了iCloud即可给任意拥有苹果设备的人发送iMessage，如果你的手机在同一个局域网内并且登陆了同一个苹果账号即可发送普通的短信给任意用户。\n\n![](https://www.micdz.cn/img/2019-10-02-11.png)\n\n不仅如此，还有更加厉害的联络方式——使用邮件\n\n![](https://www.micdz.cn/img/2019-10-02-8.png)\n\n目前，已经支持了以上的所有邮件公司，足够满足我们的日常生活，但是！\n\n它还支持你的企业邮箱。\n\n以qq企业邮箱为例\n\n![](https://www.micdz.cn/img/2019-10-02-9.png)\n\n苹果的邮箱账户可以利用IMAP协议与你的企业邮箱进行连接，只需要输入您的地址和密码即可\n\n![](https://www.micdz.cn/img/2019-10-02-10.png)\n\n## 接力使你的工作更加轻松\n\n当你在iPad上打开luogu，看到一道非常好的题目，想要到电脑上实现它，非常轻松，只需要到duck的左下角，你会发现一个浏览器的图标左上角跟随了你的iPad图标。点开后甚至能够做到页面上的工作内容“接力”，例如luogu在线IDE。\n\n## 更多方便的功能等你来探索\n\n在macOS上有许多的高级的软件，例如Xcode、Final Cut……","tags":["随笔"],"categories":["Others"]},{"title":"最近公共祖先(LCA)","path":"/article/lca/","content":"LCA最近公共祖先解决的是：对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。\n\n<!--more-->\n\n通俗地讲就是下面的这个例子：\n\n![图片来自默思·朸安](https://www.micdz.cn/img/2018-7-27-2.png)\n\n在上图中10和12的LCA就是3。\n\n## 核心思路\n\n### 模拟法\n\n根据题意进行模拟。一步一步回向根节点递进，分别对到达的顶点标号，碰到的第一个两个都到达过的顶点即为两点的LCA了。\n\n这样的做法非常自然，但是绝对不可能符合这一道题所要求的时间复杂度。\n\n### 倍增法\n\n仍旧是按照题意进行模拟，不同的是，这次不再一次一次向上找，这次以2的倍数从上向下找。\n\n具体的操作步骤很简单，首先将两节点调到保证$deep[X]>=deep[Y]$，如果这个时候两点是同一点则可以直接出答案，如果不行则将$X$从上向下跳。为什么要从上往下跳呢？\n\n![](https://www.micdz.cn/img/2018-7-27-1.png)\n\n通过上面的这个例子可以看出，如果从下向上的话，有可能跳到的那一个点不是最近公共祖先，而从上向下可以在找到后继续向下。\n\n\n\n## 代码分解\n\n$p[i][j]$ 表示节点$i$的$2^j$级祖先。\n\n### dfs求深度\n\n```cpp\nvoid dfs(int u,int fa) {//u表示当前节点，fa表示它的父亲节点\n    d[u]=d[fa]+1;//深度比它的父亲要大1\n    p[u][0]=fa;\n    for(int i=1; (1<<i)<=d[u]; i++)\n        p[u][i]=p[p[u][i-1]][i-1];//转移\n\tfor(int i=head[u];i;i=next[i]) {\n        int v=to[i];\n        if(v!=fa)//v不是父亲节点\n            dfs(v,u);//从根节点出发进行dfs\n    }\n}\n```\n\n上述的状态转移的含义是：\n$u$的$2^i$个祖先和$u$的$2^{i-1}$个祖先的$2^{i-1}$是同一个祖先\n\n数学逻辑来讲就是$2^i=2\\times2\\times\\ldots\\times2\\times2$(共有i个2)\n\n而$2^{i-1}=2\\times2\\times\\ldots \\times2\\times2$(共有i-1个2)\n\n根据乘法分配律，得出$2^{i-1}+2^{i-1}=2^i$并且要满足$2^i\\leq d[u]$，其$d[u]$是该节点的深度。\n\n所以上面的含义也就成立，可以得出每一个节点的任意的祖先（这里没有边权的概念）。\n\n\n\n### ST求LCA\n\n```cpp\nint lca(int a,int b) {\n    if(d[a]>d[b]) swap(a,b);\n    for(int i=20; i>=0; i--)\n        if(d[a]<=d[b]-(1<<i))\n            b=p[b][i];\n    if(a==b) return a;//如果直接找到答案就可以输出了，此时一定是最近的解\n    \n    for(int i=20; i>=0; i--) {\n        if(p[a][i]==p[b][i]) continue;//得到第一个答案，但不确定是不是最近所以continue，继续\n        else {\n            a=p[a][i];//将a往下跳\n            b=p[b][i];//将b往下跳\n        }\n    }\n    return p[a][0];//经过20轮操作后即可得到最终答案，也等价于p[b][0]\n\n}\n```\n\n这一步的操作也比较简单。首先必须确保$a$的深度要小于或等于$b$的深度。然后将深度大的$b$由上向下跳，可以说是从$2^{20}$开始逐步向下（这样可以有效降低代码难度而对程序运行几乎没有影响）。直到$b$刚刚跳到了$a$的上面。此时$a$与$b$的LCA就一定在$a$和$b$之间了。接下来的操作与刚才的非常相似，同样是进行20次“徘徊”，详细的内容见上方注释。\n\n\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 500000+10\n\nusing namespace std;\n\nint head[MAXN<<1],to[MAXN<<1],next[MAXN<<1],cnt=0;\n\nint n,m,s;\n\nvoid addedge(int u,int v) {\n    cnt++;\n    to[cnt]=v;\n    next[cnt]=head[u];\n    head[u]=cnt;\n}\n\nint read() {//快读略\n}\n\nint d[MAXN],p[MAXN][21];\n\nvoid dfs(int u,int fa) {\n    d[u]=d[fa]+1;\n    p[u][0]=fa;\n    for(int i=1; (1<<i)<=d[u]; i++)\n        p[u][i]=p[p[u][i-1]][i-1];\n\tfor(int i=head[u];i;i=next[i]) {\n        int v=to[i];\n        if(v!=fa)\n            dfs(v,u);\n    }\n}\n\nint lca(int a,int b) {\n    if(d[a]>d[b]) swap(a,b);\n    for(int i=20; i>=0; i--)\n        if(d[a]<=d[b]-(1<<i))\n            b=p[b][i];\n    if(a==b) return a;\n    \n    for(int i=20; i>=0; i--) {\n        if(p[a][i]==p[b][i]) continue;\n        else {\n            a=p[a][i];\n            b=p[b][i];\n        }\n    }\n    return p[a][0];\n\n}\nint main() {\n\n\tmemset(head,-1,sizeof(head));\n    \n    n=read(); m=read(); s=read();\n    for(int i=1; i<=n-1; i++) {\n        int x,y;\n        x=read(),y=read();\n        addedge(x,y);\n        addedge(y,x);//树是无向图\n    }\n    dfs(s,0);\n    for(int i=1; i<=m; i++) {\n        int a=read(),b=read();\n        printf(\"%d\\n\",lca(a,b));\n    }\n    return 0;\n}\n\n```","tags":["图论","随笔","笔记"],"categories":["OI"]},{"title":"【NOIP2016】组合数问题 题解","path":"/article/NOIP2016d2t1-solution/","content":"NOIP2016中除了玩具谜题这道大水题之外，稍难一点的就是这道题了。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n[题目链接](https://www.luogu.org/problemnew/show/P2822)\n\n## 核心思路\n\n> 用杨辉三角存储下组合数的值，利用二维前缀和累加。代码实现非常简单，思维难度仅限于杨辉三角的部分。\n\n不要被题面所迷惑了，都是骗人的，使用公式最多30分（代码完成度非常高且非常鲁棒）。\n\n### 杨辉三角\n\n```\n       1\n      1 1\n     1 2 1\n    1 3 3 1\n   1 4 6 4 1\n  ……       ……\n```\n\n上述就是最基础的杨辉三角。\n\n你可以很轻松地发现第$n$行的第$k$个数字为[组合数](https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E6%95%B0) $C^{k-1}_{n-1}$\n\n具体的论证过程参照[here](https://zh.wikipedia.org/wiki/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2)\n\n这样我们就可以$\\Theta(2000\\times \\sqrt{2000})$把所有的组合数的值求出来了\n\n\n\n### 二维前缀和\n\n可以参照我的[这篇文章](https://www.micdz.cn/article/basic-ds/)。\n\n这里的转移方程是\n\n```cpp\ns[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n```\n\ns(i,j)表示题意中的n，m所对应的对数。\n\n\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 2000+10\n\nusing namespace std;\n\nint read() {//快读略\n}\nint a[MAXN][MAXN],s[MAXN][MAXN];\nint main() {\n    int t=read(),k=read();\n    for(int i=0;i<=2000;i++) {\n        a[i][i]=1;\n        a[i][0]=1;\n    }\n    for(int i=1; i<=2000; i++)\n        for(int j=1; j<i; j++)\n            a[i][j]=(a[i-1][j]+a[i-1][j-1])%k;//在计算的时候直接%k可以避免后面无效的重复计算\n    for(int i=1; i<=2000; i++)\n        for(int j=1; j<=2000; j++) {\n            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//前缀和口诀：上加左 减左上 加自己\n            if(a[i][j]==0&&j<=i) s[i][j]++;//如果a[i][j]满足要求则++\n        }\n    for(int i=1; i<=t ;i++) {\n        int n=read(),m=read();\n        printf(\"%d\\n\",s[n][m]);\n    }\n    return 0;\n}\n```","tags":["题解","数学","随笔"],"categories":["OI","题解"]},{"title":"如何尺规作出三等分点","path":"/article/make-three-equal-points/","content":"初一的时候，老师教我们画出了线段的中点，留下思考题思考如何作出三等分点至今未予以回答。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n## 中点\n\n中点的作法很简单\n\n![](https://www.micdz.cn/img/2018-6-12-1.png)\n\n如上图：\n\n$AB$的中点是$C$证明过程非常简单\n\n![](https://www.micdz.cn/img/2018-6-12-3.png)\n\n$$\n\\begin{aligned}\n\\triangle ADE \\cong \\triangle BDE\\\\\n\\triangle ADC \\cong \\triangle BDC\n\\end{aligned}\n$$\n\n## 三等分点\n\n### step1:\n\n![](https://www.micdz.cn/img/2018-6-12-4.png)\n\n现给出一个线段$AB$。\n\n### step2:\n\n![](https://www.micdz.cn/img/2018-6-12-5.png)\n\n过$A$点作任意不与AB平行的直线。\n\n### step3:\n\n![](https://www.micdz.cn/img/2018-6-12-6.png)\n\n以$A$为圆心任意半径作圆，交直线于$C$、$D$两点。\n\n### step4:\n![](https://www.micdz.cn/img/2018-6-12-7.png)\n\n连接$B$、$D$，作其中点$E$（参照[here](https://www.micdz.cn/%E5%A6%82%E4%BD%95%E5%B0%BA%E8%A7%84%E4%BD%9C%E5%87%BA%E4%B8%89%E7%AD%89%E5%88%86%E7%82%B9/#%E4%B8%AD%E7%82%B9)）。\n\n### step5:\n![](https://www.micdz.cn/img/2018-6-12-8.png)\n\n连接AE得到$M$，即为所求。","tags":["数学","几何"],"categories":["Others"]},{"title":"【SDOI2009】SuperGCD 题解","path":"/article/SDOI2009-solution/","content":"最“快”的一道紫题。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n[题目链接](https://www.lydsy.com/JudgeOnline/problem.php?id=1876)\n\n辗转相除法并不会RE，python水过，好像py3自带了GCD函数（我不会写）。\n\n```python\na=int(input()) \nb=int(input()) \nwhile b!=0: \n    t=a \n    a=b \n    b=t%b \nprint(a)\n```\n\n最慢的点164ms可以接受\n\nnoi不支持python，这是多么遗憾的一件事情。\n\n中国还没有在OI圈普及，俄罗斯美国已经相当发达了。\n\n\n\n就这么*掉了一道紫题，有点不好意思呢。","tags":["题解","数学","高精度"],"categories":["OI"]},{"title":"网络最大流","path":"/article/max-flow/","content":"半个月前~~学了~~网络最大流，，然后弃坑。。。\n\n半个月后。。。\n\n  <!--more-->\n\n原谅我使用了一些来自互联网的图。\n\n## 基础概念\n\n![](https://www.micdz.cn/img/2018-6-04-1.png)\n\n\n\n通俗地来讲网络最大流问题就是就是求从工厂最多可以发出多少货物，不至于超过道路的容量限制，与上述通俗概念不同的是每一条道路是一次性的。也就是每一辆车通过每一条道路都需要将这条道路的容量减去车的载重直至容量小于0（好像是废话），因为如果不是这样就可以理解成第一辆车载着n通过了，第二辆车可以继续从这里载着n通过。\n\n\n\n~~严格~~的定义就是：给定一个有向图，和两个点–源点A和汇点G，点之间有连边， 每条边有一个容量限制，网络流就是指由S点流到T点的一个可行流。 最大流就是指所有可行流里面最大的流。\n\n\n\n上方给出的图就是从A出发到G最大的流。\n\n## 求解\n\n首先需要引入一个剩余的概念：\n\n![](https://www.micdz.cn/img/2018-6-04-2.png)\n\n从上图来看，左边代表的是这条道路的容量，右边代表的是这条道路剩下的流量。\n\n### 贪心\n\n自然地可以想到贪心，但是贪心却是错误的。大致的思路就像是dijkstra算法，每一次找所连边中剩余最大的那一个，很容易就可以找到例子推翻。\n\n![](https://www.micdz.cn/img/2018-6-04-3.png)\n\n例如在上面的这个经典的图中，我们找到了1->2->4->6 这条增广路，得到了汇点最大的流是2然而答案显然不是2。任可以1->3->4->2->5->6 最大是3。那么如何得到这个3呢？\n\n### DINIC\n\nDINIC的基本思路就是：\n\n1. 根据残量网络计算层次图。\n2. 在层次图中使用DFS进行增广直到不存在增广路\n3. 重复以上步骤直到无法增广\n\n至于残量网络、层次图是什么，接下来用几个不同的思路来解决。\n\n#### 添加反向边\n\n每插入一条边$u$到$v$的边权是$w$，我们考虑添加一条反向的边权为0的边，也就是从$v$到$u$边权是0的边。这样做的目的是使程序可以走“回头路”。考虑上方的图，每当从一个点流向另一个点时，将这条边的反向边加上流量值，如果到了下一个点仍保留往回走的方案。\n\n具体类似于这样：\n\n```cpp\n//读边\naddedge(u,v,s);\naddedge(v,u,0);\n\n//内部dfs，这里的s指的是遍历到的边的剩余流量。\ne[i].w-=s; e[i^1].w+=s;\n/*^1的作用就是奇数-1偶数+1。\n相当于就是正向边-s，反向+s\n*/\n```","tags":["图论","笔记","网络流","DINIC"],"categories":["OI"]},{"title":"SPFA深入解析","path":"/article/advanced-SPFA/","content":"SPFA是一种高效的单源最短路径算法。\n\n<!--more-->\n\n## 算法简述\n\n1. 读入每一条边的权值到**邻接表**\n3. 将最短路径数组初始化为INF\n4. 将起点加入队列\n5. 原点到原点路径设为0\n6. 从队列取出首元素\n7. 广度优先遍历出边\n8. 进行松弛操作，如可进行则将出边对应点加入队列\n8. 用一个数组表示i是否已入队\n\n这是一个单源最短路径算法（废话）\n\n## 正确性证明\n其实只需证明SPFA的遍历过程是收敛的，可以看看段凡丁的介绍。\n\n\n\n\n## 算法复杂度分析\n\n经过长篇的分析与介绍，段凡丁在原文中给出了\n\n$$\n\\begin{aligned}\nT=&\\Theta(\\frac{m}{n}\\cdot e)\\\\\n=&\\Theta(k\\cdot e)\\\\\n\\end{aligned}\n$$\n所以得出结论：\n$$\n\\begin{aligned}\nT=&\\Theta(e)\n\\end{aligned}\n$$\n\n\n\n你不禁大叫：“假的吧！”。这里的 $m,n$ 指的不是点数和边数， $m$ 其实是外层while的循环次数。\n\n没错，按照正常的推理逻辑的确可以得出这个结论。\n\n但是 $\\frac{m}{n}$ 完全可以很大，也就是 $n$ 要远小于 $m$ 时也就是一个稠密图时SPFA的复杂度竟然可以无限地趋近于 $\\Theta(nm)$ 。这样就远远不如dijkstra算法了（实际上还有各种各样的常数）。\n\nPs：论文里的说法太不负责任了。\n\n\n\n## 实现\n\n下面以是[热浪](https://www.luogu.org/problemnew/show/P1339)为例题的代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN 10000+10\n#define MAXM 65000+10\n#define INF 0x3f3f3f\n\nstruct edge{\n\tlong long to,next,v;\n}e[MAXM*2];\n\nlong long cnt,last[MAXN];;\nlong long n,m,s,t;\nvoid add(long long u,long long v,long long w){\n\tcnt++;\n\te[cnt].to=v;\n\te[cnt].v=w;\n\te[cnt].next=last[u];\n\tlast[u]=cnt;\n}\n\nvoid spfa(){\n\tlong long inq[MAXN],d[MAXN];\n\tqueue<long long> q;\n\tmemset(inq,0,sizeof(inq));\n\tfor(long long i=1;i<=n;i++)\n\t\td[i]=INF;\n\n\td[s]=0;inq[s]=1;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tlong long u=q.front();\n\t\tq.pop();\n\t\tinq[u]=0;\n\t\tfor(long long i=last[u];i>=0;i=e[i].next){\n\t\t\tlong long v=e[i].to,w=e[i].v;\n\t\t\tif(d[v]>d[u]+w){\n\t\t\t\td[v]=d[u]+w;\n\t\t\t\tif(!inq[v]){\n\t\t\t\t\tinq[v]=1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<d[t]<<endl;\n}\nlong long read(){\n\tlong long x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint main(){\n\tmemset(last,-1,sizeof(last));\n\tn=read(),m=read(),s=read(),t=read();\n\tfor(long long i=1; i<=m; i++){\n\t\tlong long u=read(),v=read(),w=read();\n\t\tadd(u,v,w);\n\t\tadd(v,u,w);\n\t}\n\tspfa();\n}\n```\n\n\n\n_References:_\n\n1. Duan, Fanding (1994), [\"关于最短路径的SPFA快速算法\"](http://wenku.baidu.com/view/3b8c5d778e9951e79a892705.html), _西南交通大学学报_, **29** (2): 207–212\n2. [SPFA算法wiki](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm)","tags":["图论","随笔","笔记"],"categories":["OI"]},{"title":"将Git本地仓库上传至github","path":"/article/localgit-to-github/","content":"近一段时间入手Git和GitHub，一直有许多疑惑。今天得以解决。更加深了对于Git的使用以及对GitHub的看法。\n\n\n\n本文将会系统地介绍将Git本地仓库上传至github。\n\n<!--more-->\n\n## 准备工作：\n\n1. 一个GitHub账户。\n2. 一个GitHub仓库。\n3. 与GitHub账户绑定好ssh密钥。_具体操作[here](https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5)_\n\n\n## 操作步骤\n\n接下来随便找到一个文件夹，右键git bash here。\n\n将这个文件夹与你的仓库绑定\n\n```\n$ git remote add origin git@github.com:youusername/test.git\n```\n将仓库上的文件拉下来，否则会报错\n\n```\n$ git pull origin master\n```\n记录下刚刚操作的文件\n\n```\n$ git add .\n```\n\n提交到GitHub\n\n```cpp\n$ git push origin master\n```\n\n\n\n最后你就可以到你的GitHub仓库中查看代码了。","tags":["随笔"],"categories":["Dev"]},{"title":"简单数论","path":"/article/basic-math/","content":"数论是学习OI的必经之路。\n\n<!--more-->\n\n## Primarily Test\n\n### Normal Sieve\n\n* 对于每一个数，筛去所有倍数，因为它的倍数有它自己这个因子\n* 时间复杂度： $n\\sum\\limits_{i=1}\\frac{1}{i}$\n\n### Sieve of Eratosthenes\n\n* *埃拉托色尼筛选法*，伪线性筛算法（ *与线性筛算法呈常数关系*）\n* 对于每一个质数，筛去所有它的倍数\n* 一个显然的优化是 $i-i^2$ 这一段的数是不用筛的\n* 时间复杂度： $n\\sum\\limits_{p\\le n}\\frac{1}{p}=O(n\\log\\log n)$\n\n### Linear Sieve\n\n* 对于每一个数，用小于等于它最小的质因子的所有质数筛\n* 每一个数只会被它最小的质因子筛到一次\n* 时间复杂度：  $O(n)$\n\n## Multiplicative Function\n\n* 欧拉函数一种重要的积性函数\n* $φ(n)$ 表小于等于 $n$ 的数中与 $n$ 互质的数的个数\n* 计算方法:\n* $\\varphi(n)=n\\mathop\\Pi\\limits_{p|n}\\frac{p-1}{p}$\n* 本质：容斥原理，直接枚举质因数计算\n\n## GCD\n\n* k|a 且k|b , k is a common factor of a and b\n* We call the largest k Greatest Common Divisor of a and b\n* 若 $b=0$ ，$gcd(a,b)=a$\n* $gcd(a,b)=gcd(a-b,b)$\n* $\\gcd(a,b)=\\gcd(b\\%a,a)$\n* 辗转相除，时间复杂度O(log n)\n\n52：36","tags":["数学","笔记"],"categories":["OI"]},{"title":"【LG2085 最小函数值 题解","path":"/article/LG2085-solution/","content":"题目链接[here](https://www.luogu.org/problemnew/show/P2085)\n\n正解讲了啥我也不清楚，但是有一种神奇的解法。\n\n<!--more-->\n\n## 核心思路\n\n其中关键在于：\n\n```cpp\nvoid work(int a,int b,int c){\n\tfor(int i=1;i<=sqrt(m)+1;i++){\n\t\tq.push(a*i*i+b*i+c);\n\t}\n}\n```\n\n在计算中只计算$\\sqrt m$的范围。如果直接m的话只能勉强获得20分。\n\n因为计算m的复杂度是$\\Theta(nm)$，显然会超时。\n\n\n\n这可能是一种投机取巧的方式，如果数据强一点一定会被卡掉，因为当二次函数的对称轴大于了$\\sqrt m$，最小值就一定不会在$\\sqrt m$的范围内了（$a>0$的情况），$a<0$同样成立。\n\n\n\n建议管理员还是可以强化一下数据，hack非正解。\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 200000+10\n#define INF 0x3f3f3f\nusing namespace std;\nint read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint a[MAXN],n,m;\n\npriority_queue <int,vector<int>,greater<int> > q;\n\nvoid work(int a,int b,int c){\n\tfor(int i=1;i<=sqrt(m)+1;i++){\n\t\tq.push(a*i*i+b*i+c);\n\t}\n}\nint main(){ \n\tn=read();\n\tm=read();\n\tint a,b,c;\n\tfor(int i=1;i<=n;i++){\n\t\ta=read(),b=read(),c=read();\n\t\twork(a,b,c);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tcout<<q.top()<<\" \";\n\t\tq.pop();\n\t}\n}  \n```","tags":["题解","堆"],"categories":["OI","题解"]},{"title":"【HAOI2006】聪明的猴子 题解","path":"/article/HAOI2006-solution/","content":"题目链接[here](https://www.lydsy.com/JudgeOnline/problem.php?id=2429)\n\n题目不难，普及/提高-\n\n<!--more-->\n\n## 核心思路\n\n> 找到最小生成树的。\n> \n> 记录下最小生成树的最大边。\n> \n> 比较每一只猴子的跳跃最远距离与最大边的关系，可以跳过则ans++。\n\n### 易错点\n\n看上去很简单，可以直接将[最小生成树](https://douglas-zhou.cn/2018/04/28/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/)直接拿过来套模板，我就是这样做的，然而：\n\n2AC，3WA，5RE。\n\n我开始找问题，经历了大概两天的时间，我总结出了以下这些坑点，作为一个刚开始做图论题的蒟蒻容易错的一些坑点。\n\n​\t1. 套模板时忘记把n改为cnt，cnt指的是在图中的n个点与其它点构成的$\\frac{n\\times (n-1)}{2}$条边。\n\n​\t2. 忘记将struct存下的边开大到$\\frac{n\\times (n-1)}{2}$，在题目中也就是大约1000000。\n\n​\t3. f[]数组没有完全初始化。\n\n## 代码\n\n由于套模板，这里的代码非常丑陋。\n\n简单的读入\n\n```cpp\nint m=read();\nfor(int i=1;i<=m;i++)hd[i]=read();\nint n=read();\nfor(int i=1;i<=n;i++)x[i]=read(),y[i]=read();\n```\n\n处理每一条边\n\n```cpp\nfor(int i=1;i<=n;i++)\nfor(int j=i+1;j<=n;j++){\n\tcnt++;\n\ta[cnt].u=i;\n\ta[cnt].v=j;\n\ta[cnt].s=dist(x[i],x[j],y[i],y[j]);\n}\n```\n\n非常丑陋的核心代码\n\n```cpp\nsort(a+1,a+1+cnt,cmp);\nfor(int i=1;i<=MAXN;i++)f[i]=i;\nint ans=0,s=0;\nfor(int i=1;i<=cnt;i++){\n\tif(find(a[i].u)!=find(a[i].v)){\n\t\tlink(a[i].u,a[i].v);\n\t\ts++;\n\t\tif(a[i].s>maxx)maxx=a[i].s;\n\t\tif(s==n-1){//找到答案了\n\t\t\tint shu=0;\n\t\t\t//cout<<maxx;\n\t\t\tfor(int i=1;i<=m;i++)if(hd[i]>=maxx)shu++;//计数\n\t\t\tcout<<shu<<endl;                \n\t\t\treturn 0;\n\t\t}\n\t}\n}\n```\n\n完整代码[here](https://douglas-zhou.cn/code/%E8%81%AA%E6%98%8E%E7%9A%84%E7%8C%B4%E5%AD%902)","tags":["题解","kruskal"],"categories":["OI","题解"]},{"title":"前向星存图","path":"/article/qian-xiang-xing/","content":"为什么要用前向星存图？\n\n前向星可以很方便地读取点的出边，在某些图论算法（如SPFA）中可以做到很低的复杂度\n\nFlyuZ：邻接表是用链表实现的，可以动态的增加边， 而前向星是用结构体数组实现的，是静态的，需要一开始知道数据范围，开好数组大小。 相比之下，邻接表灵活，但链式前向星好写。\n\n这里只介绍链式前向星。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n## 准备工作\n\n> head[x]是点的头指针\n>\n> next[i]是链表的下一个元素\n>\n> to[i]是这一个点所到达的边，e[i].v是这条边的权值\n\n\n\n\n\n## 建立边表\n\n```cpp\nint head[MAXN],to[MAXN],next[MAXN],weigh[MAXN];\n```\n\n## 加边的方法\n\n```cpp\nvoid add(int u,int v,int w){\n\tcnt++;//cnt可以理解为当前加入这条边的编号\n\tto[cnt]=v;//这条边指向了v，可以这么理解，所有邻接表中只有to会指向点的编号\n\tnext[cnt]=head[u];//将当前边的的下一条边指向u的头指针\n\thead[u]=cnt;//更新u的头指针\n\tweigh[cnt]=w;//记录边权\n}\n```\n\n### 原理\n\ncnt记录的是当前点的序号，后面所有的操作都是在cnt内的。\n\n将cnt的边的终点指向v。\n\n将下一个元素连到起点u的头指针并更新u的头指针。\n\n最后记录边权，这一步可有可无。\n\n\n\n## 遍历的方法\n\n```cpp\nfor(int i=head[now]; i!=0; i=next[i]) {\n\t//Do something\n}\n```\n\n从now的头元素开始沿着链表遍历全图。\n\n\n## 效率对比\n\n| 方式 | 查询（出边） | 插入 |\n| - | :-: | :-: |\n| 邻接矩阵 | $\\Theta(n)$ | $\\Theta(1)$ |\n| 前向星 | $\\Theta(k)$ | $\\Theta(3)$ |\n\n_注：上图中的k指的是所连出边，n是指点的个数_\n\n也就是说，如果在一个完全图（任何一点与所有点都有连边）中，邻接表与邻接矩阵几乎是一样的。\n\n## 代码提交\n\nGYOJ提供了模板数据，具体参照[here](https://vijos.org/d/gysyzx/p/5b6ab433d3d8a169f1b865ee)\n\n\n\nUpdate 2018.","tags":["图论","笔记"],"categories":["OI"]},{"title":"【SCOI2005】繁忙的都市 题解","path":"/article/SCOI2005-solution/","content":"[题目链接](https://www.luogu.org/problemnew/show/P2330)\n\n这道题其实可以再水一点。\n\n一道裸的最小生成树。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n## 核心思路\n\n问题一就是输出$n-1$就OK了。\n\n问题二只要一个maxx存下最大边。\n\n\n\n为什么？[here](https://douglas-zhou.cn/2018/04/28/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/)\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN 200000+10\n#define INF 0x3f3f3f\nint f[MAXN];\nstruct point{\n    int u,v,s;\n}a[MAXN];\nint read(){\n    int f=1,x=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint find(int x){\n    if(f[x]==x)return f[x];\n    return f[x]=find(f[x]);\n}\nint link(int x,int y){\n    f[find(x)]=find(y);\n}\nbool cmp(point a,point b){\n    return a.s<b.s;\n}\nint main(){\n    int n=read(),m=read();\n    for(int i=1;i<=m;i++)\n        a[i].u=read(),a[i].v=read(),a[i].s=read();\n    sort(a+1,a+1+m,cmp);\n    for(int i=1;i<=m;i++)f[i]=i;\n    int ans=0,s=0,maxx=-INF;\n    for(int i=1;i<=m;i++){\n        if(find(a[i].u)!=find(a[i].v)){\n            link(a[i].u,a[i].v),ans+=a[i].s;\n            s++;\n            if(a[i].s>maxx)maxx=a[i].s;\n            if(s==n-1){\n                cout<<n-1<<\" \"<<maxx;\n                return 0;\n            }\n        }\n    }\n    return 0;\n} \n```","tags":["题解","kruskal"],"categories":["OI","题解"]},{"title":"最小生成树","path":"/article/mst/","content":"最小生成树的主要思路是贪心，用到了并查集的知识。\n\n<!--more-->\n\n![](/img/4.jpg)\n\n## 定义\n\n\n\n> 什么是最小生成树？\n>\n> 给定一个图$G<V,E>$，$G'<v,e>$的$v\\in V,e\\in E$，且是一棵树时就可称$G'$是$G$的生成树。\n>\n> 最小生成树的定义就更清晰了。\n>\n> 即在$G$所有的生成树中，边权之和最小的一棵\n\n[题目链接](https://www.luogu.org/problemnew/show/P3366)\n\n\n\n\n\n\n\n考虑用Kruskal算法，尽管离线但是效率感人。\n\n看上去很麻烦？其实不然，只是简单的贪心罢了。\n\n\n\n## 核心思路\n\n```\n将所有的点按照边权从小到大排列。\n找到最小的一条，如果首尾不在同一子树中则相连。\n如果在则舍弃。\n当连完n-1条边则可输出答案。\n```\n\n## 代码\n\n代码并不难理解：\n\n并查集部分\n\n```cpp\nint find(int x){\n\tif(f[x]==x)return f[x];\n\treturn f[x]=find(f[x]);\n}\nint link(int x,int y){\n\tf[find(x)]=find(y);\n}\n```\n\n用`point`存边，用cmp作排序规则\n\n```cpp\nstruct point{\n\tint u,v,s;\n}a[MAXN];\n\nbool cmp(point a,point b){\n\treturn a.s<b.s;\n}\n```\n\n读入的方式很简单\n\n```cpp\nint n=read(),m=read();\nfor(int i=1;i<=m;i++)\n\ta[i].u=read(),a[i].v=read(),a[i].s=read();\n```\n\n就代表着a[i].u到a[i].v有一条边权为a[i].s的边。\n\n\n\n核心代码\n\n```cpp\nsort(a+1,a+1+m,cmp);//将边排序\nfor(int i=1;i<=m;i++)f[i]=i;//并查集初始化\nans=0,s=0;//ans存答案，s存步骤\nfor(int i=1;i<=m;i++){\n\tif(find(a[i].u)!=find(a[i].v)){//如果不在同一子树\n\t\tlink(a[i].u,a[i].v),ans+=a[i].s;//连接在一起，将ans更新\n\t\ts++;//将s更新\n\t\tif(s==n-1){//有了n-1条边\n\t\t\tcout<<ans;//直接输出答案\n\t\t\treturn 0;//结束\n\t\t}\n\t}\n}\n```\n\n\n\n完整代码[here](https://douglas-zhou.cn/code/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)\n\n最小生成树不难理解，接下来还会有次小生成树等待学习。","tags":["题解","贪心","kruskal","笔记"],"categories":["OI"]},{"title":"【NOIP2017】奶酪 题解","path":"/article/NOIP2017d2t1-solution/","content":"Day2T1，普及/提高-\n[题目链接](https://www.luogu.org/problemnew/show/P3958)\n\n> 这是一篇原始文章，不保证内容的正确性\n\n## 核心思路\n\n> 用一个结构体point封装点。\n>\n> 从1到n找到所有的与下底面相连的洞，即abs(a[i].z)<=r。\n>\n> 从它开始dfs一步一步向与它所连的洞dist(a[i],a[x])>2*r搜索。\n>\n> 如果到达一个洞可以到达上表面，即a[x].z+r>=h，就找到答案了。\n>\n> 如果全部遍历了一遍都还没找到就可以确定不能到达了。\n\n\n\n坐标距离公式，记得要`double`。\n\n```cpp\ndouble dist(point a,point b){\n\treturn sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2));\n}\n```\n\n一个没有任何技术含量的dfs。\n```cpp\nvoid dfs(long long x){\n\tif(arr||x>n)return;\n\t//cout<<\"in:\"<<x<<endl;\n\tif(a[x].z+r>=h){arr=1;return;}\n\tfor(long long i=1;i<=n;i++){\n\tif(have[i]||dist(a[i],a[x])>2*r)continue;\n\t\thave[i]=1;\n\t\tdfs(i);\n\t\t//have[i]=0;千万千万不要回溯，每一个点遍历一次就好了，回溯百分百超时\n\t}\n}\n```\n\n主函数。\n```cpp\nint main(){\n\tdouble H=read();\n\tfor(double i=1;i<=H;i++){\n\t\tarr=0;//arr表示到或没到\n\t\ts=0;\n\n\t\tn=read(),h=read(),r=read();\n\t\tfor(int i=1;i<=n;i++)have[i]=0;\n\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\ta[i].x=read();\n\t\t\ta[i].y=read();\n\t\t\ta[i].z=read();\n        }//读入\n\t\tfor(long long i=1;i<=n;i++)\n\t\t\tif(abs(a[i].z)<=r){\n\t\t\t\thave[i]=1;\n\t\t\t\tdfs(i);//如果与下表面联通就dfs\n\t\t\t\tfor(int i=1;i<=n;i++)have[i]=0;//初始化\n\t\t\t}\n\t\tif(arr)cout<<\"Yes \\n\";\n\t\telse cout<<\"No \\n\";//不要再犯类似错误\n\t}\n    \n}\n```\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 1000+10\n#define MAXM 10000+10\nusing namespace std;\n\ndouble read(){\n\tdouble x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}//丑陋一点不要介意\n\nstruct point{\n\tdouble x,y,z;\n}a[MAXN];\n\ndouble dist(point a,point b){\n\treturn sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2));\n}\n\nbool have[MAXM],arr;\nlong long n,h,r;\n\nint s=0;\nvoid dfs(long long x){\n\tif(arr||x>n)return;\n\t//cout<<\"in:\"<<x<<endl;\n\tif(a[x].z+r>=h){arr=1;return;}\n\tfor(long long i=1;i<=n;i++){\n\t\tif(have[i]||dist(a[i],a[x])>2*r)continue;\n\t\thave[i]=1;\n\t\tdfs(i);\n\t\t//have[i]=0;\n\t}\n}\nint main(){\n\tdouble H=read();\n\tfor(double i=1;i<=H;i++){\n\t\tarr=0;\n\t\ts=0;\n\n\t\tn=read(),h=read(),r=read();\n\t\tfor(int i=1;i<=n;i++)have[i]=0;\n\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\ta[i].x=read();\n\t\t\ta[i].y=read();\n\t\t\ta[i].z=read();\n\t\t}\n\t\tfor(long long i=1;i<=n;i++)\n\t\t\tif(abs(a[i].z)<=r){\n\t\t\t\thave[i]=1;\n\t\t\t\tdfs(i);\n\t\t\t\tfor(int i=1;i<=n;i++)have[i]=0;\n\t\t\t}\n\t\tif(arr)cout<<\"Yes \\n\";\n\t\telse cout<<\"No \\n\";\n\t}\n\t\n\treturn 0;\n}\n```","tags":["题解","bfs","搜索","dfs"],"categories":["OI","题解"]},{"title":"OI中的和式","path":"/article/sum-in-oi/","content":"一些基础的数学知识可以为我们提供非常好的思路，这里主要介绍的是$\\sum$求和符号。\n\n> 这是一篇原始文章，不保证内容的正确性\n\n<!--more-->\n\n## 定义\n\n求和是数学中常见又基本的操作, 我们需要为它找一个记号。假设现在有一个数列$\\{ a_1,a_2,...,s_n\\}$我们需要有一种灵活又不复杂的记号, 来表示它们的和。\n\n>$\\sum\\limits^n_{i=1}a_i$\n>\n>表示数列数列$\\{a\\}$的和.\n\n\n\n这是种记号非常类似for循环的前两个语句。(记号省略了第三个语句$i++$)\n\n## 定律\n\n就像所有运算符号一样，和式也有类似的规则：\n\n$\\sum\\limits_{k\\in K}(a_k+b_k)=\\sum\\limits_{k\\in K}a_k+\\sum\\limits_{k\\in K}b_k$\n\n证明的方法是加法交换律。\n\n$\\sum\\limits_{k\\in K}ca_k=c\\sum\\limits_{k\\in K}a_k$\n\n证明的方法是乘法分配律。\n\n$\\sum\\limits_{i\\in A}a_i\\sum\\limits_{j\\in B}j_j=\\sum\\limits_{i\\in A}\\sum\\limits_{j\\in B}a_ij_j$\n\n证明的方法是加法结合律，交换也是满足的。\n\n\n\n## 问题\n\n> Description:\n>\n> 求$S_n=\\sum\\limits^n_{i=0}x^i$\n\n\n\n利用扰动法解此题：\n\n$$\n\\begin{aligned}\nS_n+x^{n+1}&=x^0+\\sum\\limits^{n+1}_{i=1}x^i\\\\\n&=x^0+\\sum\\limits^n_{i=0}x^{i+1}\\\\\n&=x^0+x\\sum\\limits^n_{i=0}x^i\\\\\n&=x^0+xS_n\\\\\n\\end{aligned}\n$$\n\n解得\n\n$$\n\\begin{aligned}\nS_n&=\\frac{1-x^{n+1}}{1-x},x\\neq 1\\\\\n&=n+1,x= 1\n\\end{aligned}\n$$","tags":["数学","随笔","笔记"],"categories":["OI"]},{"title":"简单的背包问题","path":"/article/backpack/","content":"背包问题是非常典型的动态规划问题。\n\n包括01背包，完全背包，多重背包……\n\n<!--more-->\n\n## 01背包问题\n\n有 $n$ 件物品，最大载荷为 $m$ 的背包， $f_{i,j}$ 表示有前 $i$ 个物品，总量为 $j$ 的情况的最优解\n\n### 状态转移方程\n$$\nf_{i+1,j} =\n\\left\\{\n\\begin{aligned}\n\\max (f_{i,j},f_{i,j-w_i+1}+v_i+1)\\quad  w_{i+1}\\leq j\\\\\n{f_{i,j} \\quad w_{i+1}> j}\\\\\n\\end{aligned}\n\\right.\n$$\n\n### 代码\n\n对应的代码就很简单了：\n\n```cpp\nfor(int i=0;i<=m;i++)\n\tf[0][i]=0;\nfor(int i=1;i<=n;i++)\n\tfor(int j=0;j<=m;j++){\n\t\tif(j>=w[i])\n\t\t\tf[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);\n\t\telse f[i][j]=f[i-1][j];\n    }\n```\n\n利用动态数组优化后的代码为：\n\n```cpp\nfor(int i=0;i<=m;i++)\n\tf[i]=0;\nfor(int i=1;i<=n;i++)\n\tfor(int j=m;j>=m;j--){\n\t\tif(j>=w[i])\n\t\t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\n\t\telse f[j]=f[j];\n    }\n```\n\n### 复杂度\n\n时间复杂度 $\\Theta(nm)$ ，空间线性。\n\n\n\n## 完全背包问题\n\n与01背包不同的是，每一个物品都有无数件\n\n### 代码 \n\n```cpp\nfor(int i=0;i<=m;i++)\n\tf[i]=0;\nfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=m;j++){\n\t\tif(j>=w[i])\n\t\t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\n\t\telse f[j]=f[j];\n\t}\n```\n\n内层循环正序即可实现。\n\n### 复杂度\n\n时间复杂度$\\Theta(nm)$，空间线性。","tags":["动态规划","随笔","笔记"],"categories":["OI"]},{"title":"更新日志","path":"/article/update-data/","content":"这里是更新日志，记录一些blog小规模的更新操作。\n\n<!--more-->\n\n\n\n## 2018.4.23\n\n1. 将服务转向coding加速大陆地区访问速度。\n2. 采用了lk大佬的mathjex解决方案。\n3. 提交了coding pages 免弹窗审核。\n\n## 2018.4.30\n1. 提交了百度收录sitemap。\n2. 重建了框架使访问更加迅速。\n3. 增加对移动设备的支持。\n4. coding pages出现问题。\n5. 通过不懈的努力找到问题所在。\n6. 重新提交coding免弹窗许可。\n\n## 2018.5.3\n1. 通过了coding审核。\n2. 增加了站长统计工具。\n\n## 2018.5.6\n1. 将服务转向coding pages 动态部署。\n\n## 2018.5.12\n\n1. 增强了网站安全性，关闭了所有贴图网图片。\n2. 重新使用coding pages 静态部署。\n3. 添加了Gitment评论功能。\n\n\n\n## 2018.6.5\n\n1. **重要：全线停止使用www.douglas-zhou.cn。**\n2. Gitment~~因美观程度低~~而停止使用。\n\n## 2018.7.7\n\n经过反复的调查研究，决定启用Disqus。\n\n## 2018.8.10\n\n将公式的渲染方式更改为$\\KaTeX$，使访问更加迅速。\n\n## 2018.8.21\n\n1. 发布MicDZ's blog 2.0。\n2. 使用Valine评论。\n3. 因访问速度问题，停止使用网易云音乐浮窗。\n\n## 2020.2.22\n更新了主题文档（volantis-1.5）\n\n## 2020.2.22\n1. 更新了标题规范\n2. 加入了Github修改功能","tags":["更新日志"]},{"title":"关于","path":"/about/index.html","content":"<center><b>明德厚学、求是创新</b></center><center>Undergraduate @ HUST.</center><center>Currently learning openCV, UIKit and embedded software.</center>**最近动态**"},{"title":"友链","path":"/friends/index.html","content":"长郡巨佬技术大佬各位大佬想交换友链的话，请先添加我的友链后，在下方留言，必须要有名称、头像链接、和至少一个标签哦～> 名称： MicDZ’s blog>> 头像： https://www.micdz.cn/img/h.png>> 网址： <https://www.micdz.cn/>>> 标签：OIER"},{"path":"/img/DeepLearning/神经网络与反向传播.html","content":"## 神经网络与反向传播\n\n![image-20230102112620484](/Users/micdz/Library/Application Support/typora-user-images/image-20230102112620484.png)\n\n* sigmoid函数：\n\n$$\nf(x)=\\frac{1}{1+e^{-x}}\n$$\n![image-20230102114144312](/Users/micdz/Library/Application Support/typora-user-images/image-20230102114144312.png)\n\n将 $(-\\infin,+\\infin)$ 压缩到 $(0,1)$ 。将线性分类器产生非线性的输出。\n\n* Relu函数：\n\n$$\nf=W_2\\max(0,W_1x)\n$$\n\n \n\n![image-20230102115346980](/Users/micdz/Library/Application Support/typora-user-images/image-20230102115346980.png)"},{"title":"极简倒计时","path":"/wiki/count-down/index.html","content":"本项目由2019中考倒计时修改得来\n\n感谢[Eqvpkbz](http://eqvpkbz.github.io/)大佬的帮助\n\n本项目的样式参考了 [https://gitee.com/QH_ayang/digital-time-unit](https://gitee.com/QH_ayang/digital-time-unit)\n\n## URL参数\n\n* `date`为倒计时的目标日期，格式为`YYYY/MM/DD`\n\n* `time`为倒计时的目标时刻，格式为`HH:MM`\n\n* `name`为倒计时的标题\n\n* `mode`为倒计时的样式选择，格式为`light`或`night`\n\n参数之间用`&`分隔\n\n`date`、`time`、`name`任意缺少一个或目标时刻已过都会将倒计时自动切换为2022高考倒计时\n\n`mode`不设置则默认为`night`\n\n## 使用实例\n\n获取2050高考倒计时：\n\n[https://t.micdz.cn/?name=2050高考&date=2050/06/07&time=08:00](https://t.micdz.cn/?name=2050高考&date=2050/06/07&time=08:00)\n\n![](https://t.micdz.cn/2022高考.png)"},{"title":"参与项目","path":"/wiki/daily-learning/index.html","content":"运行依赖python3、beautifulsoup4```pip install beautifulsoup4 ```将项目克隆到本地```git clone https://www.gituhb.com/MicDZ/Daily-Learning.git```导入部署项目进入项目后将Daily-Learning-Site克隆到根目录```cd Daily-Learninggit clone https://www.gituhb.com/MicDZ/Daily-Learning-Site.git```运行```python gen.py```添加爬虫* 生成文章的临时目录为`/crawler/file`。指定地址的代码为 ```py open(os.getcwd() + \"/crawler/file/Site_Name.txt\", \"w+\") ```* 以HTML标签的格式保存文章。* 不在最终打印结果中出现的内容，标签的`class`设为`no-print`。* 将爬虫放入 `crawler`，检查无误后提交PR。TODO"}]